//------------------------------------------------------------------------------
// Copyright (c) 2015-2017 Cadence Design Systems, Inc.
//
// The information herein (Cadence IP) contains confidential and proprietary
// information of Cadence Design Systems, Inc. Cadence IP may not be modified,
// copied, reproduced, distributed, or disclosed to third parties in any manner,
// medium, or form, in whole or in part, without the prior written consent of
// Cadence Design Systems Inc. Cadence IP is for use by Cadence Design Systems,
// Inc. customers only. Cadence Design Systems, Inc. reserves the right to make
// changes to Cadence IP at any time and without notice.
//------------------------------------------------------------------------------
//
//   Filename:           edma_pbuf_tx_enst_fc.v
//   Module Name:        edma_pbuf_tx_enst_fc
//
//   Release Revision:   r1p12
//   Release SVN Tag:    gem_gxl_det0102_r1p12
//
//   IP Name:            GEM Gigabit Ethernet MAC
//   IP Part Number:     IP7014
//
//   Product Type:       Off-the-shelf
//   IP Type:            Soft
//   IP Family:          Ethernet Controller
//   Technology:         N/A
//   Protocol:           Ethernet
//   Architecture:       N/A
//   Licensable IP:      SIP-Ethernet-MAC+DMA+1588+TSN+PCS-10M/100M/1G-IP7014
//
//------------------------------------------------------------------------------
//   Description :    The frame counter is counting the number of bytes
//            that we can still send to the MAC while the queue is enabled.
//            The frame counter is controlled by some signals
//            (fc_clear, fc_load, fc_decr) that are generated by an internal FSM
//            within this module. Basically if the gatestate is '1' we start loading
//            the value of the on_time (multiplied by 2.5 if 2.5Gbps operation)
//            The next cycle we start decrementing this value (that represents the number
//            of bytes we can transfer) and we will be doing this until the gatestate is high.
//            Clearly, in the state of Wait On Gate and IDLE, the clear signal is high and the
//            decrementer is set to all zero.
//            The decrementer module is stopping decrementing if eventually the number of bytes
//            reaches zero before the gatestate returns to '0'.
//
//------------------------------------------------------------------------------


//module definition
module edma_pbuf_tx_enst_fc (
   input             tx_clk,
   input             n_txreset,
   input      [16:0] on_time,       // Number of bytes that are desidered to be transferred in the on_time(nsec). We will use this formula for the calculation of the on_time(nsec):
                                    // on_time(bytes) = on_time(nsec) * rate /8 => on_time(nsec) = 8 *(on_time(bytes) / rate).
                                    //   @ 2.5 Gbps the user will have to insert on_time(bytes)/2.5 !
                                    //   @ 1   Gbps the user will have to insert on_time(bytes)
                                    //   @ 100 Mbps the user will have to insert on_time(bytes)
                                    //   @ 10  Mbps the user will have to insert on_time(bytes)
   input             fsm_active,    // Inputs received from FSM (0 if the FSM is in IDLE)
   input             gatestate,     // State of the queue(opened or closed)
   input       [1:0] speed,         // This encodes 2.5 Gbps, 1Gbps, 100Mbps, 10Mbps:
                                    //   speed = 00 for 2.5 Gbps
                                    //   speed = 01 for 1   Gbps
                                    //   speed = 10 for 100 Mbps
                                    //   speed = 11 for 10  Mbps
   output reg        gatestate_out, // Gatestate timed with the byte_count operation
   output reg [18:0] byte_count     // The number of bytes that we can still transfer so far
);

// -----------------------------------------------------------------------------
// Declaration of the signals and parameters
// -----------------------------------------------------------------------------
  wire        fc_load;
  wire        fc_decr;
  wire        fc_clear;
  wire [18:0] on_time_x2p5;  
  reg   [1:0] c_state;
  reg   [1:0] n_state;
  reg  [19:0] counter;
  reg  [19:0] counter_start_val;
  
  parameter IDLE       = 2'b00; // IDLE
  parameter WAIT_GATE  = 2'b01; // WAIT GATE
  parameter LOAD_DEC   = 2'b10; // LOAD DECREMENT
  parameter DEC        = 2'b11; // DECREMENT

  parameter sm_2_5G    = 2'b00; //speed: 2.5 Gbps
  parameter sm_1G      = 2'b01; //speed: 1   Gbps
  parameter sm_100M    = 2'b10; //speed: 100 Mbps
  parameter sm_10M     = 2'b11; //speed: 10  Mbps

// -----------------------------------------------------------------------------
// Beginning of code
// -----------------------------------------------------------------------------

  // State Machine
  // Sequential Section
  always @ (posedge tx_clk or negedge n_txreset)
  begin
    if(~n_txreset)
      c_state <= IDLE;
    else
      c_state <= n_state;
  end

  // State Machine
  // Combinatorial section
  always @ *
  begin
     if (~fsm_active)
       n_state = IDLE;
     else
       begin
         case(c_state)
           IDLE: n_state = WAIT_GATE;
           WAIT_GATE:
           begin
             if(gatestate)
               n_state = LOAD_DEC;
             else
               n_state = WAIT_GATE;
           end
           LOAD_DEC: n_state = DEC;
           default: //DEC
           begin
             if(~gatestate)
               n_state = WAIT_GATE;
             else
               n_state = DEC;
           end
         endcase
      end
  end


  //Output Logic: Combinatorial
  assign fc_load  = ( n_state == LOAD_DEC);
  assign fc_decr  = ((n_state == DEC) && (counter != 20'd0));
  assign fc_clear = ((n_state == WAIT_GATE)||(n_state == IDLE));

  // Timing the gatestate with the byte_counter fsm
  // Since the state machine in this module takes 1 clock cycle
  // in order to start the count, we don't want to anticipate
  // the gatestate signal
  always @ (posedge tx_clk or negedge n_txreset)
  begin
    if(~n_txreset)
      gatestate_out <= 1'b0;
    else
      gatestate_out <= gatestate;
  end
  
  assign on_time_x2p5 = {on_time,1'b0} + {2'b00, on_time[16:1]};
  
  always @ *
  begin
    case (speed)
      sm_2_5G : counter_start_val = {1'b0, on_time_x2p5};  // mult by 5/2
      sm_1G   : counter_start_val = {3'd0, on_time};       // For 1G
      default : counter_start_val = {2'd0, on_time, 1'b0}; // For 100M, 10M we double it
    endcase                                                // because we will count nibbles
  end

  //This counter will count each clock cycle, so if in 100/10M it will count nibbles, otherwise 
  //it will count bytes.
  always @ (posedge tx_clk or negedge n_txreset)
  begin
    if(~n_txreset)
      counter <= 20'd0;
    else
      begin
        if(fc_clear)
          counter <= 20'd0;
        else
          begin
            if(fc_load)
              counter <= counter_start_val;
            else if(fc_decr)
              counter <= counter - 20'd1;
            else
              counter <= 20'd0;
          end
      end 
  end       
                    
  // The bytecount should only be used when the EnST function is enabled therefore
  // when when inactive set the bytecount to max value
  // if 100/10M then the number of bytes will be the half we counted
  always @ *
  begin
    if(c_state == IDLE)
      byte_count = 19'h7ffff;
    else
      begin
        if(speed[1]) // 100/10Mbps, we take the half because we have counted nibbles
          byte_count = counter[19:1];
        else
          byte_count = counter[18:0];  
      end  
  end

endmodule
