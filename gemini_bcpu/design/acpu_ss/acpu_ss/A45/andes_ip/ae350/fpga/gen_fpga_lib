#!/usr/bin/perl -w

use strict;
use Cwd;
use Getopt::Long;
use File::Path;

our $gen_mem = 0;
our $gen_clk = 0;
our $gen_ila = 0; 

our $part = "xc7k160tffg676-1";		# Default: ORCA
our $part_alias;
our $debug = 0;				# Debug mode
our $timeout = 120;			# Minutes
our $job_num_per_launch = 4;		# The job number for each launch_runs call

our $mode_release = exists $ENV{"NDS_HOME"};

our $platform = cwd(); $platform =~ s|.*/andes_ip/([a-z]+[0-9]+[Pp]?)(_.*)?/fpga.*|$1|;

our $axi_platform = 0;

if (!$mode_release) {
	# In the engineering mode inside Andes, force to use the same version
	# for generating IPs.
	$ENV{TOOL_VERSIONS_CONFIG} = "xilinx/Vivado:v2018.2";
}

if ($platform ne "ae210" and $platform ne "ae250" and $platform ne "ae350") {
	die "ERROR: The detected platform '$platform' is not ae210, ae250, or ae350!";
}

if ($platform eq "ae300" or $platform eq "ae350") {
	$axi_platform = 1;
}


our @cf1_rams = qw(
	ram65536x32
	ram32768x32
	ram16384x32
	ram8192x39
	ram8192x32
	ram8192x8
	ram4096x39
	ram4096x32
	ram2048x39
	ram2048x32
	ram2048x28
	ram2048x23
	ram2048x22
	ram1024x39
	ram1024x32
	ram1024x28
	ram1024x23
	ram1024x22
	ram512x32
	ram512x28
	ram512x23
	ram512x22
	ram256x28
	ram256x23
	ram256x22
	ram128x60
	ram128x42
	ram128x38
	ram128x28
	ram128x23
	ram128x22
	ram64x62
	ram64x32
	ram32x90
	ram32x62
	ram65536x36_9b
	ram8192x36_9b
	ram4096x36_9b
	ram2048x36_9b
	ram1024x36_9b
);

# Note this memory list is a superset of both AE250 & AE350.
our @orca_rams = qw(
	ram131072x72
	ram131072x64
	ram131072x39
	ram131072x32
	ram65536x72
	ram65536x64
	ram65536x39
	ram65536x32
	ram32768x72
	ram32768x39
	ram16384x72
	ram16384x32
	ram8192x72
	ram8192x64
	ram8192x39
	ram8192x32
	ram8192x8
	ram4608x12
	ram4096x72
	ram4096x64
	ram4096x39
	ram4096x32
	ram4096x12
	ram2048x72
	ram2048x64
	ram2048x39
	ram2048x32
	ram2048x28
	ram2048x23
	ram2048x22
	ram1024x72
	ram1024x64
	ram1024x39
	ram1024x32
	ram1024x28
	ram1024x23
	ram1024x22
	dpram1024x8
	ram512x72
	ram512x64
	ram512x32
	ram512x28
	ram512x23
	ram512x22
	ram256x72
	ram256x64
	ram256x32
	ram256x28
	ram256x23
	ram256x22
	ram128x64
	ram128x60
	ram128x42
	ram128x38
	ram128x32
	dpram128x32
	ram128x28
	ram128x23
	ram128x22
	ram128x72
	ram64x62
	ram64x32
	ram64x128
	ram32x32
	ram32x62
	ram32x52
	ram32x90
	ram32x96
	ram64x42
	ram32x42
	ram16x42
	ram65536x36_9b
	ram8192x36_9b
	ram4096x36_9b
	ram2048x36_9b
	ram1024x36_9b
);


our %common_clocks = (
	"mmcm1" => "
		CONFIG.CLKOUT2_USED {true}
		CONFIG.CLKOUT3_USED {true}
		CONFIG.CLKOUT4_USED {true}
		CONFIG.CLKOUT5_USED {true}
		CONFIG.CLKOUT6_USED {true}
		CONFIG.CLKOUT7_USED {true}
		CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {60.000}
		CONFIG.CLKOUT2_REQUESTED_OUT_FREQ {30.000}
		CONFIG.CLKOUT3_REQUESTED_OUT_FREQ {40.000}
		CONFIG.CLKOUT4_REQUESTED_OUT_FREQ {20.000}
		CONFIG.CLKOUT5_REQUESTED_OUT_FREQ {20.000}
		CONFIG.CLKOUT6_REQUESTED_OUT_FREQ {66.000}
		CONFIG.CLKOUT7_REQUESTED_OUT_FREQ {60.000}",
	"mmcm_dfs" => "
		CONFIG.CLKOUT2_USED {true}
		CONFIG.CLKOUT3_USED {true}
		CONFIG.CLKOUT4_USED {true}
		CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {60.000}
		CONFIG.CLKOUT2_REQUESTED_OUT_FREQ {60.000}
		CONFIG.CLKOUT3_REQUESTED_OUT_FREQ {60.000}
		CONFIG.CLKOUT4_REQUESTED_OUT_FREQ {60.000}
		CONFIG.USE_DYN_RECONFIG {true}
		CONFIG.INTERFACE_SELECTION {Enable_AXI}",
);
our @common_ilas = qw( 
	ila4096_4x32b 
	ila16384_4x32b 
);
$| = 1;		# Flush STDOUT.

our $result = GetOptions(
	"d|debug"			=> \$debug,
	"h|help"			=> sub { usage(0); },
	"J|job_num_per_launch=i"	=> \$job_num_per_launch,
	"part=s"			=> \$part,
	"t|timeout=i"			=> \$timeout,
);

($part, $part_alias) = check_part_number($part);

my $may_use_ila = (scalar(@common_ilas) and ($platform eq "ae250" or $platform eq "ae350"));

usage(1) unless ($result);

if (scalar(@ARGV) == 0) {
	@ARGV = qw(default);
}

# Generation type check
foreach my $arg (@ARGV) {
	$arg = lc($arg);
	if ($arg eq "default") {
		$gen_mem = 1;
		$gen_clk = 1;
		if ($may_use_ila and !$mode_release) {
			# Andes internally uses ILA for debugging so generate it by default.
			$gen_ila = 1;
		}
	} elsif ($arg eq "mem" or $arg eq "ram") {
		$gen_mem = 1;
	} elsif ($arg eq "clk" or $arg eq "clock") {
		$gen_clk = 1;
	} elsif ($arg eq "ila") { 
		if ($may_use_ila) { 
			$gen_ila = 1; 
		} else {
			print STDERR "ERROR: Type 'ila' is not supported for platform '$platform'!\n";
			exit(1);
		}
	} else {
		usage(1);
	}
}

### Main function start ###

# Create work directory and change into this directory.
our $work_path = create_work_dir();

# Check environment variable NDS_HOME.
check_nds_home();

# Set installed destination path.
our $NDS_HOME = $ENV{NDS_HOME};
our $install_path;
# Users should prepare their own loader.
our $eilm32_init_file = "$NDS_HOME/andes_ip/${platform}/fpga/loader/${platform}_loader.dat";
our $eilm64_init_file = "$NDS_HOME/andes_ip/${platform}/fpga/loader/${platform}_loader_64b.dat";
our $eilmosc_init_file = "$NDS_HOME/andes_ip/${platform}/fpga/loader/${platform}_loader_osc.dat";
our $eilm128_init_file = "$NDS_HOME/andes_ip/${platform}/fpga/loader/${platform}_loader_128b.dat";
our $mem_ip_path  = "$work_path/project_mem.srcs/sources_1/ip";
our $clk_ip_path  = "$work_path/project_clk.srcs/sources_1/ip";
our $ila_ip_path  = "$work_path/project_ila.srcs/sources_1/ip"; 


our $rams_ref;

if ($part_alias eq "orca" || $part_alias eq "orca_v2") {
	if ($part_alias eq "orca_v2") {
	$install_path = "$NDS_HOME/vendor_ip/xilinx_ip/xc7k410tffg676-2";
	} else {
	$install_path = "$NDS_HOME/vendor_ip/xilinx_ip/xc7k";	# Legacy directory
	}

	$rams_ref = \@orca_rams;
} elsif ($part_alias eq "cf1") {
	$install_path = "$NDS_HOME/vendor_ip/xilinx_ip/$part";
	# Currently CF1 only has this 32-bit configuration.

	$rams_ref = \@cf1_rams;
} elsif ($part_alias eq "vcu118") {
	$install_path = "$NDS_HOME/vendor_ip/xilinx_ip/$part";

	$rams_ref = \@orca_rams;	
} elsif ($part_alias eq "cb19") {
        $install_path = "$NDS_HOME/vendor_ip/xilinx_ip/$part";

        $rams_ref = \@orca_rams;	
} else {
	$install_path = "$NDS_HOME/vendor_ip/xilinx_ip/$part";
	# Users should prepare their own loader.

	$rams_ref = \@orca_rams;
}

if ($debug) {
	print "Info: platform=$platform\n";
	print "Info: install_path=$install_path\n";

	# Only test 2 memories in the debug mode.
	splice @$rams_ref, 2;
}

# Create the destination directory if it does not exist.
check_dst_dir(	$install_path
		); 

print <<EOF;
////////////////////////////////////////////////////////////////////////////
// NOTE: Depending on the selected module types and computer performance, //
//       the overal process may take more than one hour to complete!      //
////////////////////////////////////////////////////////////////////////////
EOF

# Generate memory models.
if ($gen_mem) {
	# Generate mem.tcl for Vivado.
	gen_mem_tcl($rams_ref);

	# Execute Vivado to generate required memory model.
	gen_modules("RAM", $rams_ref);

	# Unzip dcp file to edf file.
	unzip($rams_ref);

	# Add key word to sumulation file.
	add_key_word($rams_ref);
}

# Generate clock modules.
our $prim_in_freq;
if ($gen_clk) {

	if ($part_alias eq "vcu118") {
		$prim_in_freq = 125;
	} else {
		$prim_in_freq = 20;
	}

	# Generate clk.tcl for Vivado
	gen_clk_tcl(\%common_clocks);

	# Execute Vivado to generate required clk modules.
	gen_modules("CLOCK", \%common_clocks);

	# Change the module name for clk modules.
	rename_clk_module_name(\%common_clocks);
}




# Generate ILA modules. 
if ($gen_ila) {
	# Generate ila.tcl for vivado.
	gen_ila_tcl(\@common_ilas);

	# Execute Vivado to generate required ila modules.
	gen_modules("ILA", \@common_ilas);
}


# Install required models.
install_files(	$rams_ref, 
		\%common_clocks, 
		\@common_ilas
		); 

exit(0);

### Main function end ###




# Sub functions

sub usage {
	my	$ila_line = "";  
	if ($may_use_ila) { 
		if ($mode_release) {
			$ila_line = "\n  ila:     Generate ILA modules (NOT included by \"default\")"; 
		} else {
			$ila_line = "\n  ila:     Generate ILA modules"; 
		}
	}
	print <<EOF;
Usage of the $platform version:
  gen_fpga_lib [options]

options:
  -h,--help                 Show this help message
  -J,--job_num_per_launch=JOB_NUM
                            Specify the job number for launch_runs
  -p,--part=PART            Set the FPGA part number (default $part)
  -t,--timeout=TIMEOUT      Set the timeout value in minute for each kind of
                            module generation ($timeout minutes by default)
  TYPE...                   Generation types

TYPE should be one or more of the following:
  clk:     Generate clock modules
  mem:     Generate memory modules
  default: Generate all above modules (the default)

PART may be a complete Xilinx part number such as xc7k160tffg676-1. It can
also be some predefined shorthand names as below:
  xc7k160t:    Part number xc7k160tffg676-1
  orca:        Part number xc7k160tffg676-1
  xc7k410t:    Part number xc7k410tffg676-2
  orca_v2:     Part number xc7k410tffg676-2
  cf1:         Part number xc7a100tftg256-1
  vcu118:      Part number xcvu9pflga2104-2l-e
  cb19:        Part number xcvu19p-fsva3824-2-e
EOF
	exit(defined($_[0]) ? $_[0] : 0);
}

sub create_work_dir {
	my $work_dir = "vivado_gen";
	if (-e $work_dir) {
		if (system("/bin/rm -rf $work_dir") != 0) {
			printf STDERR "ERROR: Work directory '%s' can't be successfully removed!\n", $work_dir;
			exit(1);
		}
	}
	mkdir($work_dir);
	chdir($work_dir);

	# Return the absolute path of the working directory.
	return cwd();
}

sub check_nds_home {
	unless (exists $ENV{NDS_HOME}) {
		printf STDERR "ERROR: Please set enviroment variable NDS_HOME!\n";
		exit(1);
	}
	unless (-d $ENV{NDS_HOME}) {
		printf STDERR "ERROR: NDS_HOME '%s' doesn't exist!\n", $ENV{NDS_HOME};
		exit(1);
	}
}

sub check_dst_dir {
	my (@paths) = @_;
	# The first one is the destination path for all modules. The rest are other
	# paths used by other purposes.
	my $dst_dir = $paths[0];
	my %dirs = (
		gen_ila => ["$dst_dir/ila"], 
		gen_mem => ["$dst_dir/mem"],
		gen_clk => ["$dst_dir/clk"]
	);

	foreach my $path (@paths) {
		mkpath $path unless (-e $path);
	}

	foreach my $key (keys %dirs) {
		my $gen = ${$main::{$key}};	# Get $gen_XXX.
		if ($gen) {	# Only when $gen_XXX is 1.
			foreach my $d (@{$dirs{$key}}) {
				mkdir($d) unless (-e $d);
			}
		}
	}
}

sub gen_mem_tcl {
	my @rams = @{$_[0]};
	my ($ram, $ram_type, $depth, $width);
	my $eilm_init_file;
	open(OUT, ">", "mem.tcl");
	printf OUT "create_project project_mem . -part $part -force\n\n\n";
	foreach $ram (@rams) {
		if ($ram =~ /(\D+)(\d+)x(\d+)/) {
			($ram_type, $depth, $width) = ($1, $2, $3);
		}

		printf OUT <<EOF;
### $ram ###
create_ip -name blk_mem_gen -vendor xilinx.com -library ip -module_name $ram
EOF

		if ($ram_type eq "eilm" or $ram_type eq "eilmosc") {
			if ($ram_type eq "eilmosc") {
				$eilm_init_file = $eilmosc_init_file;
			}
			elsif ($width eq "128") {
				$eilm_init_file = $eilm128_init_file;
			}
			elsif ($width eq "64") {
				$eilm_init_file = $eilm64_init_file;
			}
			else {
				$eilm_init_file = $eilm32_init_file;
			}

			printf OUT <<EOF;
set_property -dict [list \\
	CONFIG.Use_Byte_Write_Enable {true} \\
	CONFIG.Byte_Size {8} \\
	CONFIG.Write_Depth_A {$depth} \\
	CONFIG.Write_Width_A {$width} \\
	CONFIG.Read_Width_A {$width} \\
	CONFIG.Enable_A {Use_ENA_Pin} \\
	CONFIG.Register_PortA_Output_of_Memory_Primitives {false} \\
	CONFIG.Load_Init_File {true} \\
	CONFIG.Coe_File {$eilm_init_file}] \\
	[get_ips $ram]
generate_target {instantiation_template} [get_files $mem_ip_path/$ram/$ram.xci]
# update_compile_order -fileset sources_1
generate_target all [get_files $mem_ip_path/$ram/$ram.xci]
create_ip_run [get_files -of_objects [get_fileset sources_1] $mem_ip_path/$ram/$ram.xci]

EOF
		} else {	# Normal RAM (Not EILM RAM)
			if ($ram_type eq "dpram") {
				$ram_type = "CONFIG.Memory_Type {True_Dual_Port_RAM}";
			} else {
				$ram_type = "";
			}
			if ($width % 8 == 0 and $width != 24) {
				printf OUT <<EOF;
set_property -dict [list $ram_type \\
	CONFIG.Use_Byte_Write_Enable {true} \\
	CONFIG.Byte_Size {8} \\
	CONFIG.Write_Depth_A {$depth} \\
	CONFIG.Write_Width_A {$width} \\
	CONFIG.Read_Width_A {$width} \\
	CONFIG.Enable_A {Use_ENA_Pin} \\
	CONFIG.Register_PortA_Output_of_Memory_Primitives {false}] \\
	[get_ips $ram]
EOF
			} else {
				printf OUT <<EOF;
set_property -dict [list $ram_type \\
	CONFIG.Use_Byte_Write_Enable {false} \\
	CONFIG.Write_Depth_A {$depth} \\
	CONFIG.Write_Width_A {$width} \\
	CONFIG.Read_Width_A {$width} \\
	CONFIG.Enable_A {Use_ENA_Pin} \\
	CONFIG.Register_PortA_Output_of_Memory_Primitives {false}] \\
	[get_ips $ram]
EOF
			}
			printf OUT "generate_target {Simulation} [get_files %s.xci]\n", $ram;
			printf OUT "lappend runq [create_ip_run [get_files %s.xci]]\n", $ram;
		}
	}
	print OUT "\nlaunch_runs -jobs $job_num_per_launch \$runq\n";

	close(OUT);
}

sub gen_clk_tcl {
	my %clocks = %{$_[0]};
	my @clks = keys %clocks;
	open(OUT, ">", "clk.tcl");
	printf OUT "create_project project_clk . -part $part -force\n\n\n";
	foreach my $clk (@clks) {
		my $pll_settings = $clocks{$clk};
		# chomp() makes sure the last line doesn't contain the trailing
		# newline so that the following replacement won't be performed
		# there since $pll_settings has been used with "\\" below.
		chomp($pll_settings);
		$pll_settings =~ s/\s*\\?\s*\n/ \\\n/gs;

		print OUT <<EOF;
### $clk ###
create_ip -name clk_wiz -vendor xilinx.com -library ip -module_name $clk
set_property -dict [list \\
	CONFIG.PRIM_SOURCE {No_buffer} \\
	CONFIG.USE_FREQ_SYNTH {true} \\
	CONFIG.PRIM_IN_FREQ {$prim_in_freq.000} \\
	$pll_settings \\
        CONFIG.USE_PHASE_ALIGNMENT {true} \\
	CONFIG.USE_LOCKED {false} \\
	CONFIG.RESET_TYPE {ACTIVE_LOW}] \\
	[get_ips $clk]
set_property -dict [list \\
	CONFIG.CLKOUT1_DRIVES {No_buffer} \\
	CONFIG.CLKOUT2_DRIVES {No_buffer} \\
	CONFIG.CLKOUT3_DRIVES {No_buffer} \\
	CONFIG.CLKOUT4_DRIVES {No_buffer} \\
	CONFIG.CLKOUT7_DRIVES {No_buffer}] \\
	[get_ips $clk]
	lappend runq [create_ip_run [get_files $clk.xci]]

EOF
	}

	print OUT "\nlaunch_runs -jobs $job_num_per_launch \$runq\n";
	close(OUT);
}




sub gen_ila_tcl { 
	my @ilas = @{$_[0]}; 
	my ($ila, $depth, $probes, $width); 
	open(OUT, ">", "ila.tcl"); 
	printf OUT "create_project project_ila . -part $part -force\n\n\n"; 
	foreach $ila (@ilas) { 
		if ($ila =~ /ila(\d+)_(\d+)x(\d+)/) { 
			($depth, $probes, $width) = ($1, $2, $3);
		}
		print OUT <<EOF;
### $ila ### 
create_ip -name ila -vendor xilinx.com -library ip -module_name $ila 
# Configs
set_property -dict [list \\
EOF

		for (my $j = 0; $j < $probes; $j++) {
			printf OUT "	CONFIG.C_PROBE%d_WIDTH {$width} \\\n", $j;
		}
		print OUT <<EOF;
	CONFIG.C_DATA_DEPTH {$depth} \\
	CONFIG.C_NUM_OF_PROBES {$probes} \\
	CONFIG.C_TRIGOUT_EN {true} \\
	CONFIG.C_TRIGIN_EN {true} \\
	CONFIG.C_ADV_TRIGGER {true}] \\
	[get_ips $ila] 
generate_target {instantiation_template} [get_files $ila_ip_path/$ila/$ila.xci] 
generate_target all [get_files $ila_ip_path/$ila/$ila.xci] 
lappend runq [create_ip_run [get_files -of_objects [get_fileset sources_1] $ila_ip_path/$ila/$ila.xci]] 
EOF
	}
	print OUT "\nlaunch_runs -jobs $job_num_per_launch \$runq\n";

	close(OUT);
}


sub add_key_word {
	my @rams = @{$_[0]};
	my $line;
	my ($ram, $key_word, $key_word_file);
	my ($file_path, $file_content, $key_word_line);

	foreach $ram (@rams) {
		$file_path=`ls $work_path/*/*/*/$ram/sim/$ram.v`;
		chomp($file_path);
		$file_content = "";
		$key_word_line = 0;
		$key_word = "/* synthesis syn_black_box */;\n";
		open(IN, "<", $file_path);
		while ($line = <IN>) {
			if ($line =~ /module $ram \(/) {
				$key_word_line = 1;
			}
			elsif ($key_word_line == 1) {
				if ($line =~ /\)\;/) {
					$line = ")\n$key_word";
					$key_word_line = 0;
				}
			}
			$file_content .= $line;
		}
		close(IN);
		open(OUT, ">", $file_path);
		printf OUT "%s", $file_content;
		close(OUT);
	}
}

sub unzip {
	my @rams = @{$_[0]};
	my ($ram, $file_path, $cmd);

	foreach $ram (@rams) {
		$file_path = `ls $work_path/*/*/*/$ram/$ram.dcp`;
                $file_path =~ s/\/$ram.dcp//;
                chomp($file_path);
		chdir($file_path);
		$cmd = "unzip $ram.dcp $ram.edf";
		if (system("$cmd >> $ram.log") != 0) {
			printf STDERR "ERROR: Failed unzipping %s.dcp!", $ram;
			exit(1);
		}
	}
	chdir($work_path);
}

sub rename_clk_module_name {
	my %clocks = %{$_[0]};
	my ($line, $file_path, $file_content);

	foreach my $clk (keys %clocks) {
		$file_path = `ls $work_path/*/*/*/$clk/${clk}_clk_wiz.v`;
		chomp($file_path);
		$file_content = "";
		open(IN, "<", $file_path);
		while ($line = <IN>) {
			$line =~ s/module \w+/module $clk/;
#			$line =~ s/mmcme4_adv_inst/mmcm_adv_inst/;
			$file_content .= $line;
		}
		close(IN);
		open(OUT, ">", $file_path);
		printf OUT "%s", $file_content;
		close(OUT);
	}
}

sub install_files {
	my (@rams) = @{$_[0]};
	my %clocks = %{$_[1]};
	my @ilas = @{$_[2]}; 

	my ($ram,
		$clk,
		$ila  
		); 
	my ($src_file_v, $src_file_dcp, $src_file_xci, $src_file_edf);
	my ($dst_file_v, $dst_file_dcp, $dst_file_xci, $dst_file_edf);
	my ($cmd_v);

	if ($gen_mem) {
		foreach $ram (@rams) {
			$src_file_v   = `ls $work_path/*/*/*/$ram/sim/$ram.v`;
			chomp($src_file_v);
			$src_file_dcp = `ls $work_path/*/*/*/$ram/$ram.dcp`;
			chomp($src_file_dcp);
			$src_file_xci = `ls $work_path/*/*/*/$ram/$ram.xci`;
			chomp($src_file_xci);
			$src_file_edf = `ls $work_path/*/*/*/$ram/$ram.edf`;
			chomp($src_file_edf);

			$dst_file_v   = "$install_path/mem/$ram.v";
			$dst_file_dcp = "$install_path/mem/$ram.dcp";
			$dst_file_xci = "$install_path/mem/$ram.xci";
			$dst_file_edf = "$install_path/mem/$ram.edf";

			cp_file($src_file_v  , $dst_file_v  );
			cp_file($src_file_dcp, $dst_file_dcp);
			cp_file($src_file_xci, $dst_file_xci);
			cp_file($src_file_edf, $dst_file_edf);

			if ($ram =~ m/eilm/) {
				cp_file("$mem_ip_path/$ram/$ram.mif", "$install_path/mem/$ram.mif");
			}
		}
	}

	if ($gen_clk) {
		foreach my $clk (keys %clocks) {
			$src_file_v   = `ls $work_path/*/*/*/$clk/${clk}_clk_wiz.v`;
			chomp($src_file_v);
			$src_file_dcp = `ls $work_path/*/*/*/$clk/$clk.dcp`;
			chomp($src_file_dcp);
			$src_file_xci = `ls $work_path/*/*/*/$clk/$clk.xci`;
			chomp($src_file_xci);

			$dst_file_v   = "$install_path/clk/$clk.v";
			$dst_file_dcp = "$install_path/clk/$clk.dcp";
			$dst_file_xci = "$install_path/clk/$clk.xci";

			cp_file($src_file_v  , $dst_file_v  );
			cp_file($src_file_dcp, $dst_file_dcp);
			cp_file($src_file_xci, $dst_file_xci);
		}
	}

	if ($gen_ila) {
		foreach $ila (@ilas) {
			$src_file_v   = `ls $work_path/*/*/*/$ila/${ila}_stub.v`;
			chomp($src_file_v);
			$src_file_dcp = `ls $work_path/*/*/*/$ila/$ila.dcp`;
			chomp($src_file_dcp);
			$src_file_xci = `ls $work_path/*/*/*/$ila/$ila.xci`;
			chomp($src_file_xci);

			$dst_file_v   = "$install_path/ila/${ila}_stub.v";
			$dst_file_dcp = "$install_path/ila/$ila.dcp";
			$dst_file_xci = "$install_path/ila/$ila.xci";

			cp_file($src_file_v, $dst_file_v);
			cp_file($src_file_dcp, $dst_file_dcp);
			cp_file($src_file_xci, $dst_file_xci);
		}
	}
}

sub cp_file {
	my ($src_file, $dst_file) = @_;
	my $cmd = "/bin/cp -f $src_file $dst_file";

	if (system($cmd) != 0) {
		printf STDERR "ERROR: Failed copying file %s to %s!\n", $src_file, $dst_file;
		exit(1);
	}
}

sub check_part_number {
	my ($given_part) = @_;
	my ($part, $part_alias);

	if ($given_part eq "xc7k160t" || $given_part eq "xc7k160tffg676-1" || $given_part eq "orca") {
		$part = "xc7k160tffg676-1"; $part_alias = "orca";
	} elsif ($given_part eq "xc7k410t" || $given_part eq "xc7k410tffg676-2" || $given_part eq "orca_v2") {
		$part = "xc7k410tffg676-2"; $part_alias = "orca_v2";
	} elsif ($given_part eq "100t" || $given_part eq "xc7a100tftg256-1" || $given_part eq "cf1") {
		$part = "xc7a100tftg256-1"; $part_alias = "cf1";
	} elsif ($given_part eq "vu9p" || $given_part eq "vcu118") {
		$part = "xcvu9p-flga2104-2L-e"; $part_alias = "vcu118";
	} elsif ($given_part eq "vu19p" || $given_part eq "cb19") {
                $part = "xcvu19p-fsva3824-2-e"; $part_alias = "cb19";
	} else {
		$part = $given_part;	    $part_alias = $part;
	}

	return ($part, $part_alias);
}

sub get_timestamp {
	my ($sec, $min, $hour, $mday, $mon, ) = localtime(time);

	return sprintf("%02d/%02d %02d:%02d:%02d", $mon+1, $mday, $hour, $min, $sec);
}

sub run_module_generation {
	my ($kind, $cmd, $log_file) = @_;
	my $t = time;

        system("vivado -version");
	printf <<EOF;
////////////////////////
$kind module generation
////////////////////////
// Command: $cmd
EOF

	printf "%s> Preparing...", get_timestamp();

	if (system("$cmd > $log_file") != 0) {
		printf STDERR "\nERROR: Failed generating %s modules. See %s for details. Please also check if the corresponding license is available.\n", $kind, $log_file; 
		exit(1);
	} else {
		print "\n";
	}

	return ($t, time);
}

sub wait_for_module_generation_use_log {
       my ($kind, $file_log) = @_;
       #my ($kind, $mods_ref, $file_log) = @_;
       #my ($mod_name, @files, $this_module_done);
       my $t;
       my $error = 0;
       $t = time;
       printf "%s> Waiting for %s module generations...", get_timestamp(), $kind;
       if (chk_complete($file_log)){
	    $error = 1;
       }
       printf "\n%s> Check $kind synth runme.log", get_timestamp();
       open(FH, $file_log) or die("File $file_log not found");
       while(<FH>){
       		if($_ =~ /runme.log/){
       			my @values = split(':', $_);
       			if(chk_complete( $values[1])){
				$error = 1;
			}
                        else {
                                alarm($timeout * 60);    # Re-start the timeout counter.
                        }
       		}
       }
       close(FH);
       if( $error){
	       printf "\n%s> $kind module generation failed.\n", get_timestamp();
       }
       else{
       		printf "\n%s> All $kind module generation successfully.\n", get_timestamp();
       }


       return ($t, time);
}

sub wait_for_module_generation {
	my ($kind, $mods_ref, @file_tmpls) = @_;
	my ($mod_name, @files, $this_module_done);
	my $first_done = 0;
	my $t;

	printf "%s> Waiting for %s module generations...", get_timestamp(), $kind;
	while (@$mods_ref) {
		for (my $i = $#{$mods_ref}; $i >= 0; --$i) {
			$mod_name = $mods_ref->[$i];
			@files = map { my $a = $_; $a =~ s/%s/$mod_name/eg; $a } @file_tmpls;
			# Check if all related files have been generated for this module.
			$this_module_done = 1;
			foreach my $file (@files) {
				if (! -e $file) {
					$this_module_done = 0;
					last;
				}
			}
			if ($this_module_done) {
				printf "\n%s> Module %s generation done (%d left)", get_timestamp(), $mods_ref->[$i], $#{$mods_ref};
				splice(@$mods_ref, $i, 1);
				alarm($timeout * 60);	# Re-start the timeout counter.
				if ($first_done == 0) {		# Record the time of the first finished module.
					$first_done = 1;
					$t = time;
				}
			}
		}
		print "." if (scalar(@$mods_ref) != 0);
		sleep 1;
	}

	printf "\n%s> All $kind modules are generated.\n", get_timestamp();
	return ($t, time);
}

sub gen_time_tuple {
	my $t = $_[0];
	return ($t / 3600, ($t % 3600) / 60, $t % 60);
}

sub gen_modules {
	my ($kind, $mods_ref) = @_;

	my (@mods, $tcl_file, $log_file, $cmd);
	my ($t0, $t1, $t2, $t3);

	# Use legacy file names.
	if ($kind eq "RAM") {
		$tcl_file = "mem.tcl";
	} elsif ($kind eq "CLOCK") {
		$tcl_file = "clk.tcl";
	} elsif ($kind eq "ILA") {
		$tcl_file = "ila.tcl";
	} else {
		exit(1);
	}
	$log_file = "gen_${tcl_file}.log";
	$log_file =~ s/\.tcl.log/.log/;

	$cmd = "vivado -mode batch -source $tcl_file";

	# We shouldn't affect the original list/hash so lets use the copy.
	if (ref($mods_ref) eq "HASH") {
		@mods = keys(%$mods_ref);
	} else {
		@mods = @$mods_ref;
	}

	$SIG{ALRM} = sub {
		printf STDERR "\n%s> ERROR: Timeout generating following %s modules:\n", get_timestamp(), $kind;
		print "\t$_\n" foreach @mods;
		exit(1);
	};

	alarm($timeout * 60);
	($t0, $t1) = run_module_generation($kind, $cmd, $log_file);
	($t2, $t3) = wait_for_module_generation_use_log($kind, $log_file);
	alarm(0);
	printf "Info: %02d:%02d:%02d time spent (%02d:%02d:%02d %02d:%02d:%02d %02d:%02d:%02d)\n", 
		gen_time_tuple($t3-$t0), gen_time_tuple($t1-$t0), gen_time_tuple($t2-$t1),
		gen_time_tuple($t3-$t2);
}


sub chk_complete {
	my ($log_file) = @_;
	my $gen_done = 0;
	my $error = 0;
	printf "\n%s> Check %s ...", get_timestamp(), $log_file;
	while(!$gen_done) {
		open(FCH, $log_file) or die("File $log_file not found");
		while(<FCH>){
			if($_ =~ /Exiting Vivado/){
				$gen_done = 1;
				$error= 0;
			}
			if($_ =~ /ERROR:/ ){
				print "**ERROR**";
				$gen_done = 1;
				$error = 1;
			}
		}
		close(FCH);
		print "." if ($gen_done == 0);
		sleep 5;
	}
	printf "Exiting Vivado";
	return ($error);
}

