--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 7.4 Revision 4 from HDL Works B.V.
--
-- Ease library  : work
-- HDL library   : work
-- Host name     : S212065
-- User name     : df768
-- Time stamp    : Tue Aug 19 08:05:18 2014
--
-- Designed by   : L.Maarsen
-- Company       : LogiXA
-- Project info  : eSoC
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity work.esoc_port_mal_control
-- Last modified : Mon Apr 14 12:49:06 2014.
--------------------------------------------------------------------------------



library ieee, std, work;
use ieee.std_logic_1164.all;
use std.textio.all;
use ieee.numeric_std.all;
use work.package_esoc_configuration.all;

entity esoc_port_mal_control is
  generic(
    esoc_port_nr : integer := 0);
  port(
    clk_control            : in     STD_LOGIC;
    ctrl_address           : in     std_logic_vector(15 downto 0);
    ctrl_rd                : in     std_logic := '0';
    ctrl_rddata            : out    std_logic_vector(31 downto 0);
    ctrl_wait              : out    STD_LOGIC;
    ctrl_wr                : in     std_logic;
    ctrl_wrdata            : in     std_logic_vector(31 downto 0);
    force_vlan_default_in  : out    std_logic;
    force_vlan_default_out : out    std_logic;
    magic_sleep_n          : out    STD_LOGIC := '1';
    magic_wakeup           : in     STD_LOGIC;
    port_vlan_default      : out    std_logic_vector(15 downto 0);
    reset                  : in     STD_LOGIC;
    xoff_gen               : out    STD_LOGIC;
    xon_gen                : out    STD_LOGIC);
end entity esoc_port_mal_control;

--------------------------------------------------------------------------------
-- Object        : Architecture work.esoc_port_mal_control.esoc_port_mal_control
-- Last modified : Mon Apr 14 12:49:06 2014.
--------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------
-- architecture and declarations
---------------------------------------------------------------------------------------------------------------
architecture esoc_port_mal_control of esoc_port_mal_control is

---------------------------------------------------------------------------------------------------------------
-- registers
---------------------------------------------------------------------------------------------------------------
constant reg_port_mal_vlan_default_add: integer                                := 385;
signal reg_port_mal_vlan_default: std_logic_vector(31 downto 0);
constant reg_port_mal_vlan_default_rst: std_logic_vector(31 downto 0)          := X"00000001";
  alias 	 reg_port_mal_vlan_default_force_out: std_logic is reg_port_mal_vlan_default(31);
  alias 	 reg_port_mal_vlan_default_force_in : std_logic is reg_port_mal_vlan_default(30);

constant reg_port_mal_stat_ctrl_add           : integer                        := 384;
signal   reg_port_mal_stat_ctrl               : std_logic_vector(31 downto 0);
constant reg_port_mal_stat_ctrl_rst           : std_logic_vector(31 downto 0) := X"00000001";
  alias 	 reg_port_mal_stat_ctrl_xon_gen     : std_logic is reg_port_mal_stat_ctrl(3);
  alias 	 reg_port_mal_stat_ctrl_xoff_gen    : std_logic is reg_port_mal_stat_ctrl(2);
  alias 	 reg_port_mal_stat_ctrl_magic_wakeup: std_logic is reg_port_mal_stat_ctrl(1);
  alias 	 reg_port_mal_stat_ctrl_magic_sleep : std_logic is reg_port_mal_stat_ctrl(0);

---------------------------------------------------------------------------------------------------------------
-- signals
---------------------------------------------------------------------------------------------------------------
signal ctrl_rddata_i: std_logic_vector(ctrl_rddata'high downto 0);
signal ctrl_wait_i: std_logic;
signal ctrl_bus_enable: std_logic;

begin

--=============================================================================================================
-- Process		  : access registers when addressed or provide data from other units to the ctrl_rddata_i bus
-- Description	: 
--=============================================================================================================    
registers:  process(clk_control, reset)
            begin
              if reset = '1' then
              
                reg_port_mal_vlan_default <= reg_port_mal_vlan_default_rst;
              
                -- all ports have weight 1 after reset
                reg_port_mal_stat_ctrl <= reg_port_mal_stat_ctrl_rst;
                ctrl_rddata_i   <= (others => '0');
                ctrl_wait_i     <= '1';
                ctrl_bus_enable <= '0';
                              
              elsif clk_control'event and clk_control = '1' then
                reg_port_mal_stat_ctrl_magic_wakeup <= magic_wakeup;
                ctrl_wait_i     <= '1';
                ctrl_bus_enable <= '0';
                
                -- continu if memory space of this entity is addressed
                if (to_integer(unsigned(ctrl_address)) >= esoc_port_nr * esoc_port_base_offset + esoc_port_mal_base) and (to_integer(unsigned(ctrl_address)) < esoc_port_nr * esoc_port_base_offset + esoc_port_mal_base + esoc_port_mal_size) then
                  -- claim the bus for ctrl_wait and ctrl_rddata
                  ctrl_bus_enable <= '1';
                                  
                  -- 
	                -- READ CYCLE started, unit addressed?
	                --
	                if ctrl_rd = '1' then
	                	-- Check register address and provide data when addressed
	                  case to_integer(unsigned(ctrl_address))- esoc_port_nr * esoc_port_base_offset is
                      when reg_port_mal_vlan_default_add  =>  ctrl_rddata_i <= reg_port_mal_vlan_default;
                                                              ctrl_wait_i <= '0';
                                                                        
                      when reg_port_mal_stat_ctrl_add     =>  ctrl_rddata_i <= reg_port_mal_stat_ctrl;
                                                              ctrl_wait_i <= '0';
                                                          
                      when others                         =>  NULL;
                    end case;
                                
                  --
                  -- WRITE CYCLE started, unit addressed?
                  --
                  elsif ctrl_wr = '1' then
                  	-- Check address and accept data when addressed
                  	case to_integer(unsigned(ctrl_address))- esoc_port_nr * esoc_port_base_offset is
                      when reg_port_mal_vlan_default_add => reg_port_mal_vlan_default <= ctrl_wrdata;
                                                            ctrl_wait_i <= '0';
                      
                      when reg_port_mal_stat_ctrl_add    =>  reg_port_mal_stat_ctrl <= ctrl_wrdata;
                                                            ctrl_wait_i <= '0';
                                                          
                      when others                        =>  NULL;
                    end case;
                  end if;
                end if;
              end if;
            end process;
                                                
            -- Create tristate outputs
            ctrl_wait       <= ctrl_wait_i    when ctrl_bus_enable = '1' else 'Z';
            ctrl_rddata     <= ctrl_rddata_i  when ctrl_bus_enable = '1' else (others => 'Z');
            
            -- use register content
            force_vlan_default_out  <= reg_port_mal_vlan_default_force_out;    
            force_vlan_default_in   <= reg_port_mal_vlan_default_force_in;
            
            port_vlan_default       <= reg_port_mal_vlan_default(port_vlan_default'high downto 0);
            
            magic_sleep_n	          <= reg_port_mal_stat_ctrl_magic_sleep;
            xoff_gen    	          <= reg_port_mal_stat_ctrl_xoff_gen;
				    xon_gen      	          <= reg_port_mal_stat_ctrl_xon_gen;
        
end architecture esoc_port_mal_control ; -- of esoc_port_mal_control

