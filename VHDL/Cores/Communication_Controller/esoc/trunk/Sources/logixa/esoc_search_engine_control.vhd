--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 7.4 Revision 4 from HDL Works B.V.
--
-- Ease library  : work
-- HDL library   : work
-- Host name     : S212065
-- User name     : df768
-- Time stamp    : Tue Aug 19 08:05:18 2014
--
-- Designed by   : L.Maarsen
-- Company       : LogiXA
-- Project info  : eSoC
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity work.esoc_search_engine_control
-- Last modified : Mon Apr 14 12:49:59 2014.
--------------------------------------------------------------------------------



library ieee, std, work;
use ieee.std_logic_1164.all;
use std.textio.all;
use ieee.numeric_std.all;
use work.package_esoc_configuration.all;

entity esoc_search_engine_control is
  port(
    clk_control               : in     std_logic;
    clk_search                : in     std_logic;
    ctrl_address              : in     std_logic_vector(15 downto 0);
    ctrl_rd                   : in     std_logic;
    ctrl_rddata               : out    std_logic_vector(31 downto 0);
    ctrl_wait                 : out    std_logic;
    ctrl_wr                   : in     std_logic;
    ctrl_wrdata               : in     std_logic_vector(31 downto 0);
    reset                     : in     std_logic;
    search_entry_age_time     : out    std_logic_vector(11 downto 0);
    search_entry_age_time_ena : out    std_logic;
    search_sa_drop_cnt        : in     std_logic;
    search_sa_overload_cnt    : in     std_logic);
end entity esoc_search_engine_control;

--------------------------------------------------------------------------------
-- Object        : Architecture work.esoc_search_engine_control.esoc_search_engine_control
-- Last modified : Mon Apr 14 12:49:59 2014.
--------------------------------------------------------------------------------


architecture esoc_search_engine_control of esoc_search_engine_control is
---------------------------------------------------------------------------------------------------------------
-- registers
---------------------------------------------------------------------------------------------------------------
constant reg_search_engine_sa_overload_count_add: integer                           := 2;
signal reg_search_engine_sa_overload_count: std_logic_vector(31 downto 0);
signal reg_search_engine_sa_overload_count_i: std_logic_vector(31 downto 0);
constant reg_search_engine_sa_overload_count_rst: std_logic_vector(31 downto 0)     := X"00000000";

constant reg_search_engine_sa_drop_count_add: integer                               := 1;
signal reg_search_engine_sa_drop_count: std_logic_vector(31 downto 0);
signal reg_search_engine_sa_drop_count_i: std_logic_vector(31 downto 0);
constant reg_search_engine_sa_drop_count_rst: std_logic_vector(31 downto 0)         := X"00000000";

constant reg_search_engine_stat_ctrl_add: integer                                   := 0;
signal reg_search_engine_stat_ctrl: std_logic_vector(31 downto 0);
constant reg_search_engine_stat_ctrl_rst: std_logic_vector(31 downto 0)             := X"8000012C";
constant reg_search_engine_stat_ctrl_rst_sim: std_logic_vector(31 downto 0)         := X"00000002";
  alias  reg_search_engine_stat_ctrl_age_timer_ena : std_logic is reg_search_engine_stat_ctrl(31);
  alias  reg_search_engine_stat_ctrl_age_timer     : std_logic_vector(11 downto 0) is reg_search_engine_stat_ctrl(11 downto 0);
  
---------------------------------------------------------------------------------------------------------------
-- signals
---------------------------------------------------------------------------------------------------------------
signal search_sa_cnt_update_ack_sync: std_logic_vector(esoc_meta_ffs-1 downto 0);
signal search_sa_cnt_update_sync    : std_logic_vector(esoc_meta_ffs-1 downto 0);
signal search_sa_cnt_update         : std_logic;
signal search_sa_cnt_update_ack     : std_logic;

signal ctrl_rddata_i: std_logic_vector(ctrl_rddata'high downto 0);
signal ctrl_wait_i: std_logic;
signal ctrl_bus_enable: std_logic;

begin

--=============================================================================================================
-- Process		  : access registers when addressed or provide data  to the ctrl_rddata_i bus
-- Description	: 
--=============================================================================================================    
registers:  process(clk_control, reset)
            begin
              if reset = '1' then
                -- Reset value depends on esoc mode, simulation requires short aging timer
                if esoc_mode = simulation then
                  reg_search_engine_stat_ctrl <= reg_search_engine_stat_ctrl_rst_sim;
                else
                  reg_search_engine_stat_ctrl <= reg_search_engine_stat_ctrl_rst;
                end if;
                
                ctrl_rddata_i   <= (others => '0');
                ctrl_wait_i     <= '1';
                ctrl_bus_enable <= '0';
                              
              elsif clk_control'event and clk_control = '1' then
                ctrl_wait_i     <= '1';
                ctrl_bus_enable <= '0';
                
                -- continu if memory space of this entity is addressed
                if (to_integer(unsigned(ctrl_address)) >= esoc_search_engine_base) and (to_integer(unsigned(ctrl_address)) < esoc_search_engine_base + esoc_search_engine_size) then
                  -- claim the bus for ctrl_wait and ctrl_rddata
                  ctrl_bus_enable <= '1';
                  
                  -- 
	                -- READ CYCLE started, unit addressed?
	                --
	                if ctrl_rd = '1' then
	                	-- Check register address and provide data when addressed
	                  case to_integer(unsigned(ctrl_address)) - esoc_search_engine_base is
	                    when reg_search_engine_sa_overload_count_add  =>  if search_sa_cnt_update_ack = '1' then
                                                                          ctrl_rddata_i <= reg_search_engine_sa_overload_count;
                                                                          ctrl_wait_i <= '0';
                                                                        end if;
                                                                    
                      when reg_search_engine_sa_drop_count_add      =>  if search_sa_cnt_update_ack = '1' then
                                                                          ctrl_rddata_i <= reg_search_engine_sa_drop_count;
                                                                          ctrl_wait_i <= '0';
                                                                        end if;
                                                                
                      when reg_search_engine_stat_ctrl_add          =>  ctrl_rddata_i <= reg_search_engine_stat_ctrl;
                                                                        ctrl_wait_i <= '0';
                                                                
                      when others                                   =>  NULL;
                    end case;
                                
                  --
                  -- WRITE CYCLE started, unit addressed?
                  --
                  elsif ctrl_wr = '1' then
                  	-- Check address and accept data when addressed
                  	case to_integer(unsigned(ctrl_address)) - esoc_search_engine_base is
                      when reg_search_engine_stat_ctrl_add  =>  reg_search_engine_stat_ctrl <= ctrl_wrdata;
                                                                ctrl_wait_i <= '0';

                      when others                           =>  NULL;
                    end case;
                  end if;
                end if;
              end if;
            end process;
            
            -- Create tristate outputs
            ctrl_wait   <= ctrl_wait_i    when ctrl_bus_enable = '1' else 'Z';
            ctrl_rddata <= ctrl_rddata_i  when ctrl_bus_enable = '1' else (others => 'Z');

            -- use register content
            search_entry_age_time     <= reg_search_engine_stat_ctrl_age_timer;
            search_entry_age_time_ena <= reg_search_engine_stat_ctrl_age_timer_ena;
            
--=============================================================================================================
-- Process		  : Update counters and transfer values from search clock domain to control clock domain
-- Description	: 
--=============================================================================================================    
sync1a: process(clk_search, reset)
        begin
          if reset = '1' then
            reg_search_engine_sa_drop_count_i <= reg_search_engine_sa_drop_count_rst;
            reg_search_engine_sa_overload_count_i <= reg_search_engine_sa_overload_count_rst;
              
          elsif clk_search'event and clk_search = '1' then
            -- Update source address DROP counter
            if search_sa_drop_cnt = '1' then
              reg_search_engine_sa_drop_count_i <= std_logic_vector(to_unsigned(to_integer(unsigned(reg_search_engine_sa_drop_count_i)) + 1,reg_search_engine_sa_drop_count_i'length));
            end if;
            
            -- Update source address OVERLOAD counter
            if search_sa_overload_cnt = '1' then
              reg_search_engine_sa_overload_count_i <= std_logic_vector(to_unsigned(to_integer(unsigned(reg_search_engine_sa_overload_count_i)) + 1,reg_search_engine_sa_overload_count_i'length));
            end if;
          end if;
        end process;

sync1b: process(clk_search, reset)
        begin
          if reset = '1' then
            search_sa_cnt_update  <= '0';
            search_sa_cnt_update_ack_sync <= (others => '0');
            reg_search_engine_sa_drop_count <= reg_search_engine_sa_drop_count_rst;
            reg_search_engine_sa_overload_count <= reg_search_engine_sa_overload_count_rst;

          elsif clk_search'event and clk_search = '1' then
            -- synchronise update acknowledge indication
            search_sa_cnt_update_ack_sync <= search_sa_cnt_update_ack & search_sa_cnt_update_ack_sync(search_sa_cnt_update_ack_sync'high downto 1);
          
            -- no running update? start updating the other clock domain, use a copy of the counters, because they can change during the update!
            if search_sa_cnt_update = '0' and search_sa_cnt_update_ack_sync(0) = '0' then
              search_sa_cnt_update <= '1';
              reg_search_engine_sa_drop_count <= reg_search_engine_sa_drop_count_i;
              reg_search_engine_sa_overload_count <= reg_search_engine_sa_overload_count_i;
            
            -- finalize update when acknowledge is received
            elsif search_sa_cnt_update_ack_sync(0) = '1' then
              search_sa_cnt_update <= '0';
            end if;
          end if;
        end process;
        
sync1c: process(clk_control, reset)
        begin
          if reset = '1' then
            search_sa_cnt_update_sync  <= (others => '0');
          
          -- synchronise counter update indication
          elsif clk_control'event and clk_control = '1' then
            search_sa_cnt_update_sync <= search_sa_cnt_update & search_sa_cnt_update_sync(search_sa_cnt_update_sync'high downto 1);
          end if;
        end process;  
        
        -- send update acknowledge
        search_sa_cnt_update_ack <=  search_sa_cnt_update_sync(0);  
               
end architecture esoc_search_engine_control ; -- of esoc_search_engine_control

