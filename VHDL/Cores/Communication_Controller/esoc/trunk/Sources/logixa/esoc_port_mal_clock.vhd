--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 7.4 Revision 4 from HDL Works B.V.
--
-- Ease library  : work
-- HDL library   : work
-- Host name     : S212065
-- User name     : df768
-- Time stamp    : Tue Aug 19 08:05:18 2014
--
-- Designed by   : L.Maarsen
-- Company       : LogiXA
-- Project info  : eSoC
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity work.esoc_port_mal_clock
-- Last modified : Mon Apr 14 12:49:01 2014.
--------------------------------------------------------------------------------



library ieee, std, work;
use ieee.std_logic_1164.all;
use std.textio.all;
use ieee.numeric_std.all;
use work.package_esoc_configuration.all;

entity esoc_port_mal_clock is
  port(
    clk_control    : in     STD_LOGIC;
    clk_rgmii      : out    std_logic;
    clk_rgmii_125m : in     std_logic;
    clk_rgmii_25m  : in     std_logic;
    clk_rgmii_2m5  : in     std_logic;
    ena_10         : in     STD_LOGIC;
    eth_mode       : in     STD_LOGIC;
    reset          : in     STD_LOGIC;
    set_10         : out    STD_LOGIC := '0'; -- '0'
    set_1000       : out    STD_LOGIC := '0');
end entity esoc_port_mal_clock;

--------------------------------------------------------------------------------
-- Object        : Architecture work.esoc_port_mal_clock.esoc_port_mal_clock
-- Last modified : Mon Apr 14 12:49:01 2014.
--------------------------------------------------------------------------------


architecture esoc_port_mal_clock of esoc_port_mal_clock is

constant clk_off: std_logic := '1';
constant clk_on: std_logic := '0';

signal clk125m: std_logic;
signal clk125_stop: std_logic;
signal clk125_stopped: std_logic;
signal clk125_stop_reg: std_logic_vector(1 downto 0);
signal clk125_stopped_reg: std_logic_vector(1 downto 0);
constant clk125m_reset: std_logic := clk_off;

signal clk25m: std_logic;
signal clk25_stop: std_logic;
signal clk25_stopped: std_logic;
signal clk25_stop_reg: std_logic_vector(1 downto 0);
signal clk25_stopped_reg: std_logic_vector(1 downto 0);
constant clk25m_reset: std_logic := clk_on;

signal clk2m5: std_logic;
signal clk2m5_stop: std_logic;
signal clk2m5_stopped: std_logic;
signal clk2m5_stop_reg: std_logic_vector(1 downto 0);
signal clk2m5_stopped_reg: std_logic_vector(1 downto 0);
constant clk2m5_reset: std_logic := clk_off;

type speeds is (none, s10m, s100m, s1000m);
signal speed_setting: speeds;
signal speed_current: speeds;

type switch_states is (idle, wait_for_stop);
signal switch_state: switch_states;

begin

-- Define unused speed control signals
set_10 <= '0';
set_1000 <= '0';

-- Create speed select signals
speed_setting <=  s1000m when reset = '1'  else 
                  s10m when eth_mode = '0' and ena_10 = '1' else
                  s100m when eth_mode = '0' and ena_10 = '0' else
                  s1000m;

-- Clock control 125MHz
clk125ctl:  process (clk_rgmii_125m, reset)
            begin
                if reset = '1' then
                    clk125_stop_reg <= (others => clk125m_reset);
                
                -- synchronize stop input command with clock   
                elsif clk_rgmii_125m'event and clk_rgmii_125m = '1' then
                    clk125_stop_reg <= clk125_stop & clk125_stop_reg(clk125_stop_reg'high downto 1);
                    
                end if;
            end process clk125ctl;
            
            -- use synchronized stop commando to switch on/off clock, reply with stopped indication
            clk125m         <= clk_rgmii_125m when clk125_stop_reg(0) = '0' else '1';
            clk125_stopped  <= clk125_stop_reg(0);
            
-- Clock control 25MHz
clk25ctl:  process (clk_rgmii_25m, reset)
            begin
                if reset = '1' then
                    clk25_stop_reg <= (others => clk25m_reset);
                
                -- synchronize stop input command with clock       
                elsif clk_rgmii_25m'event and clk_rgmii_25m = '1' then
                    clk25_stop_reg <= clk25_stop & clk25_stop_reg(clk25_stop_reg'high downto 1);
                
                end if;
            end process clk25ctl;

            -- use synchronized stop commando to switch on/off clock, reply with stopped indication
            clk25m        <= clk_rgmii_25m when clk25_stop_reg(0) = '0' else '1';
            clk25_stopped <= clk25_stop_reg(0);
            
-- Clock control 2.5MHz
clk2m5ctl:  process (clk_rgmii_2m5, reset)
            begin
                if reset = '1' then
                    clk2m5_stop_reg <= (others => clk2m5_reset);
                    
                -- synchronize stop input command with clock       
                elsif clk_rgmii_2m5'event and clk_rgmii_2m5 = '1' then
                    clk2m5_stop_reg <= clk2m5_stop & clk2m5_stop_reg(clk2m5_stop_reg'high downto 1);
                    
                end if;
            end process clk2m5ctl;

            -- use synchronized stop commando to switch on/off clock, reply with stopped indication
            clk2m5 <= clk_rgmii_2m5 when clk2m5_stop_reg(0) = '0' else '1';
            clk2m5_stopped <= clk2m5_stop_reg(0);

-- Clock switch
clkswitch:  process (clk_control, reset)
            begin
                if reset = '1' then
                    clk125_stop        <= clk125m_reset;
                    clk25_stop         <= clk25m_reset;
                    clk2m5_stop        <= clk2m5_reset;
                    clk125_stopped_reg <= (others => clk125m_reset);
                    clk25_stopped_reg  <= (others => clk25m_reset);
                    clk2m5_stopped_reg <= (others => clk2m5_reset);
                    speed_current      <= s1000m;
                    switch_state       <= idle;
                    
                elsif clk_control'event and clk_control = '1' then
                    -- store speed setting for change detection
                    speed_current <= speed_setting;
                
                    -- synchronize stopped indication with clock 
                    clk125_stopped_reg <= clk125_stopped & clk125_stopped_reg(clk125_stopped_reg'high downto 1);
                    clk25_stopped_reg <= clk25_stopped & clk25_stopped_reg(clk25_stopped_reg'high downto 1);
                    clk2m5_stopped_reg <= clk2m5_stopped & clk2m5_stopped_reg(clk2m5_stopped_reg'high downto 1);

                    case switch_state is
                        when idle   =>          -- Send stop command to all clock source when setting changed
                                                if speed_current /= speed_setting then
                                                    clk125_stop <= '1';
                                                    clk25_stop <= '1';
                                                    clk2m5_stop <= '1';
                                                    switch_state <= wait_for_stop;
                                                end if;
                                        
                        when wait_for_stop =>   -- When setting is stable, wait for stopped indication of all clock sources
                                                if speed_current /= speed_setting then
                                                    NULL;
                                                    
                                                elsif clk125_stopped_reg(0) = '1' and clk25_stopped_reg(0) = '1' and clk2m5_stopped_reg(0) = '1' then
                                                    -- enable only the required clock source by deasserting its stop input
                                                    if speed_setting = s10m then
                                                        clk2m5_stop <= '0';
                                                    elsif speed_setting = s100m then
                                                        clk25_stop <= '0';
                                                    elsif speed_setting = s1000m then
                                                        clk125_stop <= '0';
                                                    end if;
                                            
                                                    switch_state <= idle;
                                                end if;
                                                
                        when others       =>    switch_state <= idle;
                    end case;
                    
                end if;
            end process clkswitch;
            
            -- Drive RGMII interface clock, push/force clock onto clock network (if not done by tool)
            clk_rgmii <= clk125m and clk25m and clk2m5;
            --clk_rgmii <= clk_rgmii_125m;
            
end architecture esoc_port_mal_clock ; -- of esoc_port_mal_clock
