--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 7.4 Revision 4 from HDL Works B.V.
--
-- Ease library  : work
-- HDL library   : work
-- Host name     : S212065
-- User name     : df768
-- Time stamp    : Tue Aug 19 08:05:18 2014
--
-- Designed by   : L.Maarsen
-- Company       : LogiXA
-- Project info  : eSoC
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity work.esoc_port_mal_outbound
-- Last modified : Mon Apr 14 12:49:17 2014.
--------------------------------------------------------------------------------



library ieee, std, work;
use ieee.std_logic_1164.all;
use std.textio.all;
use ieee.numeric_std.all;
use work.package_esoc_configuration.all;

entity esoc_port_mal_outbound is
  port(
    clk_control            : in     STD_LOGIC;
    ff_tx_a_empty          : in     STD_LOGIC;
    ff_tx_a_full           : in     STD_LOGIC;
    ff_tx_crc_fwd          : out    STD_LOGIC;
    ff_tx_data             : out    STD_LOGIC_VECTOR(31 downto 0);
    ff_tx_eop              : out    STD_LOGIC;
    ff_tx_err              : out    STD_LOGIC;
    ff_tx_mod              : out    STD_LOGIC_VECTOR(1 downto 0);
    ff_tx_rdy              : in     STD_LOGIC;
    ff_tx_septy            : in     STD_LOGIC;
    ff_tx_sop              : out    STD_LOGIC;
    ff_tx_wren             : out    STD_LOGIC;
    force_vlan_default_out : in     std_logic;
    outbound_data          : in     std_logic_vector(31 downto 0);
    outbound_data_read     : out    std_logic;
    outbound_info          : in     std_logic_vector(15 downto 0);
    outbound_info_empty    : in     std_logic;
    outbound_info_read     : out    std_logic;
    port_vlan_default      : in     std_logic_vector(15 downto 0);
    reset                  : in     STD_LOGIC;
    tx_ff_uflow            : in     STD_LOGIC);
end entity esoc_port_mal_outbound;

--------------------------------------------------------------------------------
-- Object        : Architecture work.esoc_port_mal_outbound.esoc_port_mal_outbound
-- Last modified : Mon Apr 14 12:49:17 2014.
--------------------------------------------------------------------------------


architecture esoc_port_mal_outbound of esoc_port_mal_outbound is

---------------------------------------------------------------------------------------------------------------
-- registers
---------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------
-- signals
---------------------------------------------------------------------------------------------------------------
type   ff_tx_states is (idle, running, drop);
signal ff_tx_state: ff_tx_states;

signal ff_tx_byte_counter: integer range 2**esoc_outbound_info_length_size-1 downto 0;
signal ff_tx_word_counter: integer range ((2**esoc_outbound_info_length_size)/4)-1 downto 0;

signal outbound_data_read_enable: std_logic;
signal outbound_data_read_dummy: std_logic;
signal outbound_data_modify_enable: std_logic;
signal outbound_data_modify: std_logic_vector(outbound_data'high downto 0);

signal outbound_info_vlan_flag: std_logic;

signal boundary64: std_logic;

begin

           
--=============================================================================================================
-- Process		  : capture and store data when ready acycle occurs
-- Description	: 
--=============================================================================================================    
capture:    process(clk_control, reset)
            begin
              if reset = '1' then
                ff_tx_sop     <= '0';
                ff_tx_eop     <= '0';
                ff_tx_wren    <= '0';
                ff_tx_mod     <= (others => '0');
                ff_tx_byte_counter <= 0;
                ff_tx_word_counter <= 0;
                
                outbound_info_vlan_flag   <= '0';
                
                outbound_data_modify_enable <= '0';
                outbound_data_modify <= (others => '0');
                
                outbound_info_read        <= '0';
                outbound_data_read_dummy   <= '0';
                outbound_data_read_enable <= '0';
                
                boundary64    <= '0';
              
              elsif clk_control'event and clk_control = '1' then
                -- clear one-clock active signals
                outbound_info_read          <= '0';
                outbound_data_read_dummy    <= '0';
                outbound_data_modify_enable <= '0';
                
                case ff_tx_state is
                  when idle =>      -- create dummy read if the previous transaction does not end on a 64 bit boundary
                                    if boundary64 = '1' then
                                      boundary64 <= '0';
                                      outbound_data_read_dummy <= '1';
                                    
                                    -- Info fifo not empty? Get length from info fifo and acknowledge info fifo read! Start packet transmission.
                                    elsif outbound_info_empty = '0' then
                                      -- get the length, subtract 4 byes because first word is provided on ST interface immediately, acknowledge info from fifo
                                      outbound_info_read      <= '1';
                                      ff_tx_word_counter      <= 0;
                                      ff_tx_byte_counter      <= to_integer(unsigned(outbound_info(esoc_outbound_info_length+esoc_outbound_info_length_size-1 downto esoc_outbound_info_length)))-4;
                                      outbound_info_vlan_flag <= outbound_info(esoc_outbound_info_vlan_flag);
                                      
                                      -- send packet to MAC or drop packet if an error is indicated, error can be packet in data FIFO not complete due to overrun
                                      if outbound_info(esoc_outbound_info_error_flag) = '0' then
                                        outbound_data_read_enable <= '1';
                                        ff_tx_sop                 <= '1';
                                        ff_tx_wren                <= '1';
                                        ff_tx_state               <= running;
                                      
                                      -- receive data has an error, drop it!
                                      else
                                        outbound_data_read_dummy  <= '1';
                                        ff_tx_state               <= drop;
                                      end if;
                                    end if;
                  
                  when running =>   -- provide next data when ready is asserted (=acknowledge of current data)
                                    if ff_tx_rdy = '1' then
                                      --
                                      -- CONTROL THE ST INTERFACE TO MAC
                                      --
                                      -- deassert the start of packet
                                      ff_tx_sop <= '0';
                                      
                                      -- last word of transaction read by ST Sink port, stop transfer
                                      if ff_tx_byte_counter = 0 then
                                        outbound_data_read_enable <= '0';
                                        ff_tx_eop                 <= '0';
                                        ff_tx_wren                <= '0';
                                        ff_tx_state               <= idle;
                                      
                                      -- last word of transaction to be read by ST Sink port?
                                      elsif ff_tx_byte_counter <= 4 then
                                        ff_tx_eop <= '1';
                                        ff_tx_byte_counter <= 0;
                                        ff_tx_mod <= std_logic_vector(to_unsigned(4-ff_tx_byte_counter,ff_tx_mod'length));
                                      
                                      -- transaction not finished, update counter
                                      else
                                        ff_tx_byte_counter <= ff_tx_byte_counter - 4;
                                      end if;
                                      
                                      -- toggle to know from which boundary is read, 32b or 64b
                                      boundary64 <= not(boundary64);
                                      
                                      --
                                      -- MANIPULATE DATA
                                      --
                                      -- modify vlan id with default vlan id if packet is tagged and force default vlan is enabled
                                      if ff_tx_word_counter = 2 then
                                        if outbound_info_vlan_flag = '1' and force_vlan_default_out = '1' then
                                          outbound_data_modify_enable <= '1';
                                          outbound_data_modify        <= esoc_ethernet_vlan_type & port_vlan_default;
                                        end if;
                                      end if;
                                      
                                      ff_tx_word_counter <= ff_tx_word_counter + 1;
                                      
                                    end if;
                  
                  when drop =>      -- read erroneous packet from FIFO and drop!  
                                    -- size of packet always multiple of 8 bytes, no boundary64 mechanism required
                                    if ff_tx_byte_counter <= 4 then
                                      ff_tx_state <= idle;
                                    
                                    else
                                      ff_tx_byte_counter <= ff_tx_byte_counter - 4;
                                    end if;  
                                                                     
                                    outbound_data_read_dummy  <= '1';
                                    
                  when others =>    ff_tx_state <= idle;
                end case;
              end if;
            end process;
         
            ff_tx_err           <= '0';
            ff_tx_crc_fwd       <= '0';
            ff_tx_data          <= outbound_data when outbound_data_modify_enable = '0' else outbound_data_modify;
            outbound_data_read  <= (ff_tx_rdy and outbound_data_read_enable) or outbound_data_read_dummy;
            
end architecture esoc_port_mal_outbound ; -- of esoc_port_mal_outbound
