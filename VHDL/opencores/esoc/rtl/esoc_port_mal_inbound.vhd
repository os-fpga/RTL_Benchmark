--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 7.4 Revision 4 from HDL Works B.V.
--
-- Ease library  : work
-- HDL library   : work
-- Host name     : S212065
-- User name     : df768
-- Time stamp    : Tue Aug 19 08:05:18 2014
--
-- Designed by   : L.Maarsen
-- Company       : LogiXA
-- Project info  : eSoC
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity work.esoc_port_mal_inbound
-- Last modified : Mon Apr 14 12:49:11 2014.
--------------------------------------------------------------------------------



library ieee, std, work;
use ieee.std_logic_1164.all;
use std.textio.all;
use ieee.numeric_std.all;
use work.package_esoc_configuration.all;

entity esoc_port_mal_inbound is
  port(
    clk_control           : in     STD_LOGIC;
    ff_rx_a_empty         : in     STD_LOGIC;
    ff_rx_a_full          : in     STD_LOGIC;
    ff_rx_data            : in     STD_LOGIC_VECTOR(31 downto 0);
    ff_rx_dsav            : in     STD_LOGIC;
    ff_rx_dval            : in     STD_LOGIC;
    ff_rx_eop             : in     STD_LOGIC;
    ff_rx_mod             : in     STD_LOGIC_VECTOR(1 downto 0);
    ff_rx_rdy             : out    STD_LOGIC;
    ff_rx_sop             : in     STD_LOGIC;
    force_vlan_default_in : in     std_logic;
    inbound_data          : out    std_logic_vector(31 downto 0);
    inbound_data_full     : in     std_logic;
    inbound_data_write    : out    std_logic;
    inbound_header        : out    std_logic_vector(111 downto 0);
    inbound_header_write  : out    std_logic;
    inbound_info          : out    std_logic_vector(31 downto 0);
    inbound_info_write    : out    std_logic;
    port_vlan_default     : in     std_logic_vector(15 downto 0);
    reset                 : in     STD_LOGIC;
    rx_err_stat           : in     STD_LOGIC_VECTOR(17 downto 0);
    rx_frm_type           : in     STD_LOGIC_VECTOR(3 downto 0));
end entity esoc_port_mal_inbound;

--------------------------------------------------------------------------------
-- Object        : Architecture work.esoc_port_mal_inbound.esoc_port_mal_inbound
-- Last modified : Mon Apr 14 12:49:11 2014.
--------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------
-- architecture and declarations
---------------------------------------------------------------------------------------------------------------
architecture esoc_port_mal_inbound of esoc_port_mal_inbound is

---------------------------------------------------------------------------------------------------------------
-- registers
---------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------
-- signals
---------------------------------------------------------------------------------------------------------------
signal ff_rx_counter: integer range 2**esoc_inbound_info_length_size-1 downto 0;

signal boundary64: std_logic; 
signal boundary64_write: std_logic; 

begin
          
--=============================================================================================================
-- Process		  : write header and information - DMAC, SMAC, VLAN ID, LENGTH, FLAGS  - into HEADER and INFO FIFO
-- Description	: header information is used by the search process in the esoc_port_processor
--                info information is used by the data process in the esoc_port_processor
--=============================================================================================================    
infoheader: process(clk_control, reset)
            begin
              if reset = '1' then
                inbound_header          <= (others => '0');
                inbound_info            <= (others => '0');
                inbound_data            <= (others => '0');
                
                inbound_header_write    <= '0';
                inbound_info_write      <= '0';
                inbound_data_write      <= '0';
                
                ff_rx_counter           <= 0;
                boundary64              <= '0';
                boundary64_write        <= '0';
              
              elsif clk_control'event and clk_control = '1' then
                -- clear one-clock active signals
                inbound_header_write  <= '0';
                inbound_info_write    <= '0';
                inbound_data_write    <= '0';
                boundary64_write      <= '0';

                -- define unused bits to avoid inferred latch warning during analysis & synthesis
                inbound_header(esoc_inbound_header_unused3_flag downto esoc_inbound_header_unused1_flag) <= (others => '0');
                inbound_info(esoc_inbound_info_unused3_flag downto esoc_inbound_info_unused1_flag) <= (others => '0');
                  
                --
                -- MONITOR THE ST INTERFACE TO MAC
                --
                -- finalise packet storage, always write at 64b boundaries, because the other side of the FIFO has a width of 64 bit!
                -- create dummy write if the packet at completion does not end on a 64 bit boundary.  
                inbound_data_write <= boundary64_write;
                
                if ff_rx_dval = '1' then
                  -- store data in FIFO
                  if ff_rx_sop = '1' or ff_rx_counter > 0 then
                    inbound_data_write    <= '1';
                    inbound_data          <= ff_rx_data;
                    ff_rx_counter         <= ff_rx_counter + 4;
                    
                    -- init boundary64 signal at start of new packet
                    if ff_rx_sop = '1' then
                      boundary64 <= '1';
                    else
                      boundary64 <= not(boundary64);
                    end if;
                  end if;
                
                  --
                  -- MANIPULATE DATA
                  --
                  case ff_rx_counter is
                    when 0  =>      -- store DMAC (4 MSbs) in data FIFO and prepare header FIFO input
                                    if ff_rx_sop = '1' then
                                      inbound_header(esoc_inbound_header_dmac_hi+31 downto esoc_inbound_header_dmac_hi) <= ff_rx_data;
                                    end if;
                                    
                    when 4  =>      -- store DMAC (2LSBs), SMAC (2MSBs) in data FIFO and prepare header FIFO input
                                    inbound_header(esoc_inbound_header_dmac_lo+15 downto esoc_inbound_header_smac_hi) <= ff_rx_data;
                                    
                    when 8  =>      -- store SMAC (4 LSBs) in data FIFO and prepare header FIFO input
                                    inbound_header(esoc_inbound_header_smac_lo+31 downto esoc_inbound_header_smac_lo) <= ff_rx_data;
                                    
                    when 12 =>      -- tagged packet? store VLAN ID/TCI in data FIFO and prepare header FIFO input
                                    if ff_rx_data(31 downto 16) = esoc_ethernet_vlan_type then
                                      -- tagged with VLAN ID 0 is a QoS Packet only - or force default VLAN ID - replace VLAN ID with port default VLAN ID
                                      if ff_rx_data(11 downto 0) = esoc_ethernet_vlan_qos or force_vlan_default_in = '1' then
                                        inbound_data(15 downto 0) <= port_vlan_default;
                                        
                                        -- store default port VLAN ID in the header FIFO for the search operation
                                        inbound_header(esoc_inbound_header_vlan+11 downto esoc_inbound_header_vlan) <= port_vlan_default(11 downto 0);
                                        inbound_header(esoc_inbound_header_vlan_flag) <= '1';
                                        
                                        -- store  default port VLAN tag in the info FIFO for the data transfer operation
                                        inbound_info(esoc_inbound_info_vlan_tci+15 downto esoc_inbound_info_vlan_tci) <= port_vlan_default;
                                        inbound_info(esoc_inbound_info_vlan_flag) <= '1';
                                      
                                      -- tagged with VLAN ID > 0
                                      else
                                        -- store only VLAN ID in the header FIFO for the search operation
                                        inbound_header(esoc_inbound_header_vlan+11 downto esoc_inbound_header_vlan) <= ff_rx_data(11 downto 0);
                                        inbound_header(esoc_inbound_header_vlan_flag) <= '1';
                                        
                                        -- store comlete VLAN tag in the info FIFO for the data transfer operation
                                        inbound_info(esoc_inbound_info_vlan_tci+15 downto esoc_inbound_info_vlan_tci) <= ff_rx_data(15 downto 0);
                                        inbound_info(esoc_inbound_info_vlan_flag) <= '1';
                                      end if;
                                    
                                    -- untagged packet
                                    else
                                      -- store default port VLAN ID in the header FIFO for the search operation
                                      inbound_header(esoc_inbound_header_vlan+11 downto esoc_inbound_header_vlan) <= port_vlan_default(11 downto 0);
                                      inbound_header(esoc_inbound_header_vlan_flag) <= '0';
                                      
                                      -- store  default port VLAN tag in the info FIFO for the data transfer operation
                                      inbound_info(esoc_inbound_info_vlan_tci+15 downto esoc_inbound_info_vlan_tci) <= port_vlan_default;
                                      inbound_info(esoc_inbound_info_vlan_flag) <= '0';
                                    end if;
                                    
                                    -- write header when complete, search operation can start!
                                    inbound_header_write <= '1';
                                
                    when others =>  -- Write information in to fifo when packet is complete, data operation can start!
                                    if ff_rx_eop = '1' then
                                      ff_rx_counter    <= 0;
                                      inbound_info(esoc_inbound_info_length+esoc_inbound_info_length_size-1 downto esoc_inbound_info_length) <= std_logic_vector(to_unsigned(ff_rx_counter + 4 - to_integer(unsigned(ff_rx_mod)),esoc_inbound_info_length_size));
                                      inbound_info_write <= '1';
                                      boundary64_write <= not(boundary64);
                                    end if;
                  end case; 
                end if;          
              end if;
            end process;

--=============================================================================================================
-- Process		  : write packet into DATA FIFO
-- Description	: 
--=============================================================================================================                
            -- FULL signal of FIFO is used to drive READY of ST Sink interface
            ff_rx_rdy <= not(inbound_data_full);

end architecture esoc_port_mal_inbound ; -- of esoc_port_mal_inbound
