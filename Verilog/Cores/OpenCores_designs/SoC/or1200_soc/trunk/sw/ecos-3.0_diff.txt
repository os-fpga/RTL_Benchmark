diff -NaurbBw /opt/ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/ChangeLog ./ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/ChangeLog
--- /opt/ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/ChangeLog	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/ChangeLog	2009-09-16 14:04:52.000000000 -0700
@@ -0,0 +1,40 @@
+2003-03-06  Scott Furman <sfurman@rosum.com>
+	* src/openrisc_orp_flash.c, cdl/flash_openrisc_orp.cdl
+	  New package:  Flash programming for AMD AM29LVxxxxx devices
+	  used with OpenRISC Reference Platform (ORP).
+
+//===========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
diff -NaurbBw /opt/ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/cdl/flash_openrisc_orp.cdl ./ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/cdl/flash_openrisc_orp.cdl
--- /opt/ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/cdl/flash_openrisc_orp.cdl	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/cdl/flash_openrisc_orp.cdl	2009-09-16 14:04:52.000000000 -0700
@@ -0,0 +1,70 @@
+# ====================================================================
+#
+#      flash_openrisc_orp.cdl
+#
+#      FLASH memory - Hardware support for OpenRISC Reference Platform
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      jskov
+# Contributors:   jskov
+# Date:           2000-12-05
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_DEVS_FLASH_OPENRISC_ORP {
+    display       "Flash memory support for OpenRISC ORP"
+
+    parent        CYGPKG_IO_FLASH
+    active_if     CYGPKG_IO_FLASH
+    requires      CYGPKG_HAL_OPENRISC_ORP
+
+    implements    CYGHWR_IO_FLASH_DEVICE
+
+    compile       openrisc_orp_flash.c
+
+    # Arguably this should do in the generic package
+    # but then there is a logic loop so you can never enable it.
+    cdl_interface CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED {
+        display   "AMD AM29LV160 driver required"
+    }
+
+    implements    CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED
+    requires      CYGHWR_DEVS_FLASH_AMD_AM29LV160
+}
diff -NaurbBw /opt/ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/src/openrisc_orp_flash.c ./ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/src/openrisc_orp_flash.c
--- /opt/ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/src/openrisc_orp_flash.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/devs/flash/openrisc/orp/v3_0/src/openrisc_orp_flash.c	2009-09-16 14:04:52.000000000 -0700
@@ -0,0 +1,70 @@
+//==========================================================================
+//
+//      openrisc_orp_flash.c
+//
+//      Flash programming for AMD AM29LVxxxxx devices connected to OpenRISC
+//      Reference Platform (ORP).
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    jskov
+// Contributors: jskov
+// Date:         2001-05-22
+// Purpose:      
+// Description:  
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+//--------------------------------------------------------------------------
+// Device properties
+
+#define CYGNUM_FLASH_INTERLEAVE	(1)
+#define CYGNUM_FLASH_SERIES	(1)
+#define CYGNUM_FLASH_WIDTH      (16)
+#define CYGNUM_FLASH_BASE 	(0xF0000000)
+
+//--------------------------------------------------------------------------
+// Platform specific extras
+
+//--------------------------------------------------------------------------
+// Now include the driver code.
+#include "cyg/io/flash_am29xxxxx.inl"
+
+// ------------------------------------------------------------------------
+// EOF mips_ocelot_flash.c
diff -NaurbBw /opt/ecos-3.0/packages/ecos.db ./ecos-3.0/packages/ecos.db
--- /opt/ecos-3.0/packages/ecos.db	2009-03-27 01:58:47.000000000 -0700
+++ ./ecos-3.0/packages/ecos.db	2010-02-05 16:35:58.480650900 -0800
@@ -270,6 +270,17 @@
 	   on the PMC-Sierra Ocelot platform."
 }
 
+package CYGPKG_DEVS_FLASH_OPENRISC_ORP {
+	alias 		{ "Support for flash memory for OpenRISC Reference Platform (ORP)"
+	                   flash_openrisc_orp }
+	directory	devs/flash/openrisc/orp
+	script		flash_openrisc_orp.cdl
+	hardware
+        description "
+           This package contains hardware support for AM29xxxxx flash memory
+	   on the OpenRISC Reference Platform."
+}
+
 package CYGPKG_DEVS_FLASH_MIPS_VRC437X {
 	alias 		{ "Support for flash memory on VRC437X boards" flash_vrc437x }
 	directory	devs/flash/mips/vrc437x
@@ -6152,6 +6163,63 @@
             eCos on a Allied Telesyn TS1000 (PPC855T) board."
 }
 
+# --------------------------------------------------------------------------
+# OpenRISC targets
+
+package CYGPKG_HAL_OPENRISC {
+	alias		{ "OpenRISC HAL" hal_openrisc openrisc_hal }
+	directory	hal/openrisc/arch
+	script		hal_openrisc.cdl
+	hardware
+	description "
+	   The OpenRISC architecture HAL package provides generic
+           support for this processor architecture. It is also necessary to
+           select a specific target platform HAL package."  }
+
+package CYGPKG_HAL_OPENRISC_ORP {
+	alias		{ "OpenRISC Reference Platform" hal_orp orp_hal }
+	directory	hal/openrisc/orp
+	script		hal_openrisc_orp.cdl
+	hardware
+	description "
+           The OpenRISC Reference Platform (ORP) package should be used
+           with ORP-compliant simulators or hardware. "
+}
+
+target ORP {
+	alias { "OpenRISC Refererence Platform" orp }
+	packages { CYGPKG_HAL_OPENRISC
+             CYGPKG_HAL_OPENRISC_ORP
+	           CYGPKG_DEVS_FLASH_OPENRISC_ORP
+		         CYGPKG_DEVS_FLASH_AMD_AM29XXXXX
+	}
+        description "
+        The ORP (OpenRISC Reference Platform) target provides the packages
+        needed to run eCos in simulator or HW environments that conform to the 
+        OpenRISC Reference Platform."
+}
+
+package CYGPKG_HAL_OPENRISC_OR1200_SOC {
+	alias		{ "OpenRISC or1200_soc Platform" hal_or1200_soc or1200_soc_hal }
+	directory	hal/openrisc/or1200_soc
+	script		hal_openrisc_or1200_soc.cdl
+	hardware
+	description "
+           The OpenRISC or1200_soc Platform. "
+}
+
+target OR1200_SOC {
+	alias { "OpenRISC or1200_soc Platform" or1200_soc }
+	packages { CYGPKG_HAL_OPENRISC
+             CYGPKG_HAL_OPENRISC_OR1200_SOC
+	           CYGPKG_DEVS_FLASH_OPENRISC_ORP
+		         CYGPKG_DEVS_FLASH_AMD_AM29XXXXX
+	}
+        description "
+        The or1200_soc target provides the packages
+        needed to run eCos."
+}
+
 package CYGPKG_DEVS_FLASH_UE250 {
 	alias 		{ "FLASH memory support for uE250" flash_uE250 }
 	directory	devs/flash/arm/uE250
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/ChangeLog ./ecos-3.0/packages/hal/openrisc/arch/v3_0/ChangeLog
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/ChangeLog	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/ChangeLog	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,45 @@
+2003-04-17  Scott Furman <sfurman@rosum.com>
+        + Init tick timer on boot
+        + Ensure stack is aligned in HAL_INIT_CONTEXT()
+	+ Add .text.ram section for time-critical code
+
+
+2003-03-06  Scott Furman <sfurman@rosum.com>
+
+        Initial port of eCos to OpenRISC architecture
+
+//===========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/cdl/hal_openrisc.cdl ./ecos-3.0/packages/hal/openrisc/arch/v3_0/cdl/hal_openrisc.cdl
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/cdl/hal_openrisc.cdl	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/cdl/hal_openrisc.cdl	2010-02-09 09:08:43.561765600 -0800
@@ -0,0 +1,111 @@
+# ====================================================================
+#
+#      hal_openrisc.cdl
+#
+#      OpenRISC architectural HAL package configuration data
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 2003 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      sfurman
+# Original data:  bartv, nickg
+# Contributors:   jskov
+# Date:           2003-02-28
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_HAL_OPENRISC {
+    display "OpenRISC architecture"
+    parent        CYGPKG_HAL
+    hardware
+    include_dir   cyg/hal
+    define_header hal_openrisc.h
+    description   "
+        The OpenRISC architecture HAL package provides generic support
+        for this processor architecture. It is also necessary to
+        select a specific target platform HAL package."
+
+# For now, there are no defined variants of the OpenRISC
+#    cdl_interface CYGINT_HAL_OPENRISC_VARIANT {
+#        display  "Number of variant implementations in this configuration"
+#        requires 1 == CYGINT_HAL_OPENRISC_VARIANT
+#    }
+
+    compile       context.S vectors.S hal_misc.c openrisc_stub.c
+
+    make {
+        <PREFIX>/lib/vectors.o : <PACKAGE>/src/vectors.S
+        $(CC) -Wp,-MD,vectors.tmp $(INCLUDE_PATH) $(CFLAGS) -c -o $@ $<
+        @echo $@ ": \\" > $(notdir $@).deps
+        @tail vectors.tmp >> $(notdir $@).deps
+        @echo >> $(notdir $@).deps
+        @rm vectors.tmp
+    }
+
+    define_proc {
+        puts $::cdl_header "#define HAL_ARCH_PROGRAM_NEW_STACK hal_arch_program_new_stack"
+    }
+
+    cdl_option CYGBLD_LINKER_SCRIPT {
+        display "Linker script"
+        flavor data
+        no_define
+        calculated  { "src/openrisc.ld" }
+    }
+
+    make {
+        <PREFIX>/lib/target.ld: <PACKAGE>/src/openrisc.ld
+        $(CC) -E -P -Wp,-MD,target.tmp -DEXTRAS=1 -xc $(INCLUDE_PATH) $(CFLAGS) -o $@ $<
+        @echo $@ ": \\" > $(notdir $@).deps
+        @tail target.tmp >> $(notdir $@).deps
+        @echo >> $(notdir $@).deps
+        @rm target.tmp
+    }
+
+    cdl_option CYGHWR_HAL_OPENRISC_CPU_FREQ {
+        display "CPU frequency"
+        flavor  data
+        legal_values 0 to 1000000
+        default_value 104
+        description "
+           This option contains the frequency of the CPU in MegaHertz.
+           Choose the frequency to match the processor you have. This
+           may affect thing like serial device, interval clock and
+           memory access speed settings."
+    }
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/README.html ./ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/README.html
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/README.html	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/README.html	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,39 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+  <title>README - eCos OpenRISC Port</title>
+   
+</head>
+<body>
+ For those unfamiliar with OpenRISC, it is an open-source RISC/DSP processor 
+architecture. &nbsp;OpenCores.org makes available an <a
+ href="http://www.opencores.org/projects/or1k">implementation</a> of this 
+architecture that can be synthesized, for example, as part of an FPGA or ASIC.
+&nbsp;The port of eCos to OpenRISC was sponsored by the <a
+ href="http://www.rosum.com">Rosum Corporation</a>.<br>
+ <br>
+ A few notes and caveats about the eCos OpenRISC port: 
+<ul>
+   <li>The only platform supported at this time is ORP (OpenRISC Reference 
+Platform).</li>
+   <li>The only ORP devices supported so far are serial ports used for  
+  diagnostic and debugging purposes and AM29LVxxxx Flash ROM.</li>
+   <li>To build and debug, you must build the GNU development tools from
+    <a
+ href="#%20http://www.opencores.org/projects/or1k/GNU%20Toolchain%20Port">source 
+available at the OpenCores web site</a> -- not the versions      available 
+from the GNU  web site or elsewhere. &nbsp;There is a <a
+ href="./build_or32_elf_tools.sh">shell script</a> in this directory that 
+will assist in downloading     and building the GNU toolchain.</li>
+   <li>For debugging, you can use either gdb's JTAG target or the serial
+    target.  The latter has some advantages, e.g. the gdb serial target is
+thread-aware, but it is much slower, especially while     simulating.<br>
+  </li>
+ 
+</ul>
+ Scott Furman<br>
+ <i>sfurman at rosum dot com</i><br>
+ <br>
+ 
+</body>
+</html>
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/build_or32_elf_tools.sh ./ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/build_or32_elf_tools.sh
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/build_or32_elf_tools.sh	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/doc/build_or32_elf_tools.sh	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,156 @@
+#!/bin/bash -x
+
+# Checkout and build gnu toolchain for OpenRISC (or32 target)
+
+# Usage:
+# build_or32_elf_tools.sh [-c]
+#   -c  Controls whether CVS checkout is done prior to build
+#       You probably only want to use this command-line option the first time you build.
+
+# Directory in which to checkout sources and build
+BUILD_DIR=$HOME/or32-elf-src
+
+# Target architecture/OS
+TARGET=or32-elf
+
+# Directory in which to put compiled files, exported headers, etc.
+INSTALL_PREFIX=$HOME/tools/i386-redhat-linux
+
+########################################################################
+
+if [ $1foo = -cfoo ]; then DO_CVS_CHECKOUT=1; else DO_CVS_CHECKOUT=0; fi
+
+#
+# Some common variables
+#
+OK_STR="Build OK"
+FAIL_STR="Build Failed"
+
+mkdir -p $BUILD_DIR
+cd $BUILD_DIR
+
+#
+# Start with binutils
+#
+if [ $DO_CVS_CHECKOUT != 0 ]; then
+date > checkout_binutils.log 2>&1
+cvs -d :pserver:cvs@cvs.opencores.org:/home/oc/cvs -z9 co -d binutils or1k/binutils >> \
+ checkout_binutils.log 2>&1
+fi
+
+mkdir -p b-b
+cd b-b
+date > ../build_binutils.log 2>&1
+
+../binutils/configure --target=$TARGET --prefix=$INSTALL_PREFIX >> ../build_binutils.log 2>&1
+
+make all install >> ../build_binutils.log 2>&1
+BUILD_BINUTILS_STATUS=$?
+export PATH=$INSTALL_PREFIX/bin:$PATH
+cd ..
+
+#
+# Check if binutils was built and installed correctly
+#
+if [ $BUILD_BINUTILS_STATUS = 0 ]; then
+        echo "$OK_STR (`date`)" >> build_binutils.log
+else
+        echo "$FAIL_STR (`date`)" >>  build_binutils.log
+fi
+
+#
+# Build gdb
+#
+if [ $DO_CVS_CHECKOUT != 0 ]; then
+date > checkout_gdb.log 2>&1
+cvs -d :pserver:cvs@cvs.opencores.org:/home/oc/cvs -z9 co -d gdb or1k/gdb-5.0 >> checkout_gdb.log 2>&1
+fi
+
+mkdir -p b-gdb
+cd b-gdb
+date > ../build_gdb.log 2>&1
+# Current version of readline has a configuration bug, so you must not specify
+# the prefix
+#../gdb/configure --target=$TARGET --prefix=$INSTALL_PREFIX >> ../build_gdb.log 2>&1
+../gdb/configure --target=$TARGET >> ../build_gdb.log 2>&1
+make all >> ../build_gdb.log 2>&1
+BUILD_GDB_STATUS=$?
+cp gdb/gdb $INSTALL_PREFIX/bin/$TARGET-gdb
+cd ..
+
+
+#
+# Check if gdb was built and installed correctly
+#
+if [ $BUILD_GDB_STATUS = 0 ]; then
+        echo "$OK_STR (`date`)" >> build_gdb.log
+else
+        echo "$FAIL_STR (`date`)" >>  build_gdb.log
+fi
+
+#
+# Build or1k simulator
+#
+if [ $DO_CVS_CHECKOUT != 0 ]; then
+date > checkout_or1ksim.log 2>&1
+cvs -d :pserver:cvs@cvs.opencores.org:/home/oc/cvs -z9 co -d or1ksim or1k/or1ksim >> checkout_or1ksim.log 2>&1
+fi
+
+cd or1ksim
+date > ../build_or1ksim.log 2>&1
+../or1ksim/configure --target=$TARGET --prefix=$INSTALL_PREFIX >> ../build_or1ksim.log 2>&1
+make all install >> ../build_or1ksim.log 2>&1
+BUILD_OR1KSIM_STATUS=$?
+cp sim $INSTALL_PREFIX/bin/or32-elf-sim
+cd ..
+
+#
+# Check if or1ksim was built and installed correctly
+#
+if [ $BUILD_OR1KSIM_STATUS = 0 ]; then
+        echo "$OK_STR (`date`)" >> build_or1ksim.log
+else
+        echo "$FAIL_STR (`date`)" >>  build_or1ksim.log
+fi
+
+# For now, bail here
+#exit
+
+#
+# Build gcc
+#
+if [ $DO_CVS_CHECKOUT != 0 ]; then
+date > checkout_gcc.log 2>&1
+cvs -d :pserver:cvs@cvs.opencores.org:/home/oc/cvs -z9 co -d gcc or1k/gcc-3.1 >> checkout_gcc.log 2>&1
+fi
+
+# The config script looks for libraries in a weird place.  Instead of figuring out what's wrong,
+# I just placate it.
+
+pushd $INSTALL_PREFIX
+cp -pr lib $TARGET
+popd
+
+mkdir -p b-gcc
+cd b-gcc
+date > ../build_gcc.log 2>&1
+../gcc/configure --target=$TARGET \
+        --with-gnu-as --with-gnu-ld --verbose \
+        --enable-threads --prefix=$INSTALL_PREFIX \
+        --enable-languages="c,c++" >> ../build_gcc.log 2>&1
+make all install >> ../build_gcc.log 2>&1
+BUILD_GCC_STATUS=$?
+
+#
+# Check if gcc was built and installed correctly
+#
+if [ $BUILD_GCC_STATUS = 0 ]; then
+        echo "$OK_STR (`date`)" >> build_gcc.log
+else
+        echo "$FAIL_STR (`date`)" >>  build_gcc.log
+fi
+
+# Install even though g++ build fails due to inability to build libg++ without C library.
+# (How do we prevent building of libg++ ?)
+make install
+
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/arch.inc ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/arch.inc
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/arch.inc	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/arch.inc	2010-02-15 15:18:28.366085800 -0800
@@ -0,0 +1,107 @@
+##=============================================================================
+##
+##      arch.inc
+##
+##      OpenRISC assembler header file
+##
+##=============================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+##=============================================================================
+#######DESCRIPTIONBEGIN####
+##
+## Author(s):   sfurman
+## Contributors:
+## Date:        2003-01-15
+## Purpose:     Architecture definitions.
+## Description: This file contains various definitions and macros that are
+##              useful for writing assembly code for the OpenRISC CPU family.
+## Usage:
+##              #include <cyg/hal/arch.inc>
+##              ...
+##              
+##
+######DESCRIPTIONEND####
+##
+##=============================================================================
+
+#ifndef CYGONCE_HAL_ARCH_INC
+#define CYGONCE_HAL_ARCH_INC
+
+# Declare given label name as the start of a function accessible from C code
+#define FUNC_START(name)        \
+        .type _##name,@function;   \
+        .globl _##name;            \
+_##name:   
+
+#define FUNC_END(name)
+
+# Make aliases for ABI distinguished registers
+#define sp r1
+#define fp r2
+#define lr r9
+#define rv r11
+
+# Size of GPR regs - 4 bytes for or32
+#define OR1K_GPRSIZE    4
+
+# Size of all other registers
+#define OR1K_REGSIZE    4
+
+# Utility macro: Load a 32-bit constant into a register
+        .macro  load32i reg const
+        l.movhi \reg,hi(\const)
+        l.ori   \reg,\reg,lo(\const)
+        .endm
+
+##-----------------------------------------------------------------------------
+
+## OpenRISC thread and interrupt saved state structure. These offsets
+## must match the layout of the HAL_SavedRegisters struct in
+## hal_arch.h. Do not change this without changing the layout there,
+## or viceversa.
+
+#define OR1KREGS_GPRS   0
+#define OR1KREG_MACHI   (OR1KREGS_GPRS + OR1K_GPRSIZE * 32)
+#define OR1KREG_MACLO   (OR1KREG_MACHI + OR1K_REGSIZE)
+#define OR1KREG_VECTOR  (OR1KREG_MACLO + OR1K_REGSIZE)
+#define OR1KREG_SR      (OR1KREG_VECTOR+ OR1K_REGSIZE)
+#define OR1KREG_PC      (OR1KREG_SR    + OR1K_REGSIZE)
+#define OR1KREG_EEAR    (OR1KREG_PC    + OR1K_REGSIZE)
+
+#define SIZEOF_OR1KREGS (OR1KREG_EEAR  + OR1K_REGSIZE)
+
+#include <cyg/hal/openrisc.inc>
+#include <cyg/hal/platform.inc>
+
+#endif // #ifndef CYGONCE_HAL_ARCH_INC
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/basetype.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/basetype.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/basetype.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/basetype.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,76 @@
+#ifndef CYGONCE_HAL_BASETYPE_H
+#define CYGONCE_HAL_BASETYPE_H
+
+//=============================================================================
+//
+//      basetype.h
+//
+//      Standard types for this architecture.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: nickg
+// Date:         2003-02-28
+// Purpose:      Define architecture base types.
+// Usage:        Included by <cyg/infra/cyg_types.h>, do not use directly
+//              
+//####DESCRIPTIONEND####
+//
+
+#include <pkgconf/hal.h>
+
+//-----------------------------------------------------------------------------
+// Characterize the architecture
+
+# define CYG_BYTEORDER           CYG_MSBFIRST    // Big endian
+# define CYG_DOUBLE_BYTEORDER    CYG_MSBFIRST    // Big endian
+
+//-----------------------------------------------------------------------------
+// Prepend underscore to symbol name for it to be visible from C
+#define CYG_LABEL_DEFN(_name_) _##_name_
+
+//-----------------------------------------------------------------------------
+// Define the standard variable sizes
+
+// (The OpenRISC architecture uses the default definitions of the base types,
+// so we do not need to define any here.)
+
+//-----------------------------------------------------------------------------
+#endif // CYGONCE_HAL_BASETYPE_H
+
+// End of basetype.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_arch.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_arch.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_arch.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_arch.h	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,369 @@
+//==========================================================================
+//
+//      hal_arch.h
+//
+//      Architecture specific abstractions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: 
+// Date:         2003-01-17
+// Purpose:      Define architecture abstractions
+// Usage:        #include <cyg/hal/hal_arch.h>
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#ifndef CYGONCE_HAL_HAL_ARCH_H
+#define CYGONCE_HAL_HAL_ARCH_H
+
+// Include macros to access special-purpose registers (SPRs)
+#include <cyg/hal/spr_defs.h>
+
+#define CYG_HAL_OPENRISC_REG_SIZE 4
+
+#ifndef __ASSEMBLER__
+#include <pkgconf/hal.h>
+#include <cyg/infra/cyg_type.h>
+
+//--------------------------------------------------------------------------
+// Processor saved states:
+// The layout of this structure is also defined in "arch.inc", for assembly
+// code. Do not change this without changing that (or vice versa).
+
+#define CYG_HAL_OPENRISC_REG CYG_WORD32
+
+typedef struct 
+{
+    // These are common to all saved states
+    CYG_HAL_OPENRISC_REG    r[32];          // GPR regs
+    CYG_HAL_OPENRISC_REG    machi;          // High and low words of
+    CYG_HAL_OPENRISC_REG    maclo;          //   multiply/accumulate reg
+    
+    // These are only saved for exceptions and interrupts
+    CYG_WORD32              vector;         /* Vector number            */
+    CYG_WORD32              sr;             /* Status Reg               */
+    CYG_HAL_OPENRISC_REG    pc;             /* Program Counter          */
+
+    // Saved only for exceptions, and not restored when continued:
+    // Effective address of instruction/data access that caused exception
+    CYG_HAL_OPENRISC_REG    eear;           /* Exception effective address reg */
+} HAL_SavedRegisters;
+
+//--------------------------------------------------------------------------
+//  Utilities
+
+// Move from architecture special register (SPR)
+#define MFSPR(_spr_)                                      \
+({  CYG_HAL_OPENRISC_REG _result_;                        \
+    asm volatile ("l.mfspr %0, r0, %1;"                   \
+        : "=r"(_result_)                                  \
+        : "K"(_spr_)                                      \
+    );                                                    \
+    _result_;})
+
+// Move data to architecture special registers (SPR)
+#define MTSPR(_spr_, _val_)                               \
+CYG_MACRO_START                                           \
+    CYG_HAL_OPENRISC_REG val = _val_;                     \
+    asm volatile ("l.mtspr r0, %0, %1;"                   \
+        :                                                 \
+        : "r"(val), "K"(_spr_)                            \
+    );                                                    \
+CYG_MACRO_END
+
+//--------------------------------------------------------------------------
+// Exception handling function.
+// This function is defined by the kernel according to this prototype. It is
+// invoked from the HAL to deal with any CPU exceptions that the HAL does
+// not want to deal with itself. It usually invokes the kernel's exception
+// delivery mechanism.
+
+externC void cyg_hal_deliver_exception( CYG_WORD code, CYG_ADDRWORD data );
+
+//--------------------------------------------------------------------------
+// Bit manipulation macros
+
+externC cyg_uint32 hal_lsbit_index(cyg_uint32 mask);
+externC cyg_uint32 hal_msbit_index(cyg_uint32 mask);
+
+#define HAL_LSBIT_INDEX(index, mask) index = hal_lsbit_index(mask);
+
+// NOTE - Below can be optimized with l.ff1 instruction if that optional
+//        instruction is implemented in HW.  OR12k does not implement
+//        it at this time, however.
+#define HAL_MSBIT_INDEX(index, mask) index = hal_msbit_index(mask);
+
+//--------------------------------------------------------------------------
+// Context Initialization
+
+
+// Initialize the context of a thread.
+// Arguments:
+// _sparg_ name of variable containing current sp, will be written with new sp
+// _thread_ thread object address, passed as argument to entry point
+// _entry_ entry point address.
+// _id_ bit pattern used in initializing registers, for debugging.
+#define HAL_THREAD_INIT_CONTEXT( _sparg_, _thread_, _entry_, _id_ )                     \
+{                                                                                       \
+    int _i_;                                                                            \
+    register CYG_WORD _sp_ = ((CYG_WORD)_sparg_);                                       \
+    register HAL_SavedRegisters *_regs_;                                                \
+    _regs_ = (HAL_SavedRegisters *)(((_sp_) - sizeof(HAL_SavedRegisters)) & ~(CYGARC_ALIGNMENT));\
+    _sp_ &= ~(CYGARC_ALIGNMENT);                                                        \
+    for( _i_ = 1; _i_ < 32; _i_++ ) (_regs_)->r[_i_] = (_id_)|_i_;                      \
+    (_regs_)->r[1] = (CYG_HAL_OPENRISC_REG)(_sp_);       /* SP = top of stack      */   \
+    (_regs_)->r[2] = (CYG_HAL_OPENRISC_REG)(_sp_);       /* FP = top of stack      */   \
+    (_regs_)->r[3] = (CYG_HAL_OPENRISC_REG)(_thread_);   /* R3 = arg1 = thread ptr */   \
+    (_regs_)->maclo = 0;                                 /* MACLO = 0              */   \
+    (_regs_)->machi = 0;                                 /* MACHI = 0              */   \
+    (_regs_)->sr = (SPR_SR_TEE|SPR_SR_IEE);              /* Interrupts enabled     */   \
+    (_regs_)->pc = (CYG_HAL_OPENRISC_REG)(_entry_);      /* PC = entry point       */   \
+    (_regs_)->r[9] = (CYG_HAL_OPENRISC_REG)(_entry_);    /* PC = entry point       */   \
+    _sparg_ = (CYG_ADDRESS)_regs_;                                                      \
+}
+
+//--------------------------------------------------------------------------
+// Context switch macros.
+
+// The arguments to these macros are *pointers* to locations where the
+// stack pointer of the thread is to be stored/retrieved, i.e. *not*
+// the value of the stack pointer itself.
+
+externC void hal_thread_switch_context( CYG_ADDRESS to, CYG_ADDRESS from );
+externC void hal_thread_load_context( CYG_ADDRESS to )
+    __attribute__ ((noreturn));
+
+#define HAL_THREAD_SWITCH_CONTEXT(_fspptr_,_tspptr_)                    \
+        hal_thread_switch_context( (CYG_ADDRESS)_tspptr_,               \
+                                   (CYG_ADDRESS)_fspptr_);
+
+#define HAL_THREAD_LOAD_CONTEXT(_tspptr_)                               \
+        hal_thread_load_context( (CYG_ADDRESS)_tspptr_ );
+
+// Translate a stack pointer as saved by the thread context macros above into
+// a pointer to a HAL_SavedRegisters structure.
+#define HAL_THREAD_GET_SAVED_REGISTERS( _sp_, _regs_ )  \
+        (_regs_) = (HAL_SavedRegisters *)(_sp_)
+
+//--------------------------------------------------------------------------
+// Execution reorder barrier.
+// When optimizing the compiler can reorder code. In multithreaded systems
+// where the order of actions is vital, this can sometimes cause problems.
+// This macro may be inserted into places where reordering should not happen.
+// The "memory" keyword is potentially unnecessary, but it is harmless to
+// keep it.
+
+#define HAL_REORDER_BARRIER() asm volatile ( "" : : : "memory" )
+
+//--------------------------------------------------------------------------
+// Breakpoint support
+// HAL_BREAKPOINT() is a code sequence that will cause a breakpoint to
+//    occur if executed.
+// HAL_BREAKINST is the value of the breakpoint instruction and...
+// HAL_BREAKINST_SIZE is its size in bytes and...
+// HAL_BREAKINST_TYPE is its type.
+
+#define HAL_BREAKPOINT(_label_)                 \
+asm volatile (" .globl  _" #_label_ ";"         \
+              "_" #_label_ ":"                  \
+              " l.trap 1;"                      \
+    );
+
+#define HAL_BREAKINST           (0x21000001)    // l.trap 1 instruction
+
+#define HAL_BREAKINST_SIZE      4
+
+#define HAL_BREAKINST_TYPE      cyg_uint32
+
+//--------------------------------------------------------------------------
+// Thread register state manipulation for GDB support.
+
+// Default to a 32 bit register size for GDB register dumps.
+#ifndef CYG_HAL_GDB_REG
+#define CYG_HAL_GDB_REG CYG_WORD32
+#endif
+
+// Register layout expected by GDB
+typedef struct 
+{
+    CYG_HAL_OPENRISC_REG    r[32];          // GPR regs
+    CYG_HAL_OPENRISC_REG    pc;             // Program Counter
+    CYG_HAL_OPENRISC_REG    sr;             // Supervisor/Status Reg
+} GDB_Registers;
+
+// Copy a set of registers from a HAL_SavedRegisters structure into a
+// GDB_Registers structure.
+#define HAL_GET_GDB_REGISTERS( _aregval_, _regs_ )              \
+    CYG_MACRO_START                                             \
+    GDB_Registers *_gdb_ = (GDB_Registers *)(_aregval_);        \
+    int _i_;                                                    \
+                                                                \
+    for( _i_ = 0; _i_ <  32; _i_++ ) {                          \
+        _gdb_->r[_i_] = (_regs_)->r[_i_];                       \
+    }                                                           \
+                                                                \
+    _gdb_->pc = (_regs_)->pc;                                   \
+    _gdb_->sr = (_regs_)->sr;                                   \
+    CYG_MACRO_END
+
+// Copy a set of registers from a GDB_Registers structure into a
+// HAL_SavedRegisters structure.
+#define HAL_SET_GDB_REGISTERS( _regs_ , _aregval_ )             \
+    CYG_MACRO_START                                             \
+    GDB_Registers *_gdb_ = (GDB_Registers *)(_aregval_);        \
+    int _i_;                                                    \
+                                                                \
+    for( _i_ = 0; _i_ <  32; _i_++ )                            \
+        (_regs_)->r[_i_] = _gdb_->r[_i_];                       \
+                                                                \
+    (_regs_)->pc = _gdb_->pc;                                   \
+    (_regs_)->sr = _gdb_->sr;                                   \
+    CYG_MACRO_END
+
+//--------------------------------------------------------------------------
+// HAL setjmp
+// Note: These definitions are repeated in context.S. If changes are
+// required remember to update both sets.
+
+#define CYGARC_JMP_BUF_R1        0
+#define CYGARC_JMP_BUF_R2        1
+#define CYGARC_JMP_BUF_R9        2
+#define CYGARC_JMP_BUF_R10       3
+#define CYGARC_JMP_BUF_R12       4
+#define CYGARC_JMP_BUF_R14       5
+#define CYGARC_JMP_BUF_R16       6
+#define CYGARC_JMP_BUF_R18       7
+#define CYGARC_JMP_BUF_R20       8
+#define CYGARC_JMP_BUF_R22       9
+#define CYGARC_JMP_BUF_R24      10
+#define CYGARC_JMP_BUF_R26      11
+#define CYGARC_JMP_BUF_R28      12
+#define CYGARC_JMP_BUF_R30      13
+
+#define CYGARC_JMP_BUF_SIZE     14
+
+typedef CYG_HAL_OPENRISC_REG hal_jmp_buf[CYGARC_JMP_BUF_SIZE];
+
+externC int hal_setjmp(hal_jmp_buf env);
+externC void hal_longjmp(hal_jmp_buf env, int val);
+
+//-------------------------------------------------------------------------
+// Idle thread code.
+// This macro is called in the idle thread loop, and gives the HAL the
+// chance to run code when no threads are runnable. Typical idle
+// thread behaviour might be to halt the processor.
+
+externC void hal_idle_thread_action(cyg_uint32 loop_count);
+
+#define HAL_IDLE_THREAD_ACTION(_count_) hal_idle_thread_action(_count_)
+
+//--------------------------------------------------------------------------
+// Minimal and sensible stack sizes: the intention is that applications
+// will use these to provide a stack size in the first instance prior to
+// proper analysis.  Idle thread stack should be this big.
+
+// *** THESE ARE NOT INTENDED TO BE GUARANTEED SUFFICIENT STACK SIZES ***
+// They are, however, enough to start programming.
+// You might, for example, need to make your stacks larger if you have
+// large "auto" variables.
+
+// This is not a config option because it should not be adjusted except
+// under "enough rope to hang yourself" sort of disclaimers.
+
+// Typical case stack frame size: return link + 10 caller-saved temporaries + 4 locals.
+#define CYGNUM_HAL_STACK_FRAME_SIZE (15 * CYG_HAL_OPENRISC_REG_SIZE)
+
+// Stack needed for a context switch:
+#define CYGNUM_HAL_STACK_CONTEXT_SIZE (38 * 4)  // sizeof(HAL_SavedRegisters)
+
+// Interrupt + call to ISR, interrupt_end() and the DSR
+#define CYGNUM_HAL_STACK_INTERRUPT_SIZE (CYGNUM_HAL_STACK_CONTEXT_SIZE + 2*CYGNUM_HAL_STACK_FRAME_SIZE) 
+
+// We define a minimum stack size as the minimum any thread could ever
+// legitimately get away with. We can throw asserts if users ask for less
+// than this. Allow enough for three interrupt sources - clock, serial and
+// one other
+
+// If interrupts are segregated onto their own stack...
+#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK 
+
+// An interrupt stack which is large enough for all possible interrupt
+// conditions (and only used for that purpose) exists.  "User" stacks
+// can therefore be much smaller
+// NOTE - interrupt stack sizes can be smaller if we don't allow interrupts
+//         to nest.
+
+# define CYGNUM_HAL_STACK_SIZE_MINIMUM \
+         ((3 * 5)*CYGNUM_HAL_STACK_FRAME_SIZE + 2*CYGNUM_HAL_STACK_INTERRUPT_SIZE)
+
+#else
+
+// No separate interrupt stack exists.  Make sure all threads contain
+// a stack sufficiently large
+# define CYGNUM_HAL_STACK_SIZE_MINIMUM                  \
+        (( 3*CYGNUM_HAL_STACK_INTERRUPT_SIZE) +         \
+         (25*CYGNUM_HAL_STACK_FRAME_SIZE))
+#endif
+
+// Now make a reasonable choice for a typical thread size. Pluck figures
+// from thin air and say 40 call frames
+#define CYGNUM_HAL_STACK_SIZE_TYPICAL                \
+        (CYGNUM_HAL_STACK_SIZE_MINIMUM +             \
+         40 * (CYGNUM_HAL_STACK_FRAME_SIZE))
+
+#endif /* __ASSEMBLER__ */
+
+//--------------------------------------------------------------------------
+// Macros for switching context between two eCos instances (jump from
+// code in ROM to code in RAM or vice versa).
+// These are NOP's in the case of OpenRISC.
+#define CYGARC_HAL_SAVE_GP()
+#define CYGARC_HAL_RESTORE_GP()
+
+//--------------------------------------------------------------------------
+// Macro for finding return address of current function
+#define CYGARC_HAL_GET_RETURN_ADDRESS(_x_, _dummy_) \
+  asm volatile ( "l.ori %0,r9,0;" : "=r" (_x_) )
+
+#define CYGARC_HAL_GET_RETURN_ADDRESS_BACKUP(_dummy_)
+
+//--------------------------------------------------------------------------
+#endif // CYGONCE_HAL_HAL_ARCH_H
+// End of hal_arch.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_cache.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_cache.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_cache.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_cache.h	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,242 @@
+#ifndef CYGONCE_HAL_CACHE_H
+#define CYGONCE_HAL_CACHE_H
+
+//=============================================================================
+//
+//      hal_cache.h
+//
+//      HAL cache control API
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   Scott Furman
+// Contributors:
+// Date:        2003-02-08
+// Purpose:     Cache control API
+// Description: The macros defined here provide the HAL APIs for handling
+//              cache control operations.
+// Usage:
+//              #include <cyg/hal/hal_cache.h>
+//              ...
+//              
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+// Cache dimensions.
+// These really should be defined in var_cache.h. If they are not, then provide
+// a set of numbers that are typical of many variants.
+
+#ifndef HAL_DCACHE_SIZE
+
+// Data cache
+#define HAL_DCACHE_SIZE                 4096    // Size of data cache in bytes
+#define HAL_DCACHE_LINE_SIZE            16      // Bytes in a data cache line
+#define HAL_DCACHE_WAYS                 1       // Associativity of the cache
+
+// Instruction cache
+#define HAL_ICACHE_SIZE                 4096    // Size of cache in bytes
+#define HAL_ICACHE_LINE_SIZE            16      // Bytes in a cache line
+#define HAL_ICACHE_WAYS                 1       // Associativity of the cache
+
+#define HAL_DCACHE_SETS (HAL_DCACHE_SIZE/(HAL_DCACHE_LINE_SIZE*HAL_DCACHE_WAYS))
+#define HAL_ICACHE_SETS (HAL_ICACHE_SIZE/(HAL_ICACHE_LINE_SIZE*HAL_ICACHE_WAYS))
+
+#endif
+
+#ifndef __ASSEMBLER__
+
+//-----------------------------------------------------------------------------
+// Global control of data cache
+
+// Enable the data cache
+#define HAL_DCACHE_ENABLE() MTSPR(SPR_SR, MFSPR(SPR_SR) | SPR_SR_DCE)
+
+// Disable the data cache
+#define HAL_DCACHE_DISABLE() MTSPR(SPR_SR, MFSPR(SPR_SR) & ~SPR_SR_DCE)
+
+// Enable or disable the data cache, depending on argument, which is required
+// to be 0 or 1.
+#define HAL_SET_DCACHE_ENABLED(enable)                          \
+    MTSPR(SPR_SR, MFSPR(SPR_SR) | (SPR_SR_DCE & -(enable)))
+
+// Invalidate the entire data cache
+#define HAL_DCACHE_INVALIDATE_ALL()                             \
+    CYG_MACRO_START                                             \
+    int cache_enabled, addr;                                    \
+                                                                \
+    /* Save current cache mode (disabled/enabled) */            \
+    HAL_DCACHE_IS_ENABLED(cache_enabled);                       \
+                                                                \
+    /* Disable cache, so that invalidation ignores cache tags */\
+    HAL_DCACHE_DISABLE();                                       \
+    addr = HAL_DCACHE_SIZE;                                     \
+    do {                                                        \
+        MTSPR(SPR_DCBIR, addr);                                 \
+        addr -= HAL_DCACHE_LINE_SIZE;                           \
+    } while (addr > 0);                                         \
+                                                                \
+    /* Re-enable cache if it was enabled on entry */            \
+    HAL_SET_DCACHE_ENABLED(cache_enabled);                      \
+    CYG_MACRO_END
+
+// Synchronize the contents of the cache with memory.
+// (Unnecessary on OR12K, since cache is write-through.)
+#define HAL_DCACHE_SYNC()                       \
+    CYG_MACRO_START                             \
+    CYG_MACRO_END
+
+// Query the state (enabled/disabled) of the data cache
+#define HAL_DCACHE_IS_ENABLED(_state_)                          \
+    CYG_MACRO_START                                             \
+    (_state_) = (1 - !(MFSPR(SPR_SR) & SPR_SR_DCE));            \
+    CYG_MACRO_END
+
+// Load the contents of the given address range into the data cache 
+// and then lock the cache so that it stays there.
+
+// The OpenRISC architecture defines these operations, but no
+// implementation supports them yet.
+
+//#define HAL_DCACHE_LOCK(_base_, _size_)
+        
+// Undo a previous lock operation
+//#define HAL_DCACHE_UNLOCK(_base_, _size_)
+
+// Unlock entire cache
+//#define HAL_DCACHE_UNLOCK_ALL()
+
+
+//-----------------------------------------------------------------------------
+// Data cache line control
+
+// Write dirty cache lines to memory and invalidate the cache entries
+// for the given address range.
+// OR12k has write-through cache, so no flushing of writes to memory
+// are necessary.
+#define HAL_DCACHE_FLUSH( _base_ , _size_ )                          \
+    HAL_DCACHE_INVALIDATE(_base_, _size_)
+   
+// Invalidate cache lines in the given range without writing to memory.
+#define HAL_DCACHE_INVALIDATE( _base_ , _size_ )                     \
+    CYG_MACRO_START                                                  \
+    int addr;                                                        \
+    int end = _base_ + _size_;                                       \
+    for (addr = end; addr >= _base_; addr -= HAL_DCACHE_LINE_SIZE) { \
+        MTSPR(SPR_DCBIR, addr);                                      \
+    }                                                                \
+    CYG_MACRO_END
+
+// Write dirty cache lines to memory for the given address range.
+// OR12k has write-through cache, so this is a NOP
+#define HAL_DCACHE_STORE( _base_ , _size_ )
+
+// Preread the given range into the cache with the intention of reading
+// from it later.
+//#define HAL_DCACHE_READ_HINT( _base_ , _size_ )
+
+// Preread the given range into the cache with the intention of writing
+// to it later.
+//#define HAL_DCACHE_WRITE_HINT( _base_ , _size_ )
+
+// Allocate and zero the cache lines associated with the given range.
+//#define HAL_DCACHE_ZERO( _base_ , _size_ )
+
+//-----------------------------------------------------------------------------
+// Global control of Instruction cache
+
+// Enable the instruction cache
+#define HAL_ICACHE_ENABLE() MTSPR(SPR_SR, MFSPR(SPR_SR) | SPR_SR_ICE)
+
+// Disable the instruction cache
+#define HAL_ICACHE_DISABLE() MTSPR(SPR_SR, MFSPR(SPR_SR) & ~SPR_SR_ICE)
+
+// Enable or disable the data cache, depending on argument, which must
+// be 0 or 1.
+#define HAL_SET_ICACHE_ENABLED(enable)                          \
+    MTSPR(SPR_SR, MFSPR(SPR_SR) | (SPR_SR_ICE & -(enable)))
+
+// Invalidate the entire instruction cache
+#define HAL_ICACHE_INVALIDATE_ALL()                             \
+    CYG_MACRO_START                                             \
+    int cache_enabled, addr;                                    \
+                                                                \
+    /* Save current cache mode (disabled/enabled) */            \
+    HAL_ICACHE_IS_ENABLED(cache_enabled);                       \
+                                                                \
+    /* Disable cache, so that invalidation ignores cache tags */\
+    HAL_ICACHE_DISABLE();                                       \
+    addr = HAL_ICACHE_SIZE;                                     \
+    do {                                                        \
+        MTSPR(SPR_ICBIR, addr);                                 \
+        addr -= HAL_ICACHE_LINE_SIZE;                           \
+    } while (addr > 0);                                         \
+                                                                \
+    /* Re-enable cache if it was enabled on entry */            \
+    HAL_SET_ICACHE_ENABLED(cache_enabled);                      \
+    CYG_MACRO_END
+
+// Synchronize the contents of the cache with memory.
+#define HAL_ICACHE_SYNC() HAL_ICACHE_INVALIDATE_ALL()
+
+// Query the state of the instruction cache
+#define HAL_ICACHE_IS_ENABLED(_state_)                          \
+    CYG_MACRO_START                                             \
+    (_state_) = (1 - !(MFSPR(SPR_SR) & SPR_SR_ICE));            \
+    CYG_MACRO_END
+
+
+// Load the contents of the given address range into the instruction cache
+// and then lock the cache so that it stays there.
+
+// The OpenRISC architecture defines these operations, but no
+// implementation supports them yet.
+
+//#define HAL_ICACHE_LOCK(_base_, _size_)
+
+// Undo a previous lock operation
+//#define HAL_ICACHE_UNLOCK(_base_, _size_)
+
+// Unlock entire cache
+//#define HAL_ICACHE_UNLOCK_ALL()
+
+#endif /* __ASSEMBLER__ */
+
+#endif // ifndef CYGONCE_HAL_CACHE_H
+// End of hal_cache.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_intr.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_intr.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_intr.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_intr.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,458 @@
+//==========================================================================
+//
+//      hal_intr.h
+//
+//      HAL Interrupt and clock support
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: 
+// Date:         2003-01-24
+// Purpose:      Define Interrupt support
+// Description:  The macros defined here provide the HAL APIs for handling
+//               both external interrupts and clock interrupts.
+//              
+// Usage:
+//              #include <cyg/hal/hal_intr.h>
+//              ...
+//              
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+#ifndef CYGONCE_HAL_HAL_INTR_H
+#define CYGONCE_HAL_HAL_INTR_H
+
+#include <cyg/hal/hal_arch.h>
+
+//--------------------------------------------------------------------------
+// OpenRISC vectors. 
+
+// These are the exception/interrupt causes defined by the hardware.
+// These values are the ones to use for HAL_VSR_GET/SET
+
+// Reset
+#define CYGNUM_HAL_VECTOR_RESET                0x01
+
+// Bus Error - probably invalid physical address
+#define CYGNUM_HAL_VECTOR_BUS_ERROR            0x02
+
+// Either no matching page-table entry or protection fault
+// while executing load/store operation
+#define CYGNUM_HAL_VECTOR_DATA_PAGE_FAULT      0x03
+
+// Either no matching page-table entry or protection fault
+// while fetching instruction
+#define CYGNUM_HAL_VECTOR_INSTR_PAGE_FAULT     0x04
+
+// Tick Timer interrupt
+#define CYGNUM_HAL_VECTOR_TICK_TIMER           0x05
+
+// Unaligned access
+#define CYGNUM_HAL_VECTOR_UNALIGNED_ACCESS     0x06
+
+// Illegal instruction
+#define CYGNUM_HAL_VECTOR_RESERVED_INSTRUCTION 0x07
+
+// External Interrupt from PIC
+#define CYGNUM_HAL_VECTOR_INTERRUPT            0x08
+
+// D-TLB Miss
+#define CYGNUM_HAL_VECTOR_DTLB_MISS            0x09
+
+// I-TLB Miss
+#define CYGNUM_HAL_VECTOR_ITLB_MISS            0x0A
+
+// Numeric overflow, etc.
+#define CYGNUM_HAL_VECTOR_RANGE                0x0B
+
+// System Call
+#define CYGNUM_HAL_VECTOR_SYSTEM_CALL          0x0C
+
+// TRAP instruction executed
+#define CYGNUM_HAL_VECTOR_TRAP                 0x0E
+
+#define CYGNUM_HAL_VSR_MIN                     CYGNUM_HAL_VECTOR_RESET
+#define CYGNUM_HAL_VSR_MAX                     CYGNUM_HAL_VECTOR_TRAP
+#define CYGNUM_HAL_VSR_COUNT                   (CYGNUM_HAL_VSR_MAX-CYGNUM_HAL_VSR_MIN+1)
+
+// Exception vectors. These are the values used when passed out to an
+// external exception handler using cyg_hal_deliver_exception()
+
+#define CYGNUM_HAL_EXCEPTION_DATA_TLBMISS_ACCESS \
+          CYGNUM_HAL_VECTOR_DTLB_MISS
+#define CYGNUM_HAL_EXCEPTION_DATA_TLBMISS_ACCESS \
+          CYGNUM_HAL_VECTOR_DTLB_MISS
+#define CYGNUM_HAL_EXCEPTION_DATA_UNALIGNED_ACCESS \
+          CYGNUM_HAL_VECTOR_UNALIGNED_ACCESS
+#define CYGNUM_HAL_EXCEPTION_SYSTEM_CALL    CYGNUM_HAL_VECTOR_SYSTEM_CALL
+#define CYGNUM_HAL_EXCEPTION_ILLEGAL_INSTRUCTION \
+          CYGNUM_HAL_VECTOR_RESERVED_INSTRUCTION
+#define CYGNUM_HAL_EXCEPTION_OVERFLOW       CYGNUM_HAL_VECTOR_RANGE
+#define CYGNUM_HAL_EXCEPTION_INTERRUPT      CYGNUM_HAL_VECTOR_INTERRUPT
+
+// Min/Max exception numbers and how many there are
+#define CYGNUM_HAL_EXCEPTION_MIN                CYGNUM_HAL_VSR_MIN
+#define CYGNUM_HAL_EXCEPTION_MAX                CYGNUM_HAL_VSR_MAX
+#define CYGNUM_HAL_EXCEPTION_COUNT           \
+                 ( CYGNUM_HAL_EXCEPTION_MAX - CYGNUM_HAL_EXCEPTION_MIN + 1 )
+
+
+#ifndef CYGHWR_HAL_INTERRUPT_VECTORS_DEFINED
+#define CYGHWR_HAL_INTERRUPT_VECTORS_DEFINED
+
+// Interrupts 0-31 are connected to the PIC
+#define CYGNUM_HAL_INTERRUPT_0                0
+#define CYGNUM_HAL_INTERRUPT_1                1
+#define CYGNUM_HAL_INTERRUPT_2                2
+#define CYGNUM_HAL_INTERRUPT_3                3
+#define CYGNUM_HAL_INTERRUPT_4                4
+#define CYGNUM_HAL_INTERRUPT_5                5
+#define CYGNUM_HAL_INTERRUPT_6                6
+#define CYGNUM_HAL_INTERRUPT_7                7
+#define CYGNUM_HAL_INTERRUPT_8                8
+#define CYGNUM_HAL_INTERRUPT_9                9
+#define CYGNUM_HAL_INTERRUPT_10               10
+#define CYGNUM_HAL_INTERRUPT_11               11
+#define CYGNUM_HAL_INTERRUPT_12               12
+#define CYGNUM_HAL_INTERRUPT_13               13
+#define CYGNUM_HAL_INTERRUPT_14               14
+#define CYGNUM_HAL_INTERRUPT_15               15
+#define CYGNUM_HAL_INTERRUPT_16               16
+#define CYGNUM_HAL_INTERRUPT_17               17
+#define CYGNUM_HAL_INTERRUPT_18               18
+#define CYGNUM_HAL_INTERRUPT_19               19
+#define CYGNUM_HAL_INTERRUPT_20               20
+#define CYGNUM_HAL_INTERRUPT_21               21
+#define CYGNUM_HAL_INTERRUPT_22               22
+#define CYGNUM_HAL_INTERRUPT_23               23
+#define CYGNUM_HAL_INTERRUPT_24               24
+#define CYGNUM_HAL_INTERRUPT_25               25
+#define CYGNUM_HAL_INTERRUPT_26               26
+#define CYGNUM_HAL_INTERRUPT_27               27
+#define CYGNUM_HAL_INTERRUPT_28               28
+#define CYGNUM_HAL_INTERRUPT_29               29
+#define CYGNUM_HAL_INTERRUPT_30               30
+#define CYGNUM_HAL_INTERRUPT_31               31
+
+// By SW convention, interrupt #32 is the tick timer
+#define CYGNUM_HAL_INTERRUPT_32               32
+
+// The interrupt vector used by the RTC, aka tick timer
+#define CYGNUM_HAL_INTERRUPT_RTC            CYGNUM_HAL_INTERRUPT_32
+
+// Min/Max ISR numbers and how many there are
+#define CYGNUM_HAL_ISR_MIN                     0
+#define CYGNUM_HAL_ISR_MAX                     32
+#define CYGNUM_HAL_ISR_COUNT                   33
+
+#endif
+
+#ifndef __ASSEMBLER__
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/hal/hal_io.h>
+
+#include <cyg/hal/plf_intr.h>
+
+//--------------------------------------------------------------------------
+// Static data used by HAL
+
+// ISR tables
+externC volatile CYG_ADDRESS    hal_interrupt_handlers[CYGNUM_HAL_ISR_COUNT];
+externC volatile CYG_ADDRWORD   hal_interrupt_data[CYGNUM_HAL_ISR_COUNT];
+externC volatile CYG_ADDRESS    hal_interrupt_objects[CYGNUM_HAL_ISR_COUNT];
+
+// VSR table
+externC volatile CYG_ADDRESS    hal_vsr_table[CYGNUM_HAL_VSR_MAX+1];
+
+//--------------------------------------------------------------------------
+// Default ISR
+// The #define is used to test whether this routine exists, and to allow
+// us to call it.
+
+externC cyg_uint32 hal_default_isr(CYG_ADDRWORD vector, CYG_ADDRWORD data);
+
+#define HAL_DEFAULT_ISR hal_default_isr
+
+//--------------------------------------------------------------------------
+// Interrupt state storage
+
+typedef cyg_uint32 CYG_INTERRUPT_STATE;
+
+//--------------------------------------------------------------------------
+// Interrupt control macros
+#ifndef CYGHWR_HAL_INTERRUPT_ENABLE_DISABLE_RESTORE_DEFINED
+
+// Clear both tick timer and external interrupts in the Supervisor Register
+#define HAL_DISABLE_INTERRUPTS(_old_)                     \
+    CYG_MACRO_START                                       \
+    _old_ = MFSPR(SPR_SR);                                \
+    MTSPR(SPR_SR, _old_ & ~(SPR_SR_IEE|SPR_SR_TEE));      \
+    CYG_MACRO_END
+
+// Enable both tick timer and external interrupts in the Supervisor Register
+#define HAL_ENABLE_INTERRUPTS()                           \
+    MTSPR(SPR_SR, MFSPR(SPR_SR) | (SPR_SR_IEE|SPR_SR_TEE))
+
+// Copy interrupt flags from argument into Supervisor Register
+#define HAL_RESTORE_INTERRUPTS(_old_)                     \
+    CYG_MACRO_START                                       \
+    cyg_uint32 t1,t2;                                     \
+    t1 = MFSPR(SPR_SR) & ~(SPR_SR_IEE|SPR_SR_TEE);        \
+    t2 = (_old_) & (SPR_SR_IEE|SPR_SR_TEE);               \
+    MTSPR(SPR_SR, t1 | t2);                               \
+    CYG_MACRO_END
+
+#define HAL_QUERY_INTERRUPTS( _state_ )                   \
+    CYG_MACRO_START                                       \
+    _state = MFSPR(SPR_SR);                               \
+    CYG_MACRO_END
+
+#endif // CYGHWR_HAL_INTERRUPT_ENABLE_DISABLE_RESTORE_DEFINED
+
+//--------------------------------------------------------------------------
+// Routine to execute DSRs using separate interrupt stack
+
+#ifdef  CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
+externC void hal_interrupt_stack_call_pending_DSRs(void);
+#define HAL_INTERRUPT_STACK_CALL_PENDING_DSRS() \
+    hal_interrupt_stack_call_pending_DSRs()
+
+// these are offered solely for stack usage testing
+// if they are not defined, then there is no interrupt stack.
+#define HAL_INTERRUPT_STACK_BASE cyg_interrupt_stack_base
+#define HAL_INTERRUPT_STACK_TOP  cyg_interrupt_stack
+// use them to declare these extern however you want:
+//       extern char HAL_INTERRUPT_STACK_BASE[];
+//       extern char HAL_INTERRUPT_STACK_TOP[];
+// is recommended
+#endif
+
+//--------------------------------------------------------------------------
+// Vector translation.
+// For chained interrupts we only have a single vector though which all
+// are passed. For unchained interrupts we have a vector per interrupt.
+
+#ifndef HAL_TRANSLATE_VECTOR
+
+#if defined(CYGIMP_HAL_COMMON_INTERRUPTS_CHAIN)
+
+#define HAL_TRANSLATE_VECTOR(_vector_,_index_) (_index_) = 0
+
+#else
+
+#define HAL_TRANSLATE_VECTOR(_vector_,_index_) (_index_) = (_vector_)
+
+#endif
+
+#endif
+
+//--------------------------------------------------------------------------
+// Interrupt and VSR attachment macros
+
+#define HAL_INTERRUPT_IN_USE( _vector_, _state_)                          \
+    CYG_MACRO_START                                                       \
+    cyg_uint32 _index_;                                                   \
+    HAL_TRANSLATE_VECTOR ((_vector_), _index_);                           \
+                                                                          \
+    if( hal_interrupt_handlers[_index_] == (CYG_ADDRESS)HAL_DEFAULT_ISR ) \
+        (_state_) = 0;                                                    \
+    else                                                                  \
+        (_state_) = 1;                                                    \
+    CYG_MACRO_END
+
+#define HAL_INTERRUPT_ATTACH( _vector_, _isr_, _data_, _object_ )           \
+{                                                                           \
+    cyg_uint32 _index_;                                                     \
+    HAL_TRANSLATE_VECTOR( _vector_, _index_ );                              \
+                                                                            \
+    if( hal_interrupt_handlers[_index_] == (CYG_ADDRESS)HAL_DEFAULT_ISR )   \
+    {                                                                       \
+        hal_interrupt_handlers[_index_] = (CYG_ADDRESS)_isr_;               \
+        hal_interrupt_data[_index_] = (CYG_ADDRWORD)_data_;                 \
+        hal_interrupt_objects[_index_] = (CYG_ADDRESS)_object_;             \
+    }                                                                       \
+}
+
+#define HAL_INTERRUPT_DETACH( _vector_, _isr_ )                         \
+{                                                                       \
+    cyg_uint32 _index_;                                                 \
+    HAL_TRANSLATE_VECTOR( _vector_, _index_ );                          \
+                                                                        \
+    if( hal_interrupt_handlers[_index_] == (CYG_ADDRESS)_isr_ )         \
+    {                                                                   \
+        hal_interrupt_handlers[_index_] = (CYG_ADDRESS)HAL_DEFAULT_ISR; \
+        hal_interrupt_data[_index_] = 0;                                \
+        hal_interrupt_objects[_index_] = 0;                             \
+    }                                                                   \
+}
+
+#define HAL_VSR_GET( _vector_, _pvsr_ )                 \
+    *(_pvsr_) = (void (*)())hal_vsr_table[_vector_];
+    
+
+#define HAL_VSR_SET( _vector_, _vsr_, _poldvsr_ ) CYG_MACRO_START         \
+    if( (void*)_poldvsr_ != NULL)                                         \
+        *(CYG_ADDRESS *)_poldvsr_ = (CYG_ADDRESS)hal_vsr_table[_vector_]; \
+    hal_vsr_table[_vector_] = (CYG_ADDRESS)_vsr_;                         \
+CYG_MACRO_END
+
+// This is an ugly name, but what it means is: grab the VSR back to eCos
+// internal handling, or if you like, the default handler.  But if
+// cooperating with GDB and CygMon, the default behaviour is to pass most
+// exceptions to CygMon.  This macro undoes that so that eCos handles the
+// exception.  So use it with care.
+
+externC void cyg_hal_default_exception_vsr(void);
+externC void cyg_hal_default_interrupt_vsr(void);
+
+#define HAL_VSR_SET_TO_ECOS_HANDLER( _vector_, _poldvsr_ ) CYG_MACRO_START  \
+    HAL_VSR_SET( _vector_, _vector_ == CYGNUM_HAL_VECTOR_INTERRUPT          \
+                              ? (CYG_ADDRESS)cyg_hal_default_interrupt_vsr  \
+                              : (CYG_ADDRESS)cyg_hal_default_exception_vsr, \
+                 _poldvsr_ );                                               \
+CYG_MACRO_END
+
+//--------------------------------------------------------------------------
+// Interrupt controller access
+
+#ifndef CYGHWR_HAL_INTERRUPT_CONTROLLER_ACCESS_DEFINED
+#define CYGHWR_HAL_INTERRUPT_CONTROLLER_ACCESS_DEFINED
+
+// Mask (disable) interrupts from specified source
+#define HAL_INTERRUPT_MASK( _vector_ )            \
+CYG_MACRO_START                                   \
+    int mask;                                     \
+    if ((_vector_) == CYGNUM_HAL_INTERRUPT_RTC) { \
+        /* The tick timer interrupt isn't */      \
+        /* controlled by the PIC; It has its own*/\
+        /* enable bit in the SR. */               \
+        MTSPR(SPR_SR, MFSPR(SPR_SR)& ~SPR_SR_TEE);\
+    } else {                                      \
+        mask = ~(1 << (_vector_));                \
+        MTSPR(SPR_PICMR, MFSPR(SPR_PICMR)& mask); \
+    }                                             \
+CYG_MACRO_END
+
+// Allow interrupts from specified source
+#define HAL_INTERRUPT_UNMASK( _vector_ )          \
+CYG_MACRO_START                                   \
+    int bit;                                      \
+    if ((_vector_) == CYGNUM_HAL_INTERRUPT_RTC) { \
+        /* The tick timer interrupt isn't */      \
+        /* controlled by the PIC; It has its own*/\
+        /* enable bit in the SR. */               \
+        MTSPR(SPR_SR, MFSPR(SPR_SR) | SPR_SR_TEE);\
+    } else {                                      \
+        bit = (1 << (_vector_));                  \
+        MTSPR(SPR_PICMR, MFSPR(SPR_PICMR) | bit); \
+    }                                             \
+CYG_MACRO_END
+
+// Reset interrupt request in the PIC for specified device
+#define HAL_INTERRUPT_ACKNOWLEDGE( _vector_ )     \
+CYG_MACRO_START                                   \
+    int mask;                                     \
+    if ((_vector_) != CYGNUM_HAL_INTERRUPT_RTC) { \
+        mask = ~(1 << (_vector_));                \
+        MTSPR(SPR_PICSR, MFSPR(SPR_PICSR) & mask);\
+    }                                             \
+CYG_MACRO_END
+
+#define HAL_INTERRUPT_CONFIGURE( _vector_, _level_, _up_ ) CYG_EMPTY_STATEMENT
+
+#define HAL_INTERRUPT_SET_LEVEL( _vector_, _level_ )  CYG_EMPTY_STATEMENT
+
+#endif
+
+//--------------------------------------------------------------------------
+// Clock control.
+
+externC CYG_WORD32 cyg_hal_clock_period;
+#define CYGHWR_HAL_CLOCK_PERIOD_DEFINED
+
+// Start tick timer interrupts
+#define HAL_CLOCK_INITIALIZE( _period_ )        \
+CYG_MACRO_START                                 \
+{                                               \
+    int ttmr_new = _period_ | 0x60000000;       \
+    MTSPR(SPR_TTMR, 0);                         \
+    MTSPR(SPR_TTCR, 0);                         \
+    MTSPR(SPR_TTMR, ttmr_new);                  \
+    cyg_hal_clock_period = _period_;            \
+}                                               \
+CYG_MACRO_END
+
+// Acknowledge clock timer interrupt
+#define HAL_CLOCK_RESET( _vector_, _period_ )   \
+CYG_MACRO_START                                 \
+    int ttmr_new = _period_ | 0x60000000;       \
+    MTSPR(SPR_TTMR, ttmr_new);                  \
+CYG_MACRO_END
+
+// Read the current value of the tick timer
+#define HAL_CLOCK_READ( _pvalue_ )              \
+CYG_MACRO_START                                 \
+    *(_pvalue_) = MFSPR(SPR_TTCR);              \
+CYG_MACRO_END
+
+#if defined(CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY) && \
+    !defined(HAL_CLOCK_LATENCY)
+#define HAL_CLOCK_LATENCY( _pvalue_ )                   \
+CYG_MACRO_START                                         \
+    register CYG_WORD32 _cval_;                         \
+    HAL_CLOCK_READ(&_cval_);                            \
+    *(_pvalue_) = _cval_ - cyg_hal_clock_period;        \
+CYG_MACRO_END
+#endif
+
+
+//--------------------------------------------------------------------------
+// Microsecond delay function provided in hal_misc.c
+externC void hal_delay_us(int us);
+
+#define HAL_DELAY_US(n)          hal_delay_us(n)
+
+#endif /* #ifndef __ASSEMBLER__ */
+
+//--------------------------------------------------------------------------
+#endif // ifndef CYGONCE_HAL_HAL_INTR_H
+// End of hal_intr.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_io.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_io.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_io.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/hal_io.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,158 @@
+#ifndef CYGONCE_HAL_HAL_IO_H
+#define CYGONCE_HAL_HAL_IO_H
+
+//=============================================================================
+//
+//      hal_io.h
+//
+//      HAL device IO register support.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   nickg
+// Contributors:        nickg
+// Date:        2003-02-28
+// Purpose:     Define IO register support
+// Description: The macros defined here provide the HAL APIs for handling
+//              device IO control registers.
+//              
+// Usage:
+//              #include <cyg/hal/hal_io.h>
+//              ...
+//              
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>
+
+//#include <cyg/hal/plf_io.h>
+
+//-----------------------------------------------------------------------------
+// IO Register address.
+// This type is for recording the address of an IO register.
+
+typedef volatile CYG_ADDRWORD HAL_IO_REGISTER;
+
+//-----------------------------------------------------------------------------
+// HAL IO macros.
+#ifndef HAL_IO_MACROS_DEFINED
+
+//-----------------------------------------------------------------------------
+// BYTE Register access.
+// Individual and vectorized access to 8 bit registers.
+
+#define HAL_READ_UINT8( _register_, _value_ ) \
+        ((_value_) = *((volatile CYG_BYTE *)(_register_)))
+
+#define HAL_WRITE_UINT8( _register_, _value_ ) \
+        (*((volatile CYG_BYTE *)(_register_)) = (_value_))
+
+#define HAL_READ_UINT8_VECTOR( _register_, _buf_, _count_, _step_ )     \
+{                                                                       \
+    cyg_count32 _i_,_j_;                                                \
+    for( _i_ = 0, _j_ = 0; _i_ < (_count_); _i_++, _j_ += (_step_))     \
+        (_buf_)[_i_] = ((volatile CYG_BYTE *)(_register_))[_j_];        \
+}
+
+#define HAL_WRITE_UINT8_VECTOR( _register_, _buf_, _count_, _step_ )    \
+{                                                                       \
+    cyg_count32 _i_,_j_;                                                \
+    for( _i_ = 0, _j_ = 0; _i_ < (_count_); _i_++, _j_ += (_step_))     \
+        ((volatile CYG_BYTE *)(_register_))[_j_] = (_buf_)[_i_];        \
+}
+
+
+//-----------------------------------------------------------------------------
+// 16 bit access.
+// Individual and vectorized access to 16 bit registers.
+    
+#define HAL_READ_UINT16( _register_, _value_ ) \
+        ((_value_) = *((volatile CYG_WORD16 *)(_register_)))
+
+#define HAL_WRITE_UINT16( _register_, _value_ ) \
+        (*((volatile CYG_WORD16 *)(_register_)) = (_value_))
+
+#define HAL_READ_UINT16_VECTOR( _register_, _buf_, _count_, _step_ )    \
+{                                                                       \
+    cyg_count32 _i_,_j_;                                                \
+    for( _i_ = 0, _j_ = 0; _i_ < (_count_); _i_++, _j_ += (_step_))     \
+        (_buf_)[_i_] = ((volatile CYG_WORD16 *)(_register_))[_j_];      \
+}
+
+#define HAL_WRITE_UINT16_VECTOR( _register_, _buf_, _count_, _step_ )   \
+{                                                                       \
+    cyg_count32 _i_,_j_;                                                \
+    for( _i_ = 0, _j_ = 0; _i_ < (_count_); _i_++, _j_ += (_step_))     \
+        ((volatile CYG_WORD16 *)(_register_))[_j_] = (_buf_)[_i_];      \
+}
+
+//-----------------------------------------------------------------------------
+// 32 bit access.
+// Individual and vectorized access to 32 bit registers.
+    
+#define HAL_READ_UINT32( _register_, _value_ ) \
+        ((_value_) = *((volatile CYG_WORD32 *)(_register_)))
+
+#define HAL_WRITE_UINT32( _register_, _value_ ) \
+        (*((volatile CYG_WORD32 *)(_register_)) = (_value_))
+
+#define HAL_READ_UINT32_VECTOR( _register_, _buf_, _count_, _step_ )    \
+{                                                                       \
+    cyg_count32 _i_,_j_;                                                \
+    for( _i_ = 0, _j_ = 0; _i_ < (_count_); _i_++, _j_ += (_step_))     \
+        (_buf_)[_i_] = ((volatile CYG_WORD32 *)(_register_))[_j_];      \
+}
+
+#define HAL_WRITE_UINT32_VECTOR( _register_, _buf_, _count_, _step_ )   \
+{                                                                       \
+    cyg_count32 _i_,_j_;                                                \
+    for( _i_ = 0, _j_ = 0; _i_ < (_count_); _i_++, _j_ += (_step_))     \
+        ((volatile CYG_WORD32 *)(_register_))[_j_] = (_buf_)[_i_];      \
+}
+
+#define HAL_IO_MACROS_DEFINED
+
+#endif
+
+
+//-----------------------------------------------------------------------------
+#endif // ifndef CYGONCE_HAL_HAL_IO_H
+// End of hal_io.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc.inc ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc.inc
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc.inc	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc.inc	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,59 @@
+# ====================================================================
+#
+#      openrisc.inc
+#
+#      OpenRISC architectural definitions for assembly code
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 2003 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      sfurman
+# Original data:
+# Contributors:
+# Date:           2003-02-28
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+
+#ifndef _OPENRISC_INC_
+#define _OPENRISC_INC_
+
+/* Definition of special-purpose registers (SPRs) */
+#include <cyg/hal/spr_defs.h>
+
+#endif /* ifdef _OPENRISC_INC_ */
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_opcode.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_opcode.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_opcode.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_opcode.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,92 @@
+//=============================================================================
+//
+//      openrisc_opcode.h
+//
+//  Define the instruction formats and opcode values for the OpenRISC
+//  instruction set...or at least just enough of them to implement
+//  single-stepping.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   sfurman
+// Contributors:
+// Date:        2003-02-28
+// Purpose:     Allow dissection of OpenRISC instructions
+// Description: The types and macros defined here define the instruction
+//              formats of the OpenRISC instruction set...or at least the
+//              very limited subset necessary to allow single-stepping.
+//              
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#ifndef _OPENRISC_OPCODE_H
+#define _OPENRISC_OPCODE_H
+
+
+// Define the instruction formats.
+typedef union {
+    unsigned word;
+
+    // (Possibly conditional) relative jump w/ immediate displacement
+    struct {
+        unsigned op:      6;    // OP_J, OP_JAL, OP_BNF, or OP_BF
+        signed   target: 26;
+    } JType;
+
+    // Absolute jump w/ register contents used as PC target address
+    struct {
+        unsigned op:      6;	// OP_JR or OP_JALR
+        unsigned unused1:10;
+        unsigned rB:      5;	// Register containing new PC
+        unsigned unused2:11;
+    } JRType;
+
+} InstFmt;
+
+/*
+ * Values for the 'op' field.
+ */
+#define OP_J            0x00
+#define OP_JAL          0x01
+#define OP_BNF          0x03
+#define OP_BF           0x04
+#define OP_RFE          0x09
+#define OP_JR           0x11
+#define OP_JALR         0x12
+
+#endif  /* _OPENRISC_OPCODE_H */
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_stub.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_stub.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_stub.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/openrisc_stub.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,166 @@
+//========================================================================
+//
+//      openrisc_stub.h
+//
+//      OpenRISC-specific definitions for remote debugging via gdb
+//
+//========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   sfurman
+// Contributors:Red Hat, nickg, dmoseley
+// Date:        2003-02-18
+// Purpose:     OpenRISC-specific definitions for gdb stubs support
+//              
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#ifndef CYGONCE_HAL_OPENRISC_STUB_H
+#define CYGONCE_HAL_OPENRISC_STUB_H
+
+#include <pkgconf/system.h>
+#include <pkgconf/hal.h>
+
+#ifdef CYGPKG_IO_SERIAL
+#include <pkgconf/io_serial.h>
+#endif
+
+#include <cyg/hal/hal_diag.h>
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+
+#include <cyg/infra/cyg_type.h>         // CYG_UNUSED_PARAM, externC
+
+#define HAL_STUB_PLATFORM_INIT_SERIAL()       HAL_DIAG_INIT()
+
+#define HAL_STUB_PLATFORM_GET_CHAR()                                        \
+((cyg_int8)({                                                               \
+    cyg_int8 _ch_;                                                          \
+    HAL_DIAG_READ_CHAR(_ch_);                                               \
+    _ch_;                                                                   \
+}))
+
+#define HAL_STUB_PLATFORM_PUT_CHAR(c)         HAL_DIAG_WRITE_CHAR((c))
+
+#define HAL_STUB_PLATFORM_SET_BAUD_RATE(baud) CYG_UNUSED_PARAM(int,(baud))
+
+#define HAL_STUB_PLATFORM_RESET()             HAL_DIAG_INIT()
+
+#define HAL_STUB_PLATFORM_INIT()              HAL_DIAG_INIT()
+
+#endif // ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+
+// 32 GPRs + 32 VFRs + PC reg + SR reg
+#define NUMREGS 66
+
+// VFR regs are unimplemented so they are 0 bytes in length
+#define REGSIZE( _x_ ) ((((_x_) <= R31) || ((_x_) > VFR31)) ? 4 : 0)
+
+typedef unsigned long target_register_t;
+
+enum regnames {
+     R0,   SP,   R2,   R3,   R4,   R5,   R6,   R7,
+     R8,   R9,  R10,  R11,  R12,  R13,  R14,  R15,
+    R16,  R17,  R18,  R19,  R20,  R21,  R22,  R23,
+    R24,  R25,  R26,  R27,  R28,  R29,  R30,  R31,
+
+
+     // Vector/Float registers, which are as yet unimplemented,
+     // but defined in the or32 gdb back-end.
+
+    VFR0,  VFR1,  VFR2,  VFR3,  VFR4,  VFR5,  VFR6,  VFR7,
+    VFR8,  VFR9, VFR10, VFR11, VFR12, VFR13, VFR14, VFR15,
+   VFR16, VFR17, VFR18, VFR19, VFR20, VFR21, VFR22, VFR23,
+   VFR24, VFR25, VFR26, VFR27, VFR28, VFR29, VFR30, VFR31,
+
+     // Special-purpose registers
+      PC,    SR
+};
+
+typedef enum regnames regnames_t;
+
+// Override generic stubs get_register() and use arch-specific version
+#define CYGARC_STUB_REGISTER_ACCESS_DEFINED
+
+#if defined(CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT) || defined(CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT)
+#define HAL_GET_PROFILE_INFO( _thepc_, _thesp_ )                \
+    CYG_MACRO_START                                             \
+    extern HAL_SavedRegisters *hal_saved_interrupt_state;       \
+    if ( hal_saved_interrupt_state ) {                          \
+        (_thepc_) = (char *)(hal_saved_interrupt_state->pc);    \
+        (_thesp_) = (char *)(hal_saved_interrupt_state->sp);    \
+    }                                                           \
+    CYG_MACRO_END
+#endif
+
+/* Given a trap value TRAP, return the corresponding signal. */
+externC int __computeSignal (unsigned int trap_number);
+
+/* Return the trap number corresponding to the last-taken trap. */
+externC int __get_trap_number (void);
+
+/* Return the currently-saved value corresponding to register REG. */
+externC target_register_t get_register (regnames_t reg);
+
+/* Store VALUE in the register corresponding to WHICH. */
+externC void put_register (regnames_t which, target_register_t value);
+
+/* Set the currently-saved pc register value to PC. This also updates NPC
+   as needed. */
+externC void set_pc (target_register_t pc);
+
+/* Set things up so that the next user resume will execute one instruction.
+   This may be done by setting breakpoints or setting a single step flag
+   in the saved user registers, for example. */
+externC void __single_step (void);
+
+/* Clear the single-step state. */
+externC void __clear_single_step (void);
+
+/* If the breakpoint we hit is in the breakpoint() instruction, return a
+   non-zero value. */
+externC int __is_breakpoint_function (void);
+
+/* Skip the current instruction. */
+externC void __skipinst (void);
+
+externC void __install_breakpoints (void);
+
+externC void __clear_breakpoints (void);
+
+#endif // ifndef CYGONCE_HAL_OPENRISC_STUB_H
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/spr_defs.h ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/spr_defs.h
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/include/spr_defs.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/include/spr_defs.h	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,464 @@
+//==========================================================================
+//
+//      spr_defs.h
+//
+//      Defines OR1K architecture specific special-purpose registers (SPRs)
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: Damjan Lambert
+// Date:         2003-01-17
+// Purpose:      Define OpenRISC architecture special-purpose registers
+// Usage:        #include <cyg/hal/hal_arch.h>
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+/* Definition of special-purpose registers (SPRs) */
+
+#ifndef _ASM_SPR_DEFS_H
+#define _ASM_SPR_DEFS_H
+
+#define MAX_GRPS (32)
+#define MAX_SPRS_PER_GRP_BITS (11)
+#define MAX_SPRS_PER_GRP (1 << MAX_SPRS_PER_GRP_BITS)
+#define MAX_SPRS (0x10000)
+ 
+/* Base addresses for the groups */
+#define SPRGROUP_SYS    (0<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_DMMU   (1<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_IMMU   (2<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_DC     (3<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_IC     (4<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_MAC    (5<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_D      (6<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_PC     (7<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_PM     (8<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_PIC    (9<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_TT     (10<< MAX_SPRS_PER_GRP_BITS)
+
+/* System control and status group */
+#define SPR_VR          (SPRGROUP_SYS + 0)
+#define SPR_UPR         (SPRGROUP_SYS + 1)
+#define SPR_PC          (SPRGROUP_SYS + 16)  /* CZ 21/06/01 */
+#define SPR_SR          (SPRGROUP_SYS + 17)  /* CZ 21/06/01 */
+#define SPR_EPCR_BASE   (SPRGROUP_SYS + 32)  /* CZ 21/06/01 */
+#define SPR_EPCR_LAST   (SPRGROUP_SYS + 47)  /* CZ 21/06/01 */
+#define SPR_EEAR_BASE   (SPRGROUP_SYS + 48)
+#define SPR_EEAR_LAST   (SPRGROUP_SYS + 63)
+#define SPR_ESR_BASE    (SPRGROUP_SYS + 64)
+#define SPR_ESR_LAST    (SPRGROUP_SYS + 79)
+
+#if 0
+/* Data MMU group */
+#define SPR_DMMUCR      (SPRGROUP_DMMU + 0)
+#define SPR_DTLBMR_BASE(WAY)    (SPRGROUP_DMMU + 0x200 + (WAY) * 0x200)
+#define SPR_DTLBMR_LAST(WAY)    (SPRGROUP_DMMU + 0x2ff + (WAY) * 0x200)
+#define SPR_DTLBTR_BASE(WAY)    (SPRGROUP_DMMU + 0x300 + (WAY) * 0x200)
+#define SPR_DTLBTR_LAST(WAY)    (SPRGROUP_DMMU + 0x3ff + (WAY) * 0x200)
+
+/* Instruction MMU group */
+#define SPR_IMMUCR      (SPRGROUP_IMMU + 0)
+#define SPR_ITLBMR_BASE(WAY)    (SPRGROUP_IMMU + 0x200 + (WAY) * 0x200)
+#define SPR_ITLBMR_LAST(WAY)    (SPRGROUP_IMMU + 0x2ff + (WAY) * 0x200)
+#define SPR_ITLBTR_BASE(WAY)    (SPRGROUP_IMMU + 0x300 + (WAY) * 0x200)
+#define SPR_ITLBTR_LAST(WAY)    (SPRGROUP_IMMU + 0x3ff + (WAY) * 0x200)
+#else
+/* Data MMU group */
+#define SPR_DMMUCR      (SPRGROUP_DMMU + 0)
+#define SPR_DTLBMR_BASE(WAY)    (SPRGROUP_DMMU + 0x200 + (WAY) * 0x100)
+#define SPR_DTLBMR_LAST(WAY)    (SPRGROUP_DMMU + 0x27f + (WAY) * 0x100)
+#define SPR_DTLBTR_BASE(WAY)    (SPRGROUP_DMMU + 0x280 + (WAY) * 0x100)
+#define SPR_DTLBTR_LAST(WAY)    (SPRGROUP_DMMU + 0x2ff + (WAY) * 0x100)
+
+/* Instruction MMU group */
+#define SPR_IMMUCR      (SPRGROUP_IMMU + 0)
+#define SPR_ITLBMR_BASE(WAY)    (SPRGROUP_IMMU + 0x200 + (WAY) * 0x100)
+#define SPR_ITLBMR_LAST(WAY)    (SPRGROUP_IMMU + 0x27f + (WAY) * 0x100)
+#define SPR_ITLBTR_BASE(WAY)    (SPRGROUP_IMMU + 0x280 + (WAY) * 0x100)
+#define SPR_ITLBTR_LAST(WAY)    (SPRGROUP_IMMU + 0x2ff + (WAY) * 0x100)
+#endif
+
+/* Data cache group */
+#define SPR_DCCR        (SPRGROUP_DC + 0)
+#define SPR_DCBPR       (SPRGROUP_DC + 1)
+#define SPR_DCBFR       (SPRGROUP_DC + 2)
+#define SPR_DCBIR       (SPRGROUP_DC + 3)
+#define SPR_DCBWR       (SPRGROUP_DC + 4)
+#define SPR_DCBLR       (SPRGROUP_DC + 5)
+#define SPR_DCR_BASE(WAY)       (SPRGROUP_DC + 0x200 + (WAY) * 0x200)
+#define SPR_DCR_LAST(WAY)       (SPRGROUP_DC + 0x3ff + (WAY) * 0x200)
+
+/* Instruction cache group */
+#define SPR_ICCR        (SPRGROUP_IC + 0)
+#define SPR_ICBPR       (SPRGROUP_IC + 1)
+#define SPR_ICBIR       (SPRGROUP_IC + 2)
+#define SPR_ICBLR       (SPRGROUP_IC + 3)
+#define SPR_ICR_BASE(WAY)       (SPRGROUP_IC + 0x200 + (WAY) * 0x200)
+#define SPR_ICR_LAST(WAY)       (SPRGROUP_IC + 0x3ff + (WAY) * 0x200)
+
+/* MAC group */
+#define SPR_MACLO       (SPRGROUP_MAC + 1)
+#define SPR_MACHI       (SPRGROUP_MAC + 2)
+
+/* Debug group */
+#define SPR_DVR(N)      (SPRGROUP_D + (N))
+#define SPR_DCR(N)      (SPRGROUP_D + 8 + (N))
+#define SPR_DMR1        (SPRGROUP_D + 16)
+#define SPR_DMR2        (SPRGROUP_D + 17)
+#define SPR_DWCR0       (SPRGROUP_D + 18)
+#define SPR_DWCR1       (SPRGROUP_D + 19)
+#define SPR_DSR         (SPRGROUP_D + 20)
+#define SPR_DRR         (SPRGROUP_D + 21)
+#define SPR_DIR         (SPRGROUP_D + 22)
+
+/* Performance counters group */
+#define SPR_PCCR(N)     (SPRGROUP_PC + (N))
+#define SPR_PCMR(N)     (SPRGROUP_PC + 8 + (N))
+
+/* Power management group */
+#define SPR_PMR (SPRGROUP_PM + 0)
+
+/* PIC group */
+#define SPR_PICMR (SPRGROUP_PIC + 0)
+#define SPR_PICPR (SPRGROUP_PIC + 1)
+#define SPR_PICSR (SPRGROUP_PIC + 2)
+
+/* Tick Timer group */
+#define SPR_TTMR (SPRGROUP_TT + 0)
+#define SPR_TTCR (SPRGROUP_TT + 1)
+
+/*
+ * Bit definitions for the Version Register
+ *
+ */
+#define SPR_VR_VER      0xffff0000  /* Processor version */
+#define SPR_VR_REV      0x0000003f  /* Processor revision */
+
+/*
+ * Bit definitions for the Unit Present Register
+ *
+ */
+#define SPR_UPR_UP      0x00000001  /* UPR present */
+#define SPR_UPR_DCP     0x00000002  /* Data cache present */
+#define SPR_UPR_ICP     0x00000004  /* Instruction cache present */
+#define SPR_UPR_DMP     0x00000008  /* Data MMU present */
+#define SPR_UPR_IMP     0x00000010  /* Instruction MMU present */
+#define SPR_UPR_OB32P   0x00000020  /* ORBIS32 present */
+#define SPR_UPR_OB64P   0x00000040  /* ORBIS64 present */
+#define SPR_UPR_OF32P   0x00000080  /* ORFPX32 present */
+#define SPR_UPR_OF64P   0x00000100  /* ORFPX64 present */
+#define SPR_UPR_OV32P   0x00000200  /* ORVDX32 present */
+#define SPR_UPR_OV64P   0x00000400  /* ORVDX64 present */
+#define SPR_UPR_DUP     0x00000800  /* Debug unit present */
+#define SPR_UPR_PCUP    0x00001000  /* Performance counters unit present */
+#define SPR_UPR_PMP     0x00002000  /* Power management present */
+#define SPR_UPR_PICP    0x00004000  /* PIC present */
+#define SPR_UPR_TTP     0x00008000  /* Tick timer present */
+#define SPR_UPR_SRP     0x00010000  /* Shadow registers present */
+#define SPR_UPR_RES     0x00fe0000  /* ORVDX32 present */
+#define SPR_UPR_CUST    0xff000000  /* Custom units */
+
+/*
+ * Bit definitions for the Supervision Register
+ *
+ */
+#define SPR_SR_CID      0xf0000000  /* Context ID */
+#define SPR_SR_FO       0x00008000  /* Fixed one */
+#define SPR_SR_EPH      0x00004000  /* Exception Prefixi High */
+#define SPR_SR_DSX      0x00002000  /* Delay Slot Exception */
+#define SPR_SR_OVE      0x00001000  /* Overflow flag Exception */
+#define SPR_SR_OV       0x00000800  /* Overflow flag */
+#define SPR_SR_CY       0x00000400  /* Carry flag */
+#define SPR_SR_F        0x00000200  /* Condition Flag */
+#define SPR_SR_CE       0x00000100  /* CID Enable */
+#define SPR_SR_LEE      0x00000080  /* Little Endian Enable */
+#define SPR_SR_IME      0x00000040  /* Instruction MMU Enable */
+#define SPR_SR_DME      0x00000020  /* Data MMU Enable */
+#define SPR_SR_ICE      0x00000010  /* Instruction Cache Enable */
+#define SPR_SR_DCE      0x00000008  /* Data Cache Enable */
+#define SPR_SR_IEE      0x00000004  /* Interrupt Exception Enable */
+#define SPR_SR_TEE      0x00000002  /* Tick timer Exception Enable */
+#define SPR_SR_SM       0x00000001  /* Supervisor Mode */
+#define SPR_SR_FO_BIT    15
+#define SPR_SR_EPH_BIT   14
+#define SPR_SR_DSX_BIT   13
+#define SPR_SR_OVE_BIT   12
+#define SPR_SR_OV_BIT    11
+#define SPR_SR_CY_BIT    10
+#define SPR_SR_F_BIT     9
+#define SPR_SR_CE_BIT    8
+#define SPR_SR_LEE_BIT   7
+#define SPR_SR_IME_BIT   6
+#define SPR_SR_DME_BIT   5
+#define SPR_SR_ICE_BIT   4
+#define SPR_SR_DCE_BIT   3
+#define SPR_SR_IEE_BIT   2
+#define SPR_SR_TEE_BIT   1
+#define SPR_SR_SM_BIT    0
+
+
+/*
+ * Bit definitions for the Data MMU Control Register
+ *
+ */
+#define SPR_DMMUCR_P2S  0x0000003e  /* Level 2 Page Size */
+#define SPR_DMMUCR_P1S  0x000007c0  /* Level 1 Page Size */
+#define SPR_DMMUCR_VADDR_WIDTH  0x0000f800  /* Virtual ADDR Width */
+#define SPR_DMMUCR_PADDR_WIDTH  0x000f0000  /* Physical ADDR Width */
+
+/*
+ * Bit definitions for the Instruction MMU Control Register
+ *
+ */
+#define SPR_IMMUCR_P2S  0x0000003e  /* Level 2 Page Size */
+#define SPR_IMMUCR_P1S  0x000007c0  /* Level 1 Page Size */
+#define SPR_IMMUCR_VADDR_WIDTH  0x0000f800  /* Virtual ADDR Width */
+#define SPR_IMMUCR_PADDR_WIDTH  0x000f0000  /* Physical ADDR Width */
+
+/*
+ * Bit definitions for the Data TLB Match Register
+ *
+ */
+#define SPR_DTLBMR_V    0x00000001  /* Valid */
+#define SPR_DTLBMR_PL1  0x00000002  /* Page Level 1 (if 0 then PL2) */
+#define SPR_DTLBMR_CID  0x0000003c  /* Context ID */
+#define SPR_DTLBMR_LRU  0x000000c0  /* Least Recently Used */
+#define SPR_DTLBMR_VPN  0xfffff000  /* Virtual Page Number */
+
+/*
+ * Bit definitions for the Data TLB Translate Register
+ *
+ */
+#define SPR_DTLBTR_CC   0x00000001  /* Cache Coherency */
+#define SPR_DTLBTR_CI   0x00000002  /* Cache Inhibit */
+#define SPR_DTLBTR_WBC  0x00000004  /* Write-Back Cache */
+#define SPR_DTLBTR_WOM  0x00000008  /* Weakly-Ordered Memory */
+#define SPR_DTLBTR_A    0x00000010  /* Accessed */
+#define SPR_DTLBTR_D    0x00000020  /* Dirty */
+#define SPR_DTLBTR_URE  0x00000040  /* User Read Enable */
+#define SPR_DTLBTR_UWE  0x00000080  /* User Write Enable */
+#define SPR_DTLBTR_SRE  0x00000100  /* Supervisor Read Enable */
+#define SPR_DTLBTR_SWE  0x00000200  /* Supervisor Write Enable */
+#define SPR_DTLBTR_PPN  0xfffff000  /* Physical Page Number */
+#define DTLBTR_NO_LIMIT ( SPR_DTLBTR_URE |  \
+                          SPR_DTLBTR_UWE |  \
+                          SPR_DTLBTR_SRE |  \
+                          SPR_DTLBTR_SWE )
+
+/*
+ * Bit definitions for the Instruction TLB Match Register
+ *
+ */
+#define SPR_ITLBMR_V    0x00000001  /* Valid */
+#define SPR_ITLBMR_PL1  0x00000002  /* Page Level 1 (if 0 then PL2) */
+#define SPR_ITLBMR_CID  0x0000003c  /* Context ID */
+#define SPR_ITLBMR_LRU  0x000000c0  /* Least Recently Used */
+#define SPR_ITLBMR_VPN  0xfffff000  /* Virtual Page Number */
+
+/*
+ * Bit definitions for the Instruction TLB Translate Register
+ *
+ */
+#define SPR_ITLBTR_CC   0x00000001  /* Cache Coherency */
+#define SPR_ITLBTR_CI   0x00000002  /* Cache Inhibit */
+#define SPR_ITLBTR_WBC  0x00000004  /* Write-Back Cache */
+#define SPR_ITLBTR_WOM  0x00000008  /* Weakly-Ordered Memory */
+#define SPR_ITLBTR_A    0x00000010  /* Accessed */
+#define SPR_ITLBTR_D    0x00000020  /* Dirty */
+#define SPR_ITLBTR_SXE  0x00000040  /* User Read Enable */
+#define SPR_ITLBTR_UXE  0x00000080  /* User Write Enable */
+#define SPR_ITLBTR_PPN  0xfffff000  /* Physical Page Number */
+#define ITLBTR_NO_LIMIT (SPR_ITLBTR_SXE | SPR_ITLBTR_UXE)
+
+/*
+ * Bit definitions for Data Cache Control register
+ *
+ */
+#define SPR_DCCR_EW     0x000000ff  /* Enable ways */
+
+/*
+ * Bit definitions for Insn Cache Control register
+ *
+ */
+#define SPR_ICCR_EW     0x000000ff  /* Enable ways */
+
+/*
+ * Bit definitions for Debug Control registers
+ *
+ */
+#define SPR_DCR_DP      0x00000001  /* DVR/DCR present */
+#define SPR_DCR_CC      0x0000000e  /* Compare condition */
+#define SPR_DCR_SC      0x00000010  /* Signed compare */
+#define SPR_DCR_CT      0x000000e0  /* Compare to */
+
+/*
+ * Bit definitions for Debug Mode 1 register
+ *
+ */
+#define SPR_DMR1_CW0    0x00000003  /* Chain watchpoint 0 */
+#define SPR_DMR1_CW1    0x0000000c  /* Chain watchpoint 1 */
+#define SPR_DMR1_CW2    0x00000030  /* Chain watchpoint 2 */
+#define SPR_DMR1_CW3    0x000000c0  /* Chain watchpoint 3 */
+#define SPR_DMR1_CW4    0x00000300  /* Chain watchpoint 4 */
+#define SPR_DMR1_CW5    0x00000c00  /* Chain watchpoint 5 */
+#define SPR_DMR1_CW6    0x00003000  /* Chain watchpoint 6 */
+#define SPR_DMR1_CW7    0x0000c000  /* Chain watchpoint 7 */
+#define SPR_DMR1_CW8    0x00030000  /* Chain watchpoint 8 */
+#define SPR_DMR1_CW9    0x000c0000  /* Chain watchpoint 9 */
+#define SPR_DMR1_CW10   0x00300000  /* Chain watchpoint 10 */
+#define SPR_DMR1_ST     0x00400000  /* Single-step trace*/
+#define SPR_DMR1_BT     0x00800000  /* Branch trace */
+#define SPR_DMR1_DXFW   0x01000000  /* Disable external force watchpoint */
+
+/*
+ * Bit definitions for Debug Mode 2 register
+ *
+ */
+#define SPR_DMR2_WCE0   0x00000001  /* Watchpoint counter 0 enable */
+#define SPR_DMR2_WCE1   0x00000002  /* Watchpoint counter 0 enable */
+#define SPR_DMR2_AWTC   0x00001ffc  /* Assign watchpoints to counters */
+#define SPR_DMR2_WGB    0x00ffe000  /* Watchpoints generating breakpoint */
+
+/*
+ * Bit definitions for Debug watchpoint counter registers
+ *
+ */
+#define SPR_DWCR_COUNT  0x0000ffff  /* Count */
+#define SPR_DWCR_MATCH  0xffff0000  /* Match */
+
+/*
+ * Bit definitions for Debug stop register
+ *
+ */
+#define SPR_DSR_RSTE    0x00000001  /* Reset exception */
+#define SPR_DSR_BUSEE   0x00000002  /* Bus error exception */
+#define SPR_DSR_DPFE    0x00000004  /* Data Page Fault exception */
+#define SPR_DSR_IPFE    0x00000008  /* Insn Page Fault exception */
+#define SPR_DSR_LPINTE  0x00000010  /* Low priority interrupt exception */
+#define SPR_DSR_AE      0x00000020  /* Alignment exception */
+#define SPR_DSR_IIE     0x00000040  /* Illegal Instruction exception */
+#define SPR_DSR_HPINTE  0x00000080  /* High priority interrupt exception */
+#define SPR_DSR_DME     0x00000100  /* DTLB miss exception */
+#define SPR_DSR_IME     0x00000200  /* ITLB miss exception */
+#define SPR_DSR_RE      0x00000400  /* Range exception */
+#define SPR_DSR_SCE     0x00000800  /* System call exception */
+#define SPR_DSR_BE      0x00001000  /* Breakpoint exception */
+
+/*
+ * Bit definitions for Debug reason register
+ *
+ */
+#define SPR_DRR_RSTE    0x00000001  /* Reset exception */
+#define SPR_DRR_BUSEE   0x00000002  /* Bus error exception */
+#define SPR_DRR_DPFE    0x00000004  /* Data Page Fault exception */
+#define SPR_DRR_IPFE    0x00000008  /* Insn Page Fault exception */
+#define SPR_DRR_LPINTE  0x00000010  /* Low priority interrupt exception */
+#define SPR_DRR_AE      0x00000020  /* Alignment exception */
+#define SPR_DRR_IIE     0x00000040  /* Illegal Instruction exception */
+#define SPR_DRR_HPINTE  0x00000080  /* High priority interrupt exception */
+#define SPR_DRR_DME     0x00000100  /* DTLB miss exception */
+#define SPR_DRR_IME     0x00000200  /* ITLB miss exception */
+#define SPR_DRR_RE      0x00000400  /* Range exception */
+#define SPR_DRR_SCE     0x00000800  /* System call exception */
+#define SPR_DRR_BE      0x00001000  /* Breakpoint exception */
+
+/*
+ * Bit definitions for Performance counters mode registers
+ *
+ */
+#define SPR_PCMR_CP     0x00000001  /* Counter present */
+#define SPR_PCMR_UMRA   0x00000002  /* User mode read access */
+#define SPR_PCMR_CISM   0x00000004  /* Count in supervisor mode */
+#define SPR_PCMR_CIUM   0x00000008  /* Count in user mode */
+#define SPR_PCMR_LA     0x00000010  /* Load access event */
+#define SPR_PCMR_SA     0x00000020  /* Store access event */
+#define SPR_PCMR_IF     0x00000040  /* Instruction fetch event*/
+#define SPR_PCMR_DCM    0x00000080  /* Data cache miss event */
+#define SPR_PCMR_ICM    0x00000100  /* Insn cache miss event */
+#define SPR_PCMR_IFS    0x00000200  /* Insn fetch stall event */
+#define SPR_PCMR_LSUS   0x00000400  /* LSU stall event */
+#define SPR_PCMR_BS     0x00000800  /* Branch stall event */
+#define SPR_PCMR_DTLBM  0x00001000  /* DTLB miss event */
+#define SPR_PCMR_ITLBM  0x00002000  /* ITLB miss event */
+#define SPR_PCMR_DDS    0x00004000  /* Data dependency stall event */
+#define SPR_PCMR_WPE    0x03ff8000  /* Watchpoint events */
+
+/* 
+ * Bit definitions for the Power management register
+ *
+ */
+#define SPR_PMR_SDF     0x00000001  /* Slow down factor */
+#define SPR_PMR_DME     0x00000002  /* Doze mode enable */
+#define SPR_PMR_SME     0x00000004  /* Sleep mode enable */
+#define SPR_PMR_DCGE    0x00000008  /* Dynamic clock gating enable */
+#define SPR_PMR_SUME    0x00000010  /* Suspend mode enable */
+
+/*
+ * Bit definitions for PICMR
+ *
+ */
+#define SPR_PICMR_IUM   0xfffffffc  /* Interrupt unmask */
+
+/*
+ * Bit definitions for PICPR
+ *
+ */
+#define SPR_PICPR_IPRIO 0xfffffffc  /* Interrupt priority */
+
+/*
+ * Bit definitions for PICSR
+ *
+ */
+#define SPR_PICSR_IS    0xffffffff  /* Interrupt status */
+
+/*
+ * Bit definitions for Tick Timer Control Register
+ *
+ */
+#define SPR_TTCR_PERIOD 0x0fffffff  /* Time Period */
+#define SPR_TTMR_PERIOD SPR_TTCR_PERIOD
+#define SPR_TTMR_IP 0x10000000  /* Interrupt Pending */
+#define SPR_TTMR_IE 0x20000000  /* Interrupt Enable */
+#define SPR_TTMR_RT 0x40000000  /* Restart tick */
+#define SPR_TTMR_SR     0x80000000  /* Single run */
+#define SPR_TTMR_CR     0xc0000000  /* Continuous run */
+#define SPR_TTMR_M      0xc0000000  /* Tick mode */
+
+#endif
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/context.S ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/context.S
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/context.S	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/context.S	2010-02-15 15:20:32.989490600 -0800
@@ -0,0 +1,296 @@
+##=============================================================================##
+##      context.S
+##
+##      OpenRISC context switch code
+##
+##=============================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+##=============================================================================
+#######DESCRIPTIONBEGIN####
+##
+## Author(s):   Scott Furman
+## Contributors:
+## Date:        2003-01-21
+## Purpose:     OpenRISC context switch code
+## Description: This file contains implementations of the thread context 
+##              switch routines. It also contains the longjmp() and setjmp()
+##              routines.
+##
+######DESCRIPTIONEND####
+##
+##=============================================================================
+
+#include <pkgconf/hal.h>
+
+#include <cyg/hal/arch.inc>
+#include <cyg/hal/openrisc.inc>
+
+
+
+#------------------------------------------------------------------------------
+# hal_thread_switch_context()
+# Switch thread contexts
+# R3 = address of sp of next thread to execute
+# R4 = address of sp save location of current thread
+
+FUNC_START(hal_thread_switch_context)
+        l.addi  sp,sp,-SIZEOF_OR1KREGS  # space for registers
+
+        # Store General Purpose Registers (GPRs).
+        l.sw     2 * OR1K_GPRSIZE(sp), r2
+        l.sw     9 * OR1K_GPRSIZE(sp), r9
+        l.sw    10 * OR1K_GPRSIZE(sp), r10
+        l.sw    12 * OR1K_GPRSIZE(sp), r12
+        l.sw    14 * OR1K_GPRSIZE(sp), r14
+        l.sw    16 * OR1K_GPRSIZE(sp), r16
+        l.sw    18 * OR1K_GPRSIZE(sp), r18
+        l.sw    20 * OR1K_GPRSIZE(sp), r20
+        l.sw    22 * OR1K_GPRSIZE(sp), r22
+        l.sw    24 * OR1K_GPRSIZE(sp), r24
+        l.sw    26 * OR1K_GPRSIZE(sp), r26
+        l.sw    28 * OR1K_GPRSIZE(sp), r28
+        l.sw    30 * OR1K_GPRSIZE(sp), r30
+
+#ifndef CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+        
+        # R0 is not typically stored because it is always zero-valued,
+        # but we store it here for consistency when examining registers
+        # in the debugger.
+        l.sw     0 * OR1K_GPRSIZE(sp), r0
+
+        # Caller-saved regs don't need to be preserved across
+        # context switches, but we do so to make debugging easier.
+
+        l.sw     3 * OR1K_GPRSIZE(sp), r3
+        l.sw     4 * OR1K_GPRSIZE(sp), r4
+        l.sw     5 * OR1K_GPRSIZE(sp), r5
+        l.sw     6 * OR1K_GPRSIZE(sp), r6
+        l.sw     7 * OR1K_GPRSIZE(sp), r7
+        l.sw     8 * OR1K_GPRSIZE(sp), r8
+        l.sw    11 * OR1K_GPRSIZE(sp), r11
+        l.sw    13 * OR1K_GPRSIZE(sp), r13
+        l.sw    15 * OR1K_GPRSIZE(sp), r15
+        l.sw    17 * OR1K_GPRSIZE(sp), r17
+        l.sw    19 * OR1K_GPRSIZE(sp), r19
+        l.sw    21 * OR1K_GPRSIZE(sp), r21
+        l.sw    23 * OR1K_GPRSIZE(sp), r23
+        l.sw    25 * OR1K_GPRSIZE(sp), r25
+        l.sw    27 * OR1K_GPRSIZE(sp), r27
+        l.sw    29 * OR1K_GPRSIZE(sp), r29
+        l.sw    31 * OR1K_GPRSIZE(sp), r31
+
+        # save MAC LO and HI regs
+        l.mfspr r5,r0,SPR_MACLO
+        l.sw    OR1KREG_MACLO(sp),r5
+        l.mfspr r5,r0,SPR_MACHI
+        l.sw    OR1KREG_MACHI(sp),r5
+        
+#endif
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+        # Make the thread context look like an exception context if thread-
+        # aware debugging is required. This state does not need restoring.
+        l.sw    OR1KREG_PC(sp),r9
+#endif
+
+        l.addi  r5,sp,SIZEOF_OR1KREGS           # save SP in reg dump
+        l.sw     1 * OR1K_GPRSIZE(sp), r5
+
+        l.mfspr  r5,r0,SPR_SR                   # save SR in reg dump
+        l.sw     OR1KREG_SR(sp), r5
+
+        # Return resulting new SP to caller via second argument
+        l.sw     0(r4), sp
+
+        # Now load the destination thread by dropping through
+        # to hal_thread_load_context...
+FUNC_END(hal_thread_switch_context)
+
+                
+#------------------------------------------------------------------------------
+# hal_thread_load_context()
+# Load thread context
+# R3 = address of sp of next thread to execute
+# Note that this function is also the second half of hal_thread_switch_context()
+# and is simply dropped into from it.
+        
+FUNC_START(hal_thread_load_context)
+
+        # Copy R3 to SP         
+        l.lwz   sp, 0(r3)
+
+        # Restore General Purpose Registers (GPRs).
+        # R0 is not restored because it is always zero-valued.
+        l.lwz   r2,   2 * OR1K_GPRSIZE(sp)
+        l.lwz   r9,   9 * OR1K_GPRSIZE(sp)
+        l.lwz   r10, 10 * OR1K_GPRSIZE(sp)
+        l.lwz   r12, 12 * OR1K_GPRSIZE(sp)
+        l.lwz   r14, 14 * OR1K_GPRSIZE(sp)
+        l.lwz   r16, 16 * OR1K_GPRSIZE(sp)
+        l.lwz   r18, 18 * OR1K_GPRSIZE(sp)
+        l.lwz   r20, 20 * OR1K_GPRSIZE(sp)
+        l.lwz   r22, 22 * OR1K_GPRSIZE(sp)
+        l.lwz   r24, 24 * OR1K_GPRSIZE(sp)
+        l.lwz   r26, 26 * OR1K_GPRSIZE(sp)
+        l.lwz   r28, 28 * OR1K_GPRSIZE(sp)
+        l.lwz   r30, 30 * OR1K_GPRSIZE(sp)
+
+        # Merge interrupt-enable state of new thread into
+        # current SR
+        load32i r5,~(SPR_SR_TEE|SPR_SR_IEE)
+        l.mfspr r6, r0, SPR_SR
+        l.and   r6, r5, r6
+        l.lwz   r5,  OR1KREG_SR(sp)
+        l.andi  r5, r5, (SPR_SR_TEE|SPR_SR_IEE)
+        l.or    r5, r5, r6
+        l.mtspr r0, r5, SPR_SR
+
+#ifndef CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+
+        # Caller-saved regs don't need to be preserved across
+        # context switches, but we do so here to make debugging
+        # easier.
+
+        # Restore MAC LO and HI regs
+        l.lwz   r5, OR1KREG_MACLO(sp)
+        l.mtspr r0,r5,SPR_MACLO
+        l.lwz   r5, OR1KREG_MACHI(sp)
+        l.mtspr r0,r5,SPR_MACHI
+
+        l.lwz    r4,  4 * OR1K_GPRSIZE(sp)
+        l.lwz    r5,  5 * OR1K_GPRSIZE(sp)
+        l.lwz    r6,  6 * OR1K_GPRSIZE(sp)
+        l.lwz    r7,  7 * OR1K_GPRSIZE(sp)
+        l.lwz    r8,  8 * OR1K_GPRSIZE(sp)
+        l.lwz   r11, 11 * OR1K_GPRSIZE(sp)
+        l.lwz   r13, 13 * OR1K_GPRSIZE(sp)
+        l.lwz   r15, 15 * OR1K_GPRSIZE(sp)
+        l.lwz   r17, 17 * OR1K_GPRSIZE(sp)
+        l.lwz   r19, 19 * OR1K_GPRSIZE(sp)
+        l.lwz   r21, 21 * OR1K_GPRSIZE(sp)
+        l.lwz   r23, 23 * OR1K_GPRSIZE(sp)
+        l.lwz   r25, 25 * OR1K_GPRSIZE(sp)
+        l.lwz   r27, 27 * OR1K_GPRSIZE(sp)
+        l.lwz   r29, 29 * OR1K_GPRSIZE(sp)
+        l.lwz   r31, 31 * OR1K_GPRSIZE(sp)
+
+#endif
+
+	# If this is the first time we're running a thread, R3
+	# contains the argument to the thread entry point function,
+	# So we always have to restore it even though it's a callee-saved
+	# register.
+        l.lwz    r3,  3 * OR1K_GPRSIZE(sp)
+
+        # Finally, restore target thread's true SP
+        l.lwz   sp,   1 * OR1K_GPRSIZE(sp)
+
+        l.jr    lr
+        l.nop                                   # delay slot - must be nop
+
+FUNC_END(hal_thread_load_context)
+        
+#------------------------------------------------------------------------------
+# HAL longjmp, setjmp implementations
+# hal_setjmp saves only callee-saved registers into buffer supplied in r3:
+#       1,2,9,10,13,15,17,19,21,23,25,27,29,31
+# Note: These definitions are repeated in hal_arch.h. If changes are required
+# remember to update both sets.
+
+#define CYGARC_JMP_BUF_R1        0
+#define CYGARC_JMP_BUF_R2        1
+#define CYGARC_JMP_BUF_R9        2
+#define CYGARC_JMP_BUF_R10       3
+#define CYGARC_JMP_BUF_R12       4
+#define CYGARC_JMP_BUF_R14       5
+#define CYGARC_JMP_BUF_R16       6
+#define CYGARC_JMP_BUF_R18       7
+#define CYGARC_JMP_BUF_R20       8
+#define CYGARC_JMP_BUF_R22       9
+#define CYGARC_JMP_BUF_R24      10
+#define CYGARC_JMP_BUF_R26      11
+#define CYGARC_JMP_BUF_R28      12
+#define CYGARC_JMP_BUF_R30      13
+
+#define CYGARC_JMP_BUF_SIZE     14
+
+#define jmpbuf_regsize 4
+
+FUNC_START(hal_setjmp)
+        # Store General Purpose Registers (GPRs).
+        # R0 is not stored because it is always zero-valued.
+        # Caller-saved registers are not stored
+        l.sw    CYGARC_JMP_BUF_R1  * OR1K_GPRSIZE(r3), r1
+        l.sw    CYGARC_JMP_BUF_R2  * OR1K_GPRSIZE(r3), r2
+        l.sw    CYGARC_JMP_BUF_R9  * OR1K_GPRSIZE(r3), r9
+        l.sw    CYGARC_JMP_BUF_R10 * OR1K_GPRSIZE(r3), r10
+        l.sw    CYGARC_JMP_BUF_R12 * OR1K_GPRSIZE(r3), r12
+        l.sw    CYGARC_JMP_BUF_R14 * OR1K_GPRSIZE(r3), r14
+        l.sw    CYGARC_JMP_BUF_R16 * OR1K_GPRSIZE(r3), r16
+        l.sw    CYGARC_JMP_BUF_R18 * OR1K_GPRSIZE(r3), r18
+        l.sw    CYGARC_JMP_BUF_R20 * OR1K_GPRSIZE(r3), r20
+        l.sw    CYGARC_JMP_BUF_R22 * OR1K_GPRSIZE(r3), r22
+        l.sw    CYGARC_JMP_BUF_R24 * OR1K_GPRSIZE(r3), r24
+        l.sw    CYGARC_JMP_BUF_R26 * OR1K_GPRSIZE(r3), r26
+        l.sw    CYGARC_JMP_BUF_R28 * OR1K_GPRSIZE(r3), r28
+        l.sw    CYGARC_JMP_BUF_R30 * OR1K_GPRSIZE(r3), r30
+        load32i rv, 0
+        l.jr    lr
+        l.nop                   # delay slot
+FUNC_END(hal_setjmp)
+
+
+FUNC_START(hal_longjmp)
+        l.lwz    r1, CYGARC_JMP_BUF_R1  * OR1K_GPRSIZE(r3)
+        l.lwz    r2, CYGARC_JMP_BUF_R2  * OR1K_GPRSIZE(r3)
+        l.lwz    r9, CYGARC_JMP_BUF_R9  * OR1K_GPRSIZE(r3)
+        l.lwz   r10, CYGARC_JMP_BUF_R10 * OR1K_GPRSIZE(r3)
+        l.lwz   r12, CYGARC_JMP_BUF_R12 * OR1K_GPRSIZE(r3)
+        l.lwz   r14, CYGARC_JMP_BUF_R14 * OR1K_GPRSIZE(r3)
+        l.lwz   r16, CYGARC_JMP_BUF_R16 * OR1K_GPRSIZE(r3)
+        l.lwz   r18, CYGARC_JMP_BUF_R18 * OR1K_GPRSIZE(r3)
+        l.lwz   r20, CYGARC_JMP_BUF_R20 * OR1K_GPRSIZE(r3)
+        l.lwz   r22, CYGARC_JMP_BUF_R22 * OR1K_GPRSIZE(r3)
+        l.lwz   r24, CYGARC_JMP_BUF_R24 * OR1K_GPRSIZE(r3)
+        l.lwz   r26, CYGARC_JMP_BUF_R26 * OR1K_GPRSIZE(r3)
+        l.lwz   r28, CYGARC_JMP_BUF_R28 * OR1K_GPRSIZE(r3)
+        l.lwz   r30, CYGARC_JMP_BUF_R30 * OR1K_GPRSIZE(r3)
+
+        l.jr    lr
+        l.nop                   # delay slot
+FUNC_END(hal_longjmp)
+        
+
+#------------------------------------------------------------------------------
+# end of context.S
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/hal_misc.c ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/hal_misc.c
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/hal_misc.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/hal_misc.c	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,283 @@
+//==========================================================================
+//
+//      hal_misc.c
+//
+//      HAL miscellaneous functions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    nickg
+// Contributors: nickg, jlarmour
+// Date:         1999-01-21
+// Purpose:      HAL miscellaneous functions
+// Description:  This file contains miscellaneous functions provided by the
+//               HAL.
+//
+//####DESCRIPTIONEND####
+//
+//========================================================================*/
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>         // Base types
+#include <cyg/infra/cyg_trac.h>         // tracing macros
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#define CYGARC_HAL_COMMON_EXPORT_CPU_MACROS
+#include <cyg/hal/hal_arch.h>           // architectural definitions
+#include <cyg/hal/hal_intr.h>           // Interrupt handling
+#include <cyg/hal/hal_if.h>             // hal_ctrlc_isr()
+
+#include CYGHWR_MEMORY_LAYOUT_H
+
+/*------------------------------------------------------------------------*/
+/* If required, define a variable to store the clock period.              */
+
+#ifdef CYGHWR_HAL_CLOCK_PERIOD_DEFINED
+
+CYG_WORD32 cyg_hal_clock_period;
+
+#endif
+
+/*------------------------------------------------------------------------*/
+/* First level C exception handler.                                       */
+
+externC void __handle_exception (void);
+
+externC HAL_SavedRegisters *_hal_registers;
+
+externC void* volatile __mem_fault_handler;
+
+externC cyg_uint8 cyg_hal_mips_process_fpe( HAL_SavedRegisters *regs );
+
+externC cyg_uint32 cyg_hal_exception_handler(HAL_SavedRegisters *regs)
+{
+#if defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+
+    // If we caught an exception inside the stubs, see if we were expecting it
+    // and if so jump to the saved address
+    if (__mem_fault_handler) {
+        regs->pc = (CYG_HAL_OPENRISC_REG)(signed long)__mem_fault_handler;
+        return 0; // Caught an exception inside stubs        
+    }
+
+    // Set the pointer to the registers of the current exception
+    // context. At entry the GDB stub will expand the
+    // HAL_SavedRegisters structure into a (bigger) register array.
+    _hal_registers = regs;
+    __handle_exception();
+
+#elif defined(CYGFUN_HAL_COMMON_KERNEL_SUPPORT) && defined(CYGPKG_HAL_EXCEPTIONS)
+
+    // We should decode the vector and pass a more appropriate
+    // value as the second argument. For now we simply pass a
+    // pointer to the saved registers. We should also divert
+    // breakpoint and other debug vectors into the debug stubs.
+    
+    cyg_hal_deliver_exception( regs->vector, (CYG_ADDRWORD)regs );
+
+#else
+    
+    CYG_FAIL("Exception!!!");
+    
+#endif    
+    return 0;
+}
+
+/*------------------------------------------------------------------------*/
+/* default ISR                                                            */
+
+externC cyg_uint32
+hal_arch_default_isr(CYG_ADDRWORD vector, CYG_ADDRWORD data)
+{
+    return 0;
+}
+
+/*------------------------------------------------------------------------*/
+// Come here if interrupt triggered, but no apparent cause
+void hal_spurious_IRQ(HAL_SavedRegisters *regs) CYGBLD_ATTRIB_WEAK;
+void
+hal_spurious_IRQ(HAL_SavedRegisters *regs)
+{
+#if defined(CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS)
+    cyg_hal_exception_handler(regs);
+#else
+    CYG_FAIL("Spurious interrupt!!");
+#endif    
+}
+/*------------------------------------------------------------------------*/
+
+#ifdef CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG
+cyg_bool cyg_hal_stop_constructors;
+#endif
+
+typedef void (*pfunc) (void);
+extern pfunc __CTOR_LIST__[];
+extern pfunc __CTOR_END__[];
+
+void
+cyg_hal_invoke_constructors(void)
+{
+#ifdef CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG
+    static pfunc *p = &__CTOR_END__[-1];
+    
+    cyg_hal_stop_constructors = 0;
+    for (; p >= __CTOR_LIST__; p--) {
+        (*p) ();
+        if (cyg_hal_stop_constructors) {
+            p--;
+            break;
+        }
+    }
+#else
+    pfunc *p;
+
+    for (p = &__CTOR_END__[-1]; p >= __CTOR_LIST__; p--)
+        (*p) ();
+#endif
+    
+} // cyg_hal_invoke_constructors()
+
+/*------------------------------------------------------------------------*/
+/* Determine the index of the ls bit of the supplied mask.                */
+
+cyg_uint32 hal_lsbit_index(cyg_uint32 mask)
+{
+    cyg_uint32 n = mask;
+
+    static const signed char tab[64] =
+    { -1, 0, 1, 12, 2, 6, 0, 13, 3, 0, 7, 0, 0, 0, 0, 14, 10,
+      4, 0, 0, 8, 0, 0, 25, 0, 0, 0, 0, 0, 21, 27 , 15, 31, 11,
+      5, 0, 0, 0, 0, 0, 9, 0, 0, 24, 0, 0 , 20, 26, 30, 0, 0, 0,
+      0, 23, 0, 19, 29, 0, 22, 18, 28, 17, 16, 0
+    };
+
+    n &= ~(n-1UL);
+    n = (n<<16)-n;
+    n = (n<<6)+n;
+    n = (n<<4)+n;
+
+    return tab[n>>26];
+}
+
+/*------------------------------------------------------------------------*/
+/* Determine the index of the ms bit of the supplied mask.                */
+
+cyg_uint32 hal_msbit_index(cyg_uint32 mask)
+{
+    cyg_uint32 x = mask;    
+    cyg_uint32 w;
+
+    /* Phase 1: make word with all ones from that one to the right */
+    x |= x >> 16;
+    x |= x >> 8;
+    x |= x >> 4;
+    x |= x >> 2;
+    x |= x >> 1;
+
+    /* Phase 2: calculate number of "1" bits in the word        */
+    w = (x & 0x55555555) + ((x >> 1) & 0x55555555);
+    w = (w & 0x33333333) + ((w >> 2) & 0x33333333);
+    w = w + (w >> 4);
+    w = (w & 0x000F000F) + ((w >> 8) & 0x000F000F);
+    return (cyg_uint32)((w + (w >> 16)) & 0xFF) - 1;
+
+}
+
+/*------------------------------------------------------------------------*/
+/* Delay for some number of useconds.                                     */
+void 
+hal_delay_us(int us)
+{
+    cyg_uint32 val1, val2;
+    int diff;
+    long usticks;
+    long ticks;
+
+    // Calculate the number of counter register ticks per microsecond.
+    
+    usticks = (CYGNUM_HAL_RTC_PERIOD * CYGNUM_HAL_RTC_DENOMINATOR) / 1000000;
+
+    // Make sure that the value is not zero.
+    if( usticks == 0 ) usticks = 1;
+    
+    while( us > 0 )
+    {
+        int us1 = us;
+
+        // Wait in bursts of less than 10000us to avoid any overflow
+        // problems in the multiply.
+        if( us1 > 10000 )
+            us1 = 10000;
+
+        us -= us1;
+
+        ticks = us1 * usticks;
+
+        HAL_CLOCK_READ(&val1);
+        while (ticks > 0) {
+            do {
+                HAL_CLOCK_READ(&val2);
+            } while (val1 == val2);
+            diff = val2 - val1;
+            if (diff < 0) diff += CYGNUM_HAL_RTC_PERIOD;
+            ticks -= diff;
+            val1 = val2;
+        }
+    }
+}
+
+/*------------------------------------------------------------------------*/
+
+void hal_arch_program_new_stack(void *_func)
+{
+    externC void hal_program_new_stack( void *func, CYG_ADDRESS addr);
+    hal_program_new_stack( (void *)_func,
+                   (CYGMEM_REGION_ram + CYGMEM_REGION_ram_SIZE - sizeof(CYG_ADDRESS)) & ~7 );
+}
+
+/*------------------------------------------------------------------------*/
+/* Idle thread action                                                     */
+
+#include <cyg/infra/diag.h>
+
+void hal_idle_thread_action( cyg_uint32 count )
+{
+}
+
+/*------------------------------------------------------------------------*/
+/* End of hal_misc.c                                                      */
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc.ld ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc.ld
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc.ld	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc.ld	2010-02-17 12:34:39.947560200 -0800
@@ -0,0 +1,177 @@
+//==========================================================================
+//
+//      openrisc.ld
+//
+//      Linker script for OpenRISC architecture
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   sfurman
+// Contributors:jskov
+// Date:        2002-02-28
+// Purpose:     OpenRISC Linker script
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+STARTUP(vectors.o)
+ENTRY(__exception_reset)
+#ifdef EXTRAS
+INPUT(extras.o)
+#endif
+GROUP(libtarget.a libgcc.a)
+
+#define ALIGN_LMA 8
+#define FOLLOWING(_section_) AT ((LOADADDR (_section_) + SIZEOF (_section_) + ALIGN_LMA - 1) & ~ (ALIGN_LMA - 1))
+#define LMA_EQ_VMA
+#define FORCE_OUTPUT . = .
+
+
+#define SECTIONS_BEGIN
+
+#define SECTION_vectors(_region_, _vma_, _lma_)        \
+  .vectors _vma_ : _lma_                                              \
+  { FORCE_OUTPUT; KEEP(*(.vectors)) }         \
+  > _region_
+
+// Code that might be executed out of either RAM or ROM
+#define SECTION_text(_region_, _vma_, _lma_)           \
+  .text _vma_ : _lma_                                                 \
+  { __stext = .;       \
+    *(.text*) *(.gnu.warning) *(.gnu.linkonce*) *(.init) }      \
+  > _region_                                                    \
+  __etext = .;  PROVIDE (etext = .);
+
+// The .text.ram section is for performance-sensitive code that is
+// always executed from RAM.  (If the code is loaded into ROM, it will
+// be copied into RAM prior to execution.)
+//
+// Note: The SECTION_text_ram() macro must be listed in the linker
+// include script (*.ldi file) prior to SECTION_text().
+//
+// All eCos code is put in the .text section unless explicitly placed
+// into a section named section .text.ram*.
+
+#define SECTION_text_ram(_region_, _vma_, _lma_)           \
+  .text.ram _vma_ : _lma_                                  \
+  { __stext_ram = .;                                       \
+    __ram_text_start = ABSOLUTE(.);                        \
+    *(.text.ram*)                                          \
+  } > _region_                                             \
+  __load_addr_text_ram = LOADADDR(.text.ram);              \
+  __ram_text_end = .; PROVIDE(__ram_text_end = .);         \
+  __etext_ram = .;  PROVIDE (etext_ram = .);
+
+#define SECTION_fini(_region_, _vma_, _lma_)   \
+    .fini _vma_ : _lma_                                       \
+    { FORCE_OUTPUT; *(.fini) }        \
+    > _region_
+
+#define SECTION_rodata1(_region_, _vma_, _lma_)        \
+    .rodata1 _vma_ : _lma_                                            \
+    { FORCE_OUTPUT; *(.rodata1*) }             \
+    > _region_
+
+#define SECTION_rodata(_region_, _vma_, _lma_) \
+    .rodata _vma_ : _lma_                                     \
+    { FORCE_OUTPUT; *(.rodata*) }     \
+    > _region_
+
+#define SECTION_fixup(_region_, _vma_, _lma_)                      \
+    .fixup _vma_ : _lma_                                                          \
+    { __FIXUP_START__ = ABSOLUTE(.); *(.fixup) __FIXUP_END__ = ABSOLUTE(.);}\
+    > _region_
+
+#define SECTION_gcc_except_table(_region_, _vma_, _lma_)       \
+    .gcc_except_table _vma_ : _lma_                                           \
+    { __EXCEPT_START__ = ABSOLUTE(.); *(.gcc_except_table)              \
+      __EXCEPT_END__ = ABSOLUTE(.);}                                    \
+    > _region_
+
+#define SECTION_data(_region_, _vma_, _lma_)                         \
+    .data _vma_ : _lma_                                                             \
+    { __ram_data_start = ABSOLUTE(.); *(.data*)                                 \
+    __GOT1_START__ = ABSOLUTE(.); *(.got1) __GOT1_END__ = ABSOLUTE(.);        \
+      /* Put .ctors and .dtors next to the .got2 section, so that */          \
+      /* the pointers get relocated with -mrelocatable.           */          \
+     . = ALIGN(8); ___CTOR_LIST__ = ABSOLUTE(.);                               \
+      KEEP(*(SORT(.ctors*))) ___CTOR_END__ = ABSOLUTE(.);                      \
+    ___DTOR_LIST__ = ABSOLUTE(.);                                              \
+      KEEP(*(SORT(.dtors*))) ___DTOR_END__ = ABSOLUTE(.);                      \
+      . = ALIGN(8);                                                           \
+      KEEP(*( SORT (.ecos.table.*))) ;                                        \
+      . = ALIGN(4);                                                           \
+      *( .2ram.*) ;                                                           \
+    __GOT2_START__ = ABSOLUTE(.); *(.got2) __GOT2_END__ = ABSOLUTE(.);        \
+    __GOT_START = ABSOLUTE(.); _GLOBAL_OFFSET_TABLE_ = ABSOLUTE(. + 32768);   \
+    _SDA_BASE_ = ABSOLUTE(.); *(.got.plt) *(.got)                             \
+    __GOT_END__ = ABSOLUTE(.);  *(.dynamic)                                   \
+      /* We want the small data sections together, so single-instruction */   \
+      /* offsets can access them all, and initialized data all before    */   \
+      /* uninitialized, so we can shorten the on-disk segment size.      */   \
+    __SDATA_START__ = ABSOLUTE(.); *(.sdata) *(.sdata.*)                      \
+    __SDATA2_START__ = ABSOLUTE(.); *(.sdata2*) }                             \
+    > _region_                                                                \
+    __rom_data_start = LOADADDR(.data);                                       \
+    __ram_data_end = .; PROVIDE(__ram_data_end = .);                          \
+    _edata = .; PROVIDE (edata = .);
+
+#define SECTION_sbss(_region_, _vma_, _lma_)                     \
+    .sbss _vma_ : _lma_                                                         \
+    { __sbss_start = ABSOLUTE (.);                                        \
+    __SBSS_START__ = ABSOLUTE(.); *(.sbss.*) __SBSS_END__ = ABSOLUTE(.);   \
+    __SBSSx_START__ = ABSOLUTE(.); *(.sbss*) __SBSSx_END__ = ABSOLUTE(.);\
+    *(.scommon*)                                                          \
+    __sbss_end = ABSOLUTE (.); }                                          \
+    > _region_
+
+#define SECTION_bss(_region_, _vma_, _lma_)                      \
+    .bss _vma_ : _lma_                                                          \
+    { __bss_start = ABSOLUTE (.);                       \
+      FORCE_OUTPUT; *(.dynbss*) *(.bss*) *(COMMON)      \
+      __bss_end = ABSOLUTE (.); }                       \
+    > _region_
+
+#define SECTIONS_END . = ALIGN(4); _end = .; PROVIDE (end = .);
+
+#include <pkgconf/system.h>
+#include CYGHWR_MEMORY_LAYOUT_LDI
+
+// Define VSR and virtual tables to reside at fixed addresses.
+#include CYGBLD_HAL_TARGET_H
+_hal_vsr_table = CYGHWR_HAL_VSR_TABLE;
+_hal_virtual_vector_table = CYGHWR_HAL_VIRTUAL_VECTOR_TABLE;
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc_stub.c ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc_stub.c
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc_stub.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/openrisc_stub.c	2009-09-16 14:06:26.000000000 -0700
@@ -0,0 +1,298 @@
+//========================================================================
+//
+//      openrisc_stub.c
+//
+//      OpenRISC-specific code for remote debugging via gdb
+//
+//========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):     sfurman
+// Contributors:  Red Hat, jskov, gthomas
+// Date:          2003-02-07
+// Purpose:       
+// Description:   Helper functions for gdb stub for OpenRISC processors
+// Usage:         
+//
+//####DESCRIPTIONEND####
+//
+//========================================================================
+
+#include <stddef.h>
+
+#include <pkgconf/hal.h>
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+
+#define CYGARC_HAL_COMMON_EXPORT_CPU_MACROS
+
+#include <cyg/hal/hal_stub.h>
+#include <cyg/hal/hal_arch.h>
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/openrisc_opcode.h>
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+#ifdef CYGNUM_HAL_NO_VECTOR_TRACE
+#define USE_BREAKPOINTS_FOR_SINGLE_STEP
+#endif
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+#include <cyg/hal/dbg-threads-api.h>    // dbg_currthread_id
+#endif
+
+/* Given a trap value TRAP, return the corresponding signal. */
+
+int __computeSignal (unsigned int trap_number)
+{
+    switch (trap_number)
+    {
+        // Either no matching page-table entry or protection fault
+        // while executing load/store operation
+    case CYGNUM_HAL_VECTOR_DATA_PAGE_FAULT:
+        // Either no matching page-table entry or protection fault
+        // while executing load/store operation
+    case CYGNUM_HAL_VECTOR_INSTR_PAGE_FAULT:
+        return SIGSEGV;
+      
+        // No matching entry in D-TLB
+    case CYGNUM_HAL_VECTOR_DTLB_MISS:
+        // No matching entry in I-TLB
+    case CYGNUM_HAL_VECTOR_ITLB_MISS:
+        // Unaligned load/store memory access
+    case CYGNUM_HAL_VECTOR_UNALIGNED_ACCESS:
+        // Access to non-existent physical memory/device
+    case CYGNUM_HAL_VECTOR_BUS_ERROR:
+        return SIGBUS;
+
+        // TRAP instruction executed
+    case CYGNUM_HAL_VECTOR_TRAP:
+        return SIGTRAP;
+
+        /* System call instruction executed */
+    case CYGNUM_HAL_VECTOR_SYSTEM_CALL:
+        return SIGSYS;
+
+        /* Tick timer interrupt fired */
+    case CYGNUM_HAL_VECTOR_TICK_TIMER:
+        return SIGALRM;
+
+        /* External interrupt */
+    case CYGNUM_HAL_VECTOR_INTERRUPT:
+      return SIGINT;
+
+      // Illegal or reserved instruction
+    case CYGNUM_HAL_VECTOR_RESERVED_INSTRUCTION:
+        return SIGILL;
+
+        // Numeric overflow, etc.
+    case CYGNUM_HAL_VECTOR_RANGE:
+        return SIGFPE;
+
+    default:
+        return SIGTERM;
+    }
+}
+
+
+/* Return the trap number corresponding to the last-taken trap. */
+
+int __get_trap_number (void)
+{
+    // The vector is not not part of the GDB register set so get it
+    // directly from the save context.
+    return _hal_registers->vector;
+}
+
+/* Set the currently-saved pc register value to PC. This also updates NPC
+   as needed. */
+
+void set_pc (target_register_t pc)
+{
+    put_register (PC, pc);
+}
+
+
+
+/*----------------------------------------------------------------------
+ * Single-step support
+ */
+
+// Type of a single OpenRISC instruction
+typedef cyg_uint32 t_inst;
+
+/* Saved instruction data for single step support.  */
+static struct
+{
+  t_inst *targetAddr;
+  t_inst savedInstr;
+} instrBuffer;
+
+
+/* Set things up so that the next user resume will execute one instruction.
+   This may be done by setting breakpoints or setting a single step flag
+   in the saved user registers, for example. */
+
+void __single_step (void)
+{
+  t_inst *pc = (t_inst *) get_register (PC);
+  t_inst *targetAddr;
+  InstFmt insn;
+  int flag;
+
+  targetAddr = pc + 1;              /* set default */
+
+  insn.word = *pc;
+  switch (insn.JType.op) {
+  case OP_J:
+  case OP_JAL:
+    targetAddr = pc + insn.JType.target;
+    break;
+
+  case OP_BNF:
+    flag = get_register(SR) & SPR_SR_F;
+    if (!flag)
+      targetAddr = pc + insn.JType.target;
+    break;
+
+  case OP_BF:
+    flag = get_register(SR) & SPR_SR_F;
+    if (flag)
+      targetAddr = pc + insn.JType.target;
+    break;
+
+  case OP_JR:
+  case OP_JALR:
+    targetAddr = (t_inst*)get_register(insn.JRType.rB);
+    break;
+
+    /* We don't step into interrupts, syscalls or traps */
+  default:
+    break;
+  }
+
+  instrBuffer.targetAddr = targetAddr;
+  instrBuffer.savedInstr = *targetAddr;
+  *targetAddr = __break_opcode ();
+
+  // No need to flush caches; Generic stub code will handle this.
+}
+  
+/* Clear the single-step state. */
+void __clear_single_step (void)
+{
+  if (instrBuffer.targetAddr != NULL)
+    {
+      *instrBuffer.targetAddr = instrBuffer.savedInstr;
+      instrBuffer.targetAddr = NULL;
+      instrBuffer.savedInstr = 0;
+    }
+}
+
+
+void __install_breakpoints ()
+{
+  /*  if (instrBuffer.targetAddr != NULL)
+    {
+      instrBuffer.savedInstr = *instrBuffer.targetAddr;
+      *instrBuffer.targetAddr = __break_opcode ();
+      } */
+
+  /* Install the breakpoints in the breakpoint list */
+  __install_breakpoint_list();
+
+  // No need to flush caches here; Generic stub code will handle this.
+}
+
+void __clear_breakpoints (void)
+{
+  __clear_breakpoint_list();
+}
+
+/* If the breakpoint we hit is in the breakpoint() instruction, return a
+   non-zero value. */
+
+int
+__is_breakpoint_function ()
+{
+    return get_register (PC) == (target_register_t)&_breakinst;
+}
+
+
+/* Skip the current instruction.  Since this is only called by the
+   stub when the PC points to a breakpoint or trap instruction,
+   we can safely just skip 4. */
+
+void __skipinst (void)
+{
+    put_register (PC, get_register (PC) + 4);
+}
+
+target_register_t 
+get_register (regnames_t reg)
+{
+    GDB_Registers* gdb_regs;
+
+    gdb_regs = (GDB_Registers*)_registers;
+
+    if (reg >= R0 && reg <= R31)
+        return gdb_regs->r[reg];
+    if (reg == PC)
+        return gdb_regs->pc;
+    if (reg == SR)
+        return gdb_regs->sr;
+    return 0xdeadbeef;
+}
+
+void 
+put_register (regnames_t reg, target_register_t value)
+{
+    GDB_Registers* gdb_regs;
+
+    gdb_regs = (GDB_Registers*)_registers;
+
+    if (reg >= R0 && reg <= R31) {
+        gdb_regs->r[reg] = value;
+    } else if (reg == PC) {
+        gdb_regs->pc = value;
+    } else if (reg == SR) {
+        gdb_regs->sr = value;
+    } else {
+        CYG_FAIL("Attempt to write to non-existent register ");
+    }
+}
+
+#endif // CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/vectors.S ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/vectors.S
--- /opt/ecos-3.0/packages/hal/openrisc/arch/v3_0/src/vectors.S	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/arch/v3_0/src/vectors.S	2010-02-17 12:38:23.429074600 -0800
@@ -0,0 +1,859 @@
+##==========================================================================
+##
+##      Vectors.S
+##
+##      OpenRISC exception vectors, interrupt-handling, reset and
+##        platform-indepent initialization
+##
+##==========================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+##==========================================================================
+#######DESCRIPTIONBEGIN####
+##
+## Author(s):    sfurman
+## Contributors: 
+## Date:         2003-01-20
+## Purpose:      OpenRISC interrupts, exception vectors and reset
+## Description:  This file defines the code placed into the exception
+##               vectors. It also contains the first level default VSRs
+##               that save and restore state for both exceptions and
+##               interrupts.
+##
+######DESCRIPTIONEND####
+##
+##==========================================================================
+
+#include <pkgconf/hal.h>
+
+#ifdef CYGPKG_KERNEL
+#include <pkgconf/kernel.h>     // CYGPKG_KERNEL_INSTRUMENT
+#endif
+
+#include <cyg/hal/hal_intr.h>
+#include <cyg/hal/hal_cache.h>
+
+#===========================================================================
+                
+        
+        .extern _hal_vsr_table
+
+        .extern _cyg_hal_invoke_constructors
+        .extern _cyg_instrument
+        .extern _cyg_start
+        .extern _hal_IRQ_init
+        .extern _hal_platform_init
+        .extern _initialize_stub
+
+        .extern __bss_start
+        .extern __bss_end
+        .extern __sbss_start
+        .extern __sbss_end
+
+# Include variant macros after MSR definition.        
+#include <cyg/hal/arch.inc>
+#include <cyg/hal/openrisc.inc>
+
+
+#===========================================================================
+# Start by defining the exceptions vectors that must be placed in low
+# memory, starting at location 0x000.
+        
+        .section ".vectors","ax"
+
+#---------------------------------------------------------------------------
+# Macros for generating an exception vector service routine
+
+# dummy Macros for the first 0x100 bytes
+        .macro  dummy_vector name org
+        .p2align 8
+        .globl  __exception_\name
+__exception_\name:
+        l.nop
+        l.nop
+        l.nop
+        .endm
+
+# Reset vector macro
+
+        .macro  reset_vector name org
+        .p2align 8
+        .globl  __exception_\name
+__exception_\name:
+        load32i r3,_start
+        l.jr    r3
+        l.nop           # delay slot
+        .endm
+        
+# Generic vector macro
+                
+        .macro  exception_vector name org
+        .p2align 8
+        .globl  __exception_\name
+__exception_\name:
+        l.addi  sp,sp,-SIZEOF_OR1KREGS  # space for registers
+
+        # Store General Purpose Registers (GPRs).
+
+        l.sw     3 * OR1K_GPRSIZE(sp), r3
+        l.sw     4 * OR1K_GPRSIZE(sp), r4
+        l.sw     5 * OR1K_GPRSIZE(sp), r5
+        l.sw     6 * OR1K_GPRSIZE(sp), r6
+        l.sw     7 * OR1K_GPRSIZE(sp), r7
+        l.sw     8 * OR1K_GPRSIZE(sp), r8
+        l.sw     9 * OR1K_GPRSIZE(sp), r9
+        l.sw    11 * OR1K_GPRSIZE(sp), r11
+        l.sw    13 * OR1K_GPRSIZE(sp), r13
+        l.sw    15 * OR1K_GPRSIZE(sp), r15
+        l.sw    17 * OR1K_GPRSIZE(sp), r17
+        l.sw    19 * OR1K_GPRSIZE(sp), r19
+        l.sw    21 * OR1K_GPRSIZE(sp), r21
+        l.sw    23 * OR1K_GPRSIZE(sp), r23
+        l.sw    25 * OR1K_GPRSIZE(sp), r25
+        l.sw    27 * OR1K_GPRSIZE(sp), r27
+        l.sw    29 * OR1K_GPRSIZE(sp), r29
+        l.sw    31 * OR1K_GPRSIZE(sp), r31
+
+
+#ifndef CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+
+        # R0 is not typically stored because it is always zero-valued,
+        # but we store it here for consistency when examining registers
+        # in the debugger.
+        l.sw     0 * OR1K_GPRSIZE(sp), r0
+
+        # Callee-saved regs don't need to be preserved across a call into
+        # an ISR, but we can do so to make debugging easier.
+        l.sw     2 * OR1K_GPRSIZE(sp), r2
+        l.sw    10 * OR1K_GPRSIZE(sp), r10
+        l.sw    12 * OR1K_GPRSIZE(sp), r12
+        l.sw    14 * OR1K_GPRSIZE(sp), r14
+        l.sw    16 * OR1K_GPRSIZE(sp), r16
+        l.sw    18 * OR1K_GPRSIZE(sp), r18
+        l.sw    20 * OR1K_GPRSIZE(sp), r20
+        l.sw    22 * OR1K_GPRSIZE(sp), r22
+        l.sw    24 * OR1K_GPRSIZE(sp), r24
+        l.sw    26 * OR1K_GPRSIZE(sp), r26
+        l.sw    28 * OR1K_GPRSIZE(sp), r28
+        l.sw    30 * OR1K_GPRSIZE(sp), r30
+
+	# save MAC LO and HI regs
+        l.mfspr r5,r0,SPR_MACLO
+        l.sw    OR1KREG_MACLO(sp),r5
+        l.mfspr r5,r0,SPR_MACHI
+        l.sw    OR1KREG_MACHI(sp),r5
+#endif
+        
+        # Save SP of interruptee in reg dump
+        l.addi  r5,sp,SIZEOF_OR1KREGS
+        l.sw     1 * OR1K_GPRSIZE(sp),r5
+
+        # ...and the PC
+        l.mfspr r5,r0,SPR_EPCR_BASE
+        l.sw    OR1KREG_PC(sp),r5
+
+        # ... and the Supervisor Register
+        l.mfspr r5,r0,SPR_ESR_BASE
+        l.sw    OR1KREG_SR(sp),r5
+
+        # ... and the exception's effective address, if there is one.
+        # FIXME - don't need to do this for some exceptions
+        l.mfspr r5,r0,SPR_EEAR_BASE
+        l.sw    OR1KREG_EEAR(sp),r5
+
+        # Second arg to VSR is exception number
+        # First vector is located at 0x100, second at 0x200, etc.
+        # Shift right to get vector number for address lookup.
+        l.ori   r4,r0,(\org>>8)
+        l.sw    OR1KREG_VECTOR(sp),r4
+
+        # Lookup address of VSR in table and jump to it
+        #   Arg 0: Pointer to HAL_SavedRegisters struct
+        #   Arg 1: Vector #
+        load32i r5,_hal_vsr_table+(\org>>6)
+        l.lwz   r5,0(r5)
+        l.jr    r5                           # To the VSR, Batman
+
+        # First arg to VSR is SP
+        l.or    r3,r0,sp                     # Delay slot
+        
+        .endm
+        
+#---------------------------------------------------------------------------
+# Define the exception vectors.
+
+rom_vectors:
+        # These are the architecture-defined vectors that
+        # are always present. 
+
+        dummy_vector            dummy                   0x000
+        reset_vector            reset                   0x100
+        exception_vector        bus_error               0x200
+        exception_vector        data_page_fault         0x300
+        exception_vector        instruction_page_fault  0x400
+        exception_vector        tick_timer              0x500
+        exception_vector        unaligned_access        0x600
+        exception_vector        illegal_instruction     0x700
+        exception_vector        external_interrupt      0x800
+        exception_vector        dtlb_miss               0x900
+        exception_vector        itlb_miss               0xa00
+        exception_vector        range                   0xb00
+        exception_vector        syscall                 0xc00
+        exception_vector        reserved                0xd00
+        exception_vector        trap                    0xe00
+
+rom_vectors_end:   
+
+
+#if     defined(CYG_HAL_STARTUP_ROM) ||                 \
+        (       defined(CYG_HAL_STARTUP_RAM) &&         \
+                !defined(CYGSEM_HAL_USE_ROM_MONITOR))
+
+        .macro  hal_vsr_table_init
+
+        # Next initialize the VSR table. This happens whether the
+        # vectors were copied to RAM or not.
+
+        # First fill with exception handlers
+        load32i r3,_cyg_hal_default_exception_vsr
+        load32i r4,_hal_vsr_table+4  # First entry in table is unused
+        l.ori   r5,r0,CYGNUM_HAL_VSR_COUNT
+1:      l.sw    0(r4),r3
+        l.addi  r5,r5,-1
+        l.sfgtsi r5,0
+        l.bf    1b
+        l.addi  r4,r4,4         # delay slot
+
+        # Then fill in the interrupt handlers
+        load32i r4,_hal_vsr_table
+        load32i r3,_cyg_hal_default_interrupt_vsr
+        l.sw    CYGNUM_HAL_VECTOR_INTERRUPT*4(r4),r3
+        l.sw    CYGNUM_HAL_VECTOR_TICK_TIMER*4(r4),r3
+        .endm
+
+#elif defined(CYG_HAL_STARTUP_RAM) && defined(CYGSEM_HAL_USE_ROM_MONITOR)
+
+        # Initialize the VSR table entries
+        # We only take control of the interrupt vectors,
+        # the rest are left to the ROM for now...
+
+        .macro  hal_vsr_table_init
+        load32i r4,_hal_vsr_table
+        load32i r3,_cyg_hal_default_interrupt_vsr
+        l.sw    CYGNUM_HAL_VECTOR_INTERRUPT*4(r4),r3
+        l.sw    CYGNUM_HAL_VECTOR_TICK_TIMER*4(r4),r3
+        .endm
+
+
+#else
+
+#error "Need to define hal_vsr_table_init"
+
+#endif
+
+# I-Cache initialization macro
+        .macro  hal_icache_init
+        /* Disable I-Cache */
+        l.mfspr r13,r0,SPR_SR
+        l.addi  r11,r0,-1
+        l.xori  r11,r11,SPR_SR_ICE
+        l.and   r11,r13,r11
+        l.mtspr r0,r11,SPR_SR
+      
+        /* Invalidate I-Cache */
+        l.addi  r13,r0,0
+        l.addi  r11,r0,HAL_ICACHE_SIZE
+1:
+        l.mtspr r0,r13,SPR_ICBIR
+        l.sfne  r13,r11
+        l.bf    1b
+        l.addi  r13,r13,HAL_ICACHE_LINE_SIZE
+        
+        /* Enable I-Cache */
+        l.mfspr r13,r0,SPR_SR
+        l.ori   r13,r13,SPR_SR_ICE
+        l.mtspr r0,r13,SPR_SR
+
+        /* Flush instructions out of instruction buffer */
+        l.nop
+        l.nop
+        l.nop
+        l.nop
+        l.nop
+        .endm
+        
+# D-Cache initialization macro
+        .macro  hal_dcache_init
+
+        /* Flush DC */
+        l.addi  r10,r0,0
+        l.addi  r11,r0,HAL_DCACHE_SIZE
+1:
+        l.mtspr r0,r10,SPR_DCBIR
+        l.sfne  r10,r11
+        l.bf    1b
+        l.addi  r10,r10,HAL_DCACHE_LINE_SIZE
+
+        /* Enable DC */
+        l.mfspr r10,r0,SPR_SR
+        l.ori   r10,r10,SPR_SR_DCE
+        l.mtspr r0,r10,SPR_SR
+        .endm
+        
+#===========================================================================
+# Startup code:  We jump here from the reset vector to set up the world.
+        
+        .text   
+
+FUNC_START(start)
+
+        # Initialize Supervision Register:
+        #   Supervisor mode on, all interrupts off, caches off
+        #
+        # (If we've entered here from a hardware reset, then the SR is already
+        # set to this value, but we may have jumped here as part of a soft
+        # system reset.)
+        l.ori   r3,r0,SPR_SR_SM
+        l.mtspr r0,r3,SPR_SR
+        
+        # Run platform-specific hardware initialization code.
+        # This may include memory controller initialization.
+        # Hence, it is not safe to access RAM until after this point.
+        hal_hardware_init 
+
+#ifdef CYGSEM_HAL_ENABLE_ICACHE_ON_STARTUP
+        # Enable I-Cache
+        hal_icache_init
+#endif
+
+#ifdef CYGSEM_HAL_ENABLE_DCACHE_ON_STARTUP
+        # Enable D-Cache
+        hal_dcache_init
+#endif
+
+	# Start the tick timer, in case timer polling routine hal_delay_us() is called.
+	# Initially, no interrupts are generated by the tick timer.  Later on, that
+	# may change when the kernel is initialized.
+	l.movhi	r3, hi(0x40000000|CYGNUM_HAL_RTC_PERIOD)
+	l.mtspr	r0,r3, SPR_TTMR
+        
+        .globl  _hal_hardware_init_done
+_hal_hardware_init_done:                
+
+        # set up stack
+        load32i sp,__interrupt_stack
+
+        # Make a dummy frame on the stack, so that stack backtraces are sane
+        # for debugging.  On return from that function, the restore_state()
+        # function is called to resume the interrupted thread.
+        l.addi  sp,sp,-8
+        l.sw    4(sp),r0        # Dummy saved FP
+        l.sw    0(sp),r0        # Dummy saved LR
+        
+        # Set up exception handlers and VSR table, taking care not to
+        # step on any ROM monitor VSRs.
+        hal_vsr_table_init        
+
+#if defined(CYG_HAL_STARTUP_ROM)
+        # Copy exception/interrupt vectors from ROM to address 0x100
+        load32i r4,0x100
+        load32i r3,rom_vectors
+        load32i r5,rom_vectors_end
+1:      l.sfeq  r3,r5
+        l.bf    2f
+        l.lwz   r6,0(r3)
+        l.sw    0(r4),r6
+        l.addi  r3,r3,4
+        l.j     1b
+        l.addi  r4,r4,4         # delay slot
+2:
+
+        # Copy .data section into RAM
+        load32i r3,__rom_data_start
+        load32i r4,__ram_data_start
+        load32i r5,__ram_data_end
+1:      l.sfeq  r4,r5
+        l.bf    2f
+        l.lwz   r6,0(r3)
+        l.sw    0(r4),r6
+        l.addi  r3,r3,4
+        l.j     1b
+        l.addi  r4,r4,4         # delay slot
+2:
+
+#endif
+
+        # clear BSS
+        load32i r4,__bss_start
+        load32i r5,__bss_end
+1:      l.sfeq  r4,r5
+        l.bf    2f
+        l.nop
+        l.sw    0(r4),r0
+        l.j     1b
+        l.addi  r4,r4,4
+2:
+
+        # Note:  no SBSS section to clear with OpenRISC target
+        
+        # Platform-specific initialization
+        l.jal   _hal_platform_init
+        l.nop   # delay slot
+        
+        # call c++ constructors
+        l.jal   _cyg_hal_invoke_constructors
+        l.nop   # delay slot
+        
+# pause sim 
+load32i r3,0x5ffffffc
+load32i r5,0xcea5e0ff
+l.sw    (0)(r3),r5
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        l.jal   _initialize_stub
+        l.nop   # delay slot
+#endif
+
+#if defined(CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT) \
+    || defined(CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT)
+        .extern _hal_ctrlc_isr_init
+        l.jal   _hal_ctrlc_isr_init
+        l.nop   # delay slot
+#endif
+
+# pause sim 
+load32i r3,0x5ffffffc
+load32i r5,0xcea5e0ff
+l.sw    (0)(r3),r5
+        
+        l.jal   _cyg_start       # call cyg_start()
+        l.nop   # delay slot
+9:      
+        l.j     9b              # if we return, loop
+
+FUNC_END(start)
+        
+#---------------------------------------------------------------------------
+# This code handles the common part of all exception handlers.
+# On entry, the machine state is already saved on the stack.
+#
+# R3 = pointer to HAL_SavedRegisters struct containing saved machine state
+# R4 = Vector number
+#       
+# It calls a C routine to do any work, which may result in
+# thread switches and changes to the saved state. When we return
+# here, the saved state is restored and execution is continued.
+        
+        .text
+
+FUNC_START(cyg_hal_default_exception_vsr)
+
+        .extern _cyg_hal_exception_handler
+
+        # Call C code
+
+        # When cyg_hal_exception_handler() returns, it will jump
+	# directly to restore_state(), which will resume execution
+	# at the location of the exception.
+        l.movhi r9, hi(restore_state)
+        l.j     _cyg_hal_exception_handler
+        l.ori   r9,r9,lo(restore_state) #Delay slot
+
+        # Control never reaches this point, 
+
+FUNC_END(cyg_hal_default_exception_vsr)
+
+#---------------------------------------------------------------------------
+# This code handles all interrupts and dispatches to a C ISR function
+# On entry, the machine state is already saved on the stack.
+#
+# R3 = pointer to HAL_SavedRegisters struct containing saved machine state
+# R4 = Vector number
+#       
+# After we return here, the saved state is restored and execution is continued.
+        
+#ifdef CYGIMP_FORCE_INTERRUPT_HANDLING_CODE_IN_RAM
+	.section .text.ram,"ax"
+#else
+	.section .text,"ax"
+#endif
+	
+FUNC_START(cyg_hal_default_interrupt_vsr)
+
+        # Stash away pointer to saved regs for later
+        l.or    r31,r3,r3
+        
+        # Set scheduler lock to prevent thread rescheduling while the ISR runs
+#ifdef CYGFUN_HAL_COMMON_KERNEL_SUPPORT                 
+        .extern _cyg_scheduler_sched_lock
+        load32i r5, _cyg_scheduler_sched_lock
+        l.lwz   r6,0(r5)
+        l.addi  r6,r6,1
+        l.sw    0(r5),r6
+#endif
+        
+#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
+        # Interrupts execute on their own dedicated stack.
+        # If we're on a thread stack, switch to the interrupt stack.
+        # If we're called inside a nested interrupt, do nothing.
+        l.or    r6,sp,sp                        # Stash SP for later
+        load32i r7,__interrupt_stack            # stack top (highest addr + 1)
+        load32i r8,__interrupt_stack_base       # stack base (lowest addr)
+        l.sfltu sp,r8                           # if (sp < __interrupt_stack_base) 
+        l.bf    1f                              #    switch to interrupt stack
+        l.sfltu sp,r7                           # if (sp < __interrupt_stack_top)
+        l.bf   2f                               #    already on interrupt stack
+        l.nop                                   # delay slot
+1:      l.or    sp,r7,r7                        # Switch to interrupt stack
+2:      l.addi  sp,sp,-8                        # Make space to save old SP...
+        l.sw    0(sp),r6                        # ...and save it on the stack           
+#endif
+
+        # Call C code
+
+#if defined(CYGPKG_KERNEL_INSTRUMENT) && defined(CYGDBG_KERNEL_INSTRUMENT_INTR)
+        # Log the interrupt if kernel tracing is enabled
+        l.ori   r3,r0,0x0301                    # arg1 = type = INTR,RAISE
+                                                # arg2 = vector number
+        l.ori   r5,r0,r0                        # arg3 = 0
+        l.jal   _cyg_instrument                  # call instrument function
+        
+#endif
+
+#if defined(CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT) \
+    || defined(CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT)
+        # If we are supporting Ctrl-C interrupts from GDB, we must squirrel
+        # away a pointer to the save interrupt state here so that we can
+        # plant a breakpoint at some later time.
+        
+        .extern _hal_saved_interrupt_state
+        load32i r8,_hal_saved_interrupt_state
+        l.sw    0(r8),r31
+        
+#endif
+
+        # In the event of multiple pending interrupts, determine which
+        # one will be serviced first.  By software convention, the lowest
+        # numbered external interrupt gets priority.
+        #
+        # The (internal) tick timer interrupt is serviced only if no
+        # external interrupts are pending.
+
+        # Read the PIC interrupt controller's status register
+        l.mfspr r9,r0,SPR_PICSR
+
+        # Any pending external interrupts ?
+        l.sfnei r9,0
+        l.bf    check_for_external_interrupts
+
+        # Theoretically, the only way we could get here is if the tick timer
+        # interrupt fired, but we check to be sure that's what happened.
+        l.sfeqi r4,CYGNUM_HAL_VECTOR_TICK_TIMER
+        l.bf    3f
+        l.ori   r3,r0,CYGNUM_HAL_INTERRUPT_RTC  # delay slot
+        
+#ifndef CYGIMP_HAL_COMMON_INTERRUPTS_IGNORE_SPURIOUS
+        l.jal   _hal_spurious_IRQ
+        l.nop
+#endif // CYGIMP_HAL_COMMON_INTERRUPTS_IGNORE_SPURIOUS
+        l.j     ignore_spurious_interrupt
+        
+        # Identify the lowest numbered interrupt bit in the PIC's PSR,
+        # numbering the MSB as 31 and the LSB as 0
+check_for_external_interrupts:  
+        l.ori   r3,r0,0
+2:      l.andi  r11,r9,1                        # Test low bit
+        l.sfnei r11,0
+        l.bf    3f
+        l.srli  r9,r9,1                         # Shift right 1 bit
+        l.j     2b
+        l.addi  r3,r3,1                         # Delay slot
+3:              
+
+        # At this point, r3 contains the ISR number, from 0-32
+        # which will be used to index the table of ISRs
+        l.slli  r15,r3,2
+        load32i r9, _hal_interrupt_handlers     # get interrupt handler table
+        l.add   r9,r9,r15
+        l.lwz   r11,0(r9)                       # load ISR pointer
+        load32i r9, _hal_interrupt_data         # get interrupt data table
+        l.add   r9,r9,r15
+        l.lwz   r4,0(r9)                        # load data arg to ISR
+
+        # Call ISR
+        #   arg0 = ISR #
+        #   arg1 = data arg associated with interrupt
+        l.jalr  r11
+        l.nop
+
+ignore_spurious_interrupt:
+        
+#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
+
+        # If we are returning from the last nested interrupt, move back
+        # to the thread stack. interrupt_end() must be called on the
+        # thread stack since it potentially causes a context switch.
+        # Since we have arranged for the top of stack location to
+        # contain the sp we need to go back to here, just pop it off
+        # and put it in SP.
+
+        l.lwz   sp,0(sp)        
+#endif  
+
+#ifdef CYGFUN_HAL_COMMON_KERNEL_SUPPORT
+
+        # We only need to call _interrupt_end() when there is a kernel
+        # present to do any tidying up.
+        
+        # on return r11 bit 1 will indicate whether a DSR is
+        # to be posted. Pass this together with a pointer to
+        # the interrupt object we have just used to the
+        # interrupt tidy up routine.
+        l.or    r3,r11,r11
+
+        # Get pointer to HAL_SavedRegisters struct, stashed earlier
+        l.or    r5,r31,r31
+
+        # Get opaque object associated w/ interrupt vector
+        load32i r9, _hal_interrupt_objects          # get interrupt data table
+        l.add   r9,r9,r15
+        l.lwz   r4,0(r9)
+
+        # Call interrupt_end() to execute any pending DSRs
+        #   Arg 0 = return value from ISR
+        #   Arg 1 = object associated with interrupt
+        #   Arg 2 = HAL_SavedRegisters struct
+
+        .extern _interrupt_end
+        l.jal   _interrupt_end                   # call into C to finish off
+        l.nop
+#endif
+
+        # Fall through to restore_state...
+
+# Return from either an interrupt or an exception
+#       
+# On entry:     
+#    SP = pointer to (HAL_SavedRegisters struct)
+#
+restore_state:
+
+        # Restore General Purpose Registers (GPRs).
+        # R0 is not restored because it is always zero-valued.
+        # R1, R3, and R4 are used as temps, so they are restored a little later
+        l.lwz   r5,   5 * OR1K_GPRSIZE(sp)
+        l.lwz   r6,   6 * OR1K_GPRSIZE(sp)
+        l.lwz   r7,   7 * OR1K_GPRSIZE(sp)
+        l.lwz   r8,   8 * OR1K_GPRSIZE(sp)
+        l.lwz   r9,   9 * OR1K_GPRSIZE(sp)
+        l.lwz   r11, 11 * OR1K_GPRSIZE(sp)
+        l.lwz   r13, 13 * OR1K_GPRSIZE(sp)
+        l.lwz   r15, 15 * OR1K_GPRSIZE(sp)
+        l.lwz   r17, 17 * OR1K_GPRSIZE(sp)
+        l.lwz   r19, 19 * OR1K_GPRSIZE(sp)
+        l.lwz   r21, 21 * OR1K_GPRSIZE(sp)
+        l.lwz   r23, 23 * OR1K_GPRSIZE(sp)
+        l.lwz   r25, 25 * OR1K_GPRSIZE(sp)
+        l.lwz   r27, 27 * OR1K_GPRSIZE(sp)
+        l.lwz   r29, 29 * OR1K_GPRSIZE(sp)
+        l.lwz   r31, 31 * OR1K_GPRSIZE(sp)
+
+#ifndef CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+        # Callee-saved regs don't need to be preserved across a call into
+        # an ISR, but we can do so to make debugging easier.
+
+        l.lwz   r2,   2 * OR1K_GPRSIZE(sp)
+        l.lwz   r10, 10 * OR1K_GPRSIZE(sp)
+        l.lwz   r12, 12 * OR1K_GPRSIZE(sp)
+        l.lwz   r14, 14 * OR1K_GPRSIZE(sp)
+        l.lwz   r16, 16 * OR1K_GPRSIZE(sp)
+        l.lwz   r18, 18 * OR1K_GPRSIZE(sp)
+        l.lwz   r20, 20 * OR1K_GPRSIZE(sp)
+        l.lwz   r22, 22 * OR1K_GPRSIZE(sp)
+        l.lwz   r24, 24 * OR1K_GPRSIZE(sp)
+        l.lwz   r26, 26 * OR1K_GPRSIZE(sp)
+        l.lwz   r28, 28 * OR1K_GPRSIZE(sp)
+        l.lwz   r30, 30 * OR1K_GPRSIZE(sp)
+
+        # Restore MAC LO and HI regs
+        l.lwz   r4, OR1KREG_MACLO(sp)
+        l.mtspr r0,r4,SPR_MACLO
+        l.lwz   r4, OR1KREG_MACHI(sp)
+        l.mtspr r0,r4,SPR_MACHI
+#endif
+
+        # Must disable interrupts, since they could clobber ESR and EPC regs
+        l.mfspr r3, r0, SPR_SR
+        load32i r4,~(SPR_SR_TEE|SPR_SR_IEE)
+        l.and   r3, r4, r3
+        l.mtspr r0, r3, SPR_SR
+
+        # At this point we've restored all the pre-interrupt GPRs except for the SP.
+        # Restore pre-interrupt SR, SP, and PC
+        l.lwz    r4,  OR1KREG_SR(sp)
+        l.mtspr  r0, r4, SPR_ESR_BASE
+
+        l.lwz    r4,  OR1KREG_PC(sp)
+        l.mtspr  r0, r4, SPR_EPCR_BASE
+
+        l.lwz   r4,   4 * OR1K_GPRSIZE(sp)
+        l.lwz   r3,   3 * OR1K_GPRSIZE(sp)
+        l.lwz    sp,  1 * OR1K_GPRSIZE(sp)
+
+        # All done, restore CPU state and continue
+        l.rfe
+        l.nop           # Delay slot
+
+
+##-----------------------------------------------------------------------------
+## Execute pending DSRs on the interrupt stack with interrupts enabled.
+## Note: this can only be called from code running on a thread stack
+
+#ifdef CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK
+        .extern _cyg_interrupt_call_pending_DSRs
+
+	.text
+FUNC_START(hal_interrupt_stack_call_pending_DSRs)
+        # Switch to interrupt stack
+        l.or    r3, sp, sp      # Stash entry SP
+        load32i sp, __interrupt_stack
+        l.addi  sp, sp, -16
+        l.sw    0(sp), r3       # Save entry SP
+        l.mfspr r4,r0,SPR_SR
+        l.sw    4(sp), r4       # Save interrupt state
+        l.ori   r4, r4, SPR_SR_IEE|SPR_SR_TEE
+        l.sw    8(sp),lr
+        
+        l.jal   _cyg_interrupt_call_pending_DSRs
+	# Enable interrupts before calling DSRs
+	l.mtspr r0, r4, SPR_SR  # Delay slot
+
+        l.lwz   r4, 4(sp)
+        l.lwz   lr, 8(sp)
+        l.lwz   sp, 0(sp)
+
+        # Merge original interrupt state with (possibly altered) SR reg
+        l.andi  r4, r4, SPR_SR_IEE|SPR_SR_TEE
+        l.mfspr r5, r0, SPR_SR
+        load32i r6, ~(SPR_SR_IEE|SPR_SR_TEE)
+        l.and   r5, r5, r6
+        l.or    r4, r4, r5
+        
+        l.jr    r9
+        l.mtspr r0, r4, SPR_SR  # Delay slot
+        
+FUNC_END(hal_interrupt_stack_call_pending_DSRs)
+#endif          
+
+##-----------------------------------------------------------------------------
+## Switch to a new stack.
+## This is used in RedBoot to allow code to execute in a different
+## stack context.
+
+FUNC_START(hal_program_new_stack)
+        # Arguments are:
+        # r3 = function to call
+        # r4 = stack pointer to use
+
+        # Dummy prologue, so that debugger is fooled into thinking there
+        # is a stack frame.  The debugger will use the offsets in the prologue
+        # below to read the saved register values out of the *new* stack.
+        l.addi  sp,sp,-8
+        l.sw    0(sp),fp
+        l.addi  fp,sp,8
+        l.sw    4(sp),lr
+        
+        l.or    r5,sp,sp        # Remember original SP
+        l.addi  r6,fp,-8        # Remember original FP
+        l.or    sp,r4,r4        # Switch to new stack
+
+        # "Real prologue" - Offsets here must match dummy prologue above
+        l.addi  sp,sp,-16
+        l.sw    0(sp),r6        # So debugger can know caller's FP
+        l.sw    4(sp),lr        # So debugger can know caller's PC
+        l.sw    8(sp),r5        # Save old SP on stack
+
+        # Call function
+        l.jalr  r3
+        l.nop
+        
+        l.lwz   sp, 8(sp)       # Restore original SP
+        l.lwz   lr, 4(sp)
+        l.jr    lr              # Return to caller
+        l.addi  sp,sp, 8        # Delay slot
+        
+FUNC_END(hal_program_new_stack)
+
+#---------------------------------------------------------------------------
+## Temporary interrupt stack
+        
+        .section ".bss"
+
+        .balign 16
+        .global _cyg_interrupt_stack_base
+_cyg_interrupt_stack_base:
+__interrupt_stack_base:
+        .rept CYGNUM_HAL_COMMON_INTERRUPTS_STACK_SIZE
+        .byte 0
+        .endr
+        .balign 16
+        .global _cyg_interrupt_stack
+_cyg_interrupt_stack:
+__interrupt_stack:
+        
+        .long   0,0,0,0,0,0,0,0 
+
+#--------------------------------------
+        .data
+        .extern _hal_default_isr
+
+        .globl  _hal_interrupt_handlers
+_hal_interrupt_handlers:
+        .rept   CYGNUM_HAL_ISR_COUNT
+        .long   _hal_default_isr
+        .endr
+
+        .globl  _hal_interrupt_data
+_hal_interrupt_data:
+        .rept   CYGNUM_HAL_ISR_COUNT
+        .long   0
+        .endr
+
+        .globl  _hal_interrupt_objects
+_hal_interrupt_objects:
+        .rept   CYGNUM_HAL_ISR_COUNT
+        .long   0
+        .endr
+
+#---------------------------------------------------------------------------
+# end of vectors.S
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/ChangeLog ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/ChangeLog
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/ChangeLog	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/ChangeLog	2010-02-05 17:03:32.661243000 -0800
@@ -0,0 +1,38 @@
+
+        Initial port of eCos to OpenRISC or1200 Platform (OR1200)
+
+//===========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/cdl/hal_openrisc_or1200_soc.cdl ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/cdl/hal_openrisc_or1200_soc.cdl
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/cdl/hal_openrisc_or1200_soc.cdl	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/cdl/hal_openrisc_or1200_soc.cdl	2010-02-17 11:06:26.624690600 -0800
@@ -0,0 +1,335 @@
+# ====================================================================
+#
+#      hal_openrisc_or1200_soc.cdl
+#
+#      OpenRISC or1200 Platform (OR1200) HAL package configuration data
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      sfurman 
+# Contributors:   qaztronic
+# Date:           02-06-2010
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_HAL_OPENRISC_OR1200_SOC {
+    display  "OpenRISC Reference Platform"
+    parent        CYGPKG_HAL_OPENRISC
+    include_dir   cyg/hal
+    hardware
+    description   "
+           The or1200_soc HAL package should be used when targetting the
+           OpenRISC or1200_soc Platform."
+
+    compile       hal_diag.c hal_aux.c
+
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT
+
+    define_proc {
+        puts $::cdl_system_header "#define CYGBLD_HAL_TARGET_H   <pkgconf/hal_openrisc.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_PLATFORM_H <pkgconf/hal_openrisc_or1200_soc.h>"
+    }
+
+    cdl_component CYG_HAL_STARTUP {
+        display       "Startup type"
+        flavor        data
+        legal_values  {"RAM" "ROM"}
+        default_value {"ROM"}
+        no_define
+        define -file system.h CYG_HAL_STARTUP
+        description   "
+            Selects whether code initially runs from ROM or RAM.  In the case of ROM startup,
+            it's possible for the code to be copied into RAM and executed there."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD {
+        display       "Diagnostic serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200 230400 460800 921600
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the diagnostic console.
+            Note: this should match the value chosen for the GDB port if the
+            diagnostic and GDB port are the same.
+            Note: very high baud rates are useful during simulation."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_BAUD {
+        display       "GDB serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200 230400 460800 921600
+        default_value 115200
+        description   "
+            This option controls the baud rate used for the GDB connection.
+            Note: very high baud rates are useful during simulation."
+    }
+
+    # Real-time clock/counter specifics
+    cdl_component CYGNUM_HAL_RTC_CONSTANTS {
+        display       "Real-time clock constants."
+        flavor        none
+    
+        cdl_option CYGNUM_HAL_RTC_NUMERATOR {
+            display       "Real-time clock numerator"
+            flavor        data
+            calculated    1000000000
+        }
+        cdl_option CYGNUM_HAL_RTC_DENOMINATOR {
+            display       "Real-time clock denominator"
+            flavor        data
+            calculated    100
+        }
+        cdl_option CYGNUM_HAL_RTC_PERIOD {
+            display       "Real-time clock period"
+            flavor        data
+# sfurman: Probably ought be "calculated" - not "default_value"
+# However, it is handy to override this value during simulator-based testing
+            default_value {CYGHWR_HAL_OPENRISC_CPU_FREQ * 1000000 / CYGNUM_HAL_RTC_DENOMINATOR}
+            description   "
+                The tick timer facility is used
+                to drive the eCos kernel RTC. The count register
+                increments at the CPU clock speed.  By default, 100 Hz"
+        }
+    }
+
+    cdl_option CYGBLD_BUILD_GDB_STUBS {
+        display "Build GDB stub ROM image"
+        default_value 0
+        parent CYGBLD_GLOBAL_OPTIONS
+        requires { CYG_HAL_STARTUP == "ROM" }
+        requires CYGSEM_HAL_ROM_MONITOR
+        requires CYGBLD_BUILD_COMMON_GDB_STUBS
+        requires CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        requires ! CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+        requires ! CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+        requires ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+        requires ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+        no_define
+        description "
+                This option enables the building of the GDB stubs for the
+                board. The common HAL controls takes care of most of the
+                build process, but the final conversion from ELF image to
+                binary data is handled by the platform CDL, allowing
+                relocation of the data if necessary."
+
+        make -priority 320 {
+            <PREFIX>/bin/gdb_module.bin : <PREFIX>/bin/gdb_module.img
+            $(OBJCOPY) -O binary $< $@
+        }
+    }
+
+
+    cdl_option CYGNUM_HAL_BREAKPOINT_LIST_SIZE {
+        display       "Number of breakpoints supported by the HAL."
+        flavor        data
+        default_value 25
+        description   "
+            This option determines the number of breakpoints supported by the HAL."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS {
+        display      "Number of communication channels on the board"
+        flavor       data
+        default_value  1
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL {
+        display          "Debug serial port"
+        active_if        CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE
+        flavor data
+        legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+        default_value    0
+        description      "
+           The or1200_soc platform has at least one serial port, but it can potentially have several.
+           This option chooses which port will be used to connect to a host
+           running GDB."
+    }
+ 
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL {
+        display          "Diagnostic serial port"
+        active_if        CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+        flavor data
+        legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+        default_value    0
+        description      "
+           The or1200_soc platform has at least one serial port, but it can potentially have several.
+           This option chooses which port will be used for diagnostic output."
+     }
+
+    cdl_component CYGBLD_GLOBAL_OPTIONS {
+        display "Global build options"
+        flavor  none
+        description   "
+            Global build options including control over
+            compiler flags, linker flags and choice of toolchain."
+
+
+        parent  CYGPKG_NONE
+
+        cdl_option CYGBLD_GLOBAL_COMMAND_PREFIX {
+            display "Global command prefix"
+            flavor  data
+            no_define
+            default_value { "or32-elf" }
+            description "
+                This option specifies the command prefix used when
+                invoking the build tools."
+        }
+
+        cdl_option CYGBLD_GLOBAL_CFLAGS {
+            display "Global compiler flags"
+            flavor  data
+            no_define
+            default_value { "-msoft-float -Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -fno-omit-frame-pointer -fno-rtti -fno-exceptions -fvtable-gc -finit-priority" }
+            description   "
+                This option controls the global compiler flags which
+                are used to compile all packages by
+                default. Individual packages may define
+                options which override these global flags."
+        }
+
+        cdl_option CYGBLD_GLOBAL_LDFLAGS {
+            display "Global linker flags"
+            flavor  data
+            no_define
+            default_value { "-msoft-float -g -nostdlib -Wl,--gc-sections -Wl,-static" }
+            description   "
+                This option controls the global linker flags. Individual
+                packages may define options which override these global flags."
+        }
+    }
+
+    cdl_component CYGHWR_MEMORY_LAYOUT {
+        display "Memory layout"
+        flavor data
+        no_define
+        calculated { CYG_HAL_STARTUP == "RAM" ? "openrisc_or1200_soc_ram" : \
+                                                "openrisc_or1200_soc_rom" }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_LDI {
+            display "Memory layout linker script fragment"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_LDI
+            calculated { CYG_HAL_STARTUP == "RAM" ? "<pkgconf/mlt_openrisc_or1200_soc_ram.ldi>" : \
+                                                    "<pkgconf/mlt_openrisc_or1200_soc_rom.ldi>" }
+        }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_H {
+            display "Memory layout header file"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_H
+            calculated { CYG_HAL_STARTUP == "RAM" ? "<pkgconf/mlt_openrisc_or1200_soc_ram.h>" : \
+                                                    "<pkgconf/mlt_openrisc_or1200_soc_rom.h>" }
+        }
+    }
+
+    cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
+        display       "Work with a ROM monitor"
+        flavor        booldata
+        legal_values  { "Generic" "CygMon" "GDB_stubs" }
+        default_value { CYG_HAL_STARTUP == "RAM" ? "CygMon" : 0 }
+        parent        CYGPKG_HAL_ROM_MONITOR
+        requires      { CYG_HAL_STARTUP == "RAM" }
+        description   "
+            Support can be enabled for three different varieties of ROM monitor.
+            This support changes various eCos semantics such as the encoding
+            of diagnostic output, or the overriding of hardware interrupt
+            vectors.
+            Firstly there is \"Generic\" support which prevents the HAL
+            from overriding the hardware vectors that it does not use, to
+            instead allow an installed ROM monitor to handle them. This is
+            the most basic support which is likely to be common to most
+            implementations of ROM monitor.
+            \"CygMon\" provides support for the Cygnus ROM Monitor.
+            And finally, \"GDB_stubs\" provides support when GDB stubs are
+            included in the ROM monitor or boot ROM."
+    }
+
+    cdl_option CYGSEM_HAL_ROM_MONITOR {
+        display       "Behave as a ROM monitor"
+        flavor        bool
+        default_value 1
+        parent        CYGPKG_HAL_ROM_MONITOR
+        requires      { CYG_HAL_STARTUP == "ROM" }
+        description   "
+            Enable this option if this program is to be used as a ROM monitor,
+            i.e. applications will be loaded into RAM on the board, and this
+            ROM monitor may process exceptions or interrupts generated from the
+            application. This enables features such as utilizing a separate
+            interrupt stack when exceptions are generated."
+    }
+
+    cdl_component CYGPKG_REDBOOT_HAL_OPTIONS {
+        display       "Redboot HAL options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+        description   "
+            This option lists the target's requirements for a valid Redboot
+            configuration."
+
+        cdl_option CYGBLD_BUILD_REDBOOT_BIN {
+            display       "Build Redboot ROM binary image"
+            active_if     CYGBLD_BUILD_REDBOOT
+            default_value 1
+            no_define
+            description "This option enables the conversion of the Redboot ELF
+                         image to a binary image suitable for ROM programming."
+    
+            compile -library=libextras.a redboot_cmds.c
+    
+            make -priority 325 {
+                <PREFIX>/bin/redboot.srec : <PREFIX>/bin/redboot.elf
+                $(OBJCOPY) --strip-all $< $(@:.srec=.img)
+                $(OBJCOPY) -O srec $< $@
+            }
+        }
+    }
+
+    define_proc {
+        puts $cdl_header "#define CYGHWR_HAL_VSR_TABLE    0"
+        puts $cdl_header "#define CYGHWR_HAL_VIRTUAL_VECTOR_TABLE 0x30000000"
+    }
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/doc/README.html ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/doc/README.html
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/doc/README.html	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/doc/README.html	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,13 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+                           
+  <meta http-equiv="refresh"
+ content="1;URL=&quot;../../../arch/current/doc/README.html">
+  <title>README - eCos OpenRISC Port</title>
+    
+</head>
+<body>
+ Redirecting to OpenRISC eCos README...              
+</body>
+</html>
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/hal_diag.h ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/hal_diag.h
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/hal_diag.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/hal_diag.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,69 @@
+#ifndef CYGONCE_HAL_HAL_DIAG_H
+#define CYGONCE_HAL_HAL_DIAG_H
+
+//=============================================================================
+//
+//      hal_diag.h
+//
+//      HAL Support for Kernel Diagnostic Routines
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   nickg
+// Contributors:nickg
+// Date:        2003-02-28
+// Purpose:     HAL Support for Kernel Diagnostic Routines
+// Description: Diagnostic routines for use during kernel development.
+// Usage:       #include <cyg/hal/hal_diag.h>
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/hal/hal_if.h>
+
+#define HAL_DIAG_INIT() hal_if_diag_init()
+#define HAL_DIAG_WRITE_CHAR(_c_) hal_if_diag_write_char(_c_)
+#define HAL_DIAG_READ_CHAR(_c_) hal_if_diag_read_char(&_c_)
+
+//-----------------------------------------------------------------------------
+// end of hal_diag.h
+#endif // CYGONCE_HAL_HAL_DIAG_H
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/mc.h ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/mc.h
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/mc.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/mc.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,143 @@
+//==========================================================================
+//
+//      mc.h
+//
+//      OpenCores.org memory controller definitions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: Marko Mlinar
+// Date:         2003-01-17
+// Purpose:      Define OpenRISC architecture special-purpose registers
+// Usage:        #include <cyg/hal/hal_arch.h>
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+/* Prototypes */
+#ifndef __MC_H
+#define __MC_H
+
+#define N_CE        (8)
+
+#define MC_CSR      (0x00)
+#define MC_POC      (0x04)
+#define MC_BA_MASK  (0x08)
+#define MC_CSC(i)   (0x10 + (i) * 8)
+#define MC_TMS(i)   (0x14 + (i) * 8)
+
+#define MC_ADDR_SPACE (MC_CSC(N_CE))
+
+/* POC register field definition */
+#define MC_POC_EN_BW_OFFSET     0
+#define MC_POC_EN_BW_WIDTH      2
+#define MC_POC_EN_MEMTYPE_OFFSET        2
+#define MC_POC_EN_MEMTYPE_WIDTH 2
+
+/* CSC register field definition */
+#define MC_CSC_EN_OFFSET        0
+#define MC_CSC_MEMTYPE_OFFSET   1
+#define MC_CSC_MEMTYPE_WIDTH    2
+#define MC_CSC_BW_OFFSET        4
+#define MC_CSC_BW_WIDTH         2
+#define MC_CSC_MS_OFFSET        6
+#define MC_CSC_MS_WIDTH         2
+#define MC_CSC_WP_OFFSET        8
+#define MC_CSC_BAS_OFFSET       9
+#define MC_CSC_KRO_OFFSET       10
+#define MC_CSC_PEN_OFFSET       11
+#define MC_CSC_SEL_OFFSET       16
+#define MC_CSC_SEL_WIDTH        8
+
+#define MC_CSC_MEMTYPE_SDRAM  0
+#define MC_CSC_MEMTYPE_SSRAM  1
+#define MC_CSC_MEMTYPE_ASYNC  2
+#define MC_CSC_MEMTYPE_SYNC   3
+
+#define MC_CSR_VALID            0xFF000703LU
+#define MC_POC_VALID            0x0000000FLU
+#define MC_BA_MASK_VALID        0x000000FFLU
+#define MC_CSC_VALID            0x00FF0FFFLU
+#define MC_TMS_SDRAM_VALID      0x0FFF83FFLU
+#define MC_TMS_SSRAM_VALID      0x00000000LU
+#define MC_TMS_ASYNC_VALID      0x03FFFFFFLU
+#define MC_TMS_SYNC_VALID       0x01FFFFFFLU
+#define MC_TMS_VALID            0xFFFFFFFFLU /* reg test compat. */
+
+/* TMS register field definition SDRAM */
+#define MC_TMS_SDRAM_TRFC_OFFSET        24
+#define MC_TMS_SDRAM_TRFC_WIDTH         4
+#define MC_TMS_SDRAM_TRP_OFFSET         20
+#define MC_TMS_SDRAM_TRP_WIDTH          4
+#define MC_TMS_SDRAM_TRCD_OFFSET        17
+#define MC_TMS_SDRAM_TRCD_WIDTH         4
+#define MC_TMS_SDRAM_TWR_OFFSET         15
+#define MC_TMS_SDRAM_TWR_WIDTH          2
+#define MC_TMS_SDRAM_WBL_OFFSET         9
+#define MC_TMS_SDRAM_OM_OFFSET          7
+#define MC_TMS_SDRAM_OM_WIDTH           2
+#define MC_TMS_SDRAM_CL_OFFSET          4
+#define MC_TMS_SDRAM_CL_WIDTH           3
+#define MC_TMS_SDRAM_BT_OFFSET          3
+#define MC_TMS_SDRAM_BL_OFFSET          0
+#define MC_TMS_SDRAM_BL_WIDTH           3
+
+/* TMS register field definition ASYNC */
+#define MC_TMS_ASYNC_TWWD_OFFSET        20
+#define MC_TMS_ASYNC_TWWD_WIDTH         6
+#define MC_TMS_ASYNC_TWD_OFFSET         16
+#define MC_TMS_ASYNC_TWD_WIDTH          4
+#define MC_TMS_ASYNC_TWPW_OFFSET        12
+#define MC_TMS_ASYNC_TWPW_WIDTH         4
+#define MC_TMS_ASYNC_TRDZ_OFFSET        8
+#define MC_TMS_ASYNC_TRDZ_WIDTH         4
+#define MC_TMS_ASYNC_TRDV_OFFSET        0
+#define MC_TMS_ASYNC_TRDV_WIDTH         8
+
+/* TMS register field definition SYNC  */
+#define MC_TMS_SYNC_TTO_OFFSET          16
+#define MC_TMS_SYNC_TTO_WIDTH           9
+#define MC_TMS_SYNC_TWR_OFFSET          12
+#define MC_TMS_SYNC_TWR_WIDTH           4
+#define MC_TMS_SYNC_TRDZ_OFFSET         8
+#define MC_TMS_SYNC_TRDZ_WIDTH          4
+#define MC_TMS_SYNC_TRDV_OFFSET         0
+#define MC_TMS_SYNC_TRDV_WIDTH          8
+
+#endif
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.h ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.h
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.h	2010-02-09 10:06:21.870364800 -0800
@@ -0,0 +1,37 @@
+// eCos memory layout
+
+#ifndef __ASSEMBLER__
+#include <cyg/infra/cyg_type.h>
+#include <stddef.h>
+
+#endif
+#define CYGMEM_REGION_ram (0)
+#define CYGMEM_REGION_ram_SIZE (0x00080000)
+#define CYGMEM_REGION_ram_ATTR (CYGMEM_REGION_ATTR_R | CYGMEM_REGION_ATTR_W)
+#define CYGMEM_REGION_rom (0x20000000)
+#define CYGMEM_REGION_rom_SIZE (0x00400000)
+#define CYGMEM_REGION_rom_ATTR (CYGMEM_REGION_ATTR_R)
+
+#if 0
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vectors) [];
+#endif
+#define CYGMEM_SECTION_reserved_vectors (CYG_LABEL_NAME (__reserved_vectors))
+#define CYGMEM_SECTION_reserved_vectors_SIZE (0x3000)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vsr_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_vsr_table (CYG_LABEL_NAME (__reserved_vsr_table))
+#define CYGMEM_SECTION_reserved_vsr_table_SIZE (0x200)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_virtual_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_virtual_table (CYG_LABEL_NAME (__reserved_virtual_table))
+#define CYGMEM_SECTION_reserved_virtual_table_SIZE (0x100)
+#endif
+
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__heap1) [];
+#endif
+#define CYGMEM_SECTION_heap1 (CYG_LABEL_NAME (__heap1))
+#define CYGMEM_SECTION_heap1_SIZE (CYGMEM_REGION_ram_SIZE - (size_t) CYG_LABEL_NAME (__heap1))
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.ldi ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.ldi
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.ldi	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_ram.ldi	2010-02-09 10:06:53.713503400 -0800
@@ -0,0 +1,25 @@
+// eCos memory layout
+
+#include <cyg/infra/cyg_type.inc>
+
+MEMORY
+{
+    ram : ORIGIN = 0x00000000, LENGTH = 0x00080000
+    rom : ORIGIN = 0x20000000, LENGTH = 0x00400000
+}
+
+SECTIONS
+{
+    SECTIONS_BEGIN
+    SECTION_vectors (ram, 0x00000100, LMA_EQ_VMA)
+    SECTION_text (ram, 0x00008000, LMA_EQ_VMA)
+    SECTION_fini (ram, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata1 (ram, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_rodata (ram, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_fixup (ram, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_gcc_except_table (ram, ALIGN (0x1), LMA_EQ_VMA)
+    SECTION_data (ram, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_bss (ram, ALIGN (0x10), LMA_EQ_VMA)
+    CYG_LABEL_DEFN(__heap1) = ALIGN (0x8);
+    SECTIONS_END
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.h ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.h
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.h	2010-02-15 12:04:01.734170600 -0800
@@ -0,0 +1,37 @@
+// eCos memory layout
+
+#ifndef __ASSEMBLER__
+#include <cyg/infra/cyg_type.h>
+#include <stddef.h>
+
+#endif
+#define CYGMEM_REGION_ram (0x30000000)
+#define CYGMEM_REGION_ram_SIZE (0x00080000)
+#define CYGMEM_REGION_ram_ATTR (CYGMEM_REGION_ATTR_R | CYGMEM_REGION_ATTR_W)
+#define CYGMEM_REGION_rom (0x20000000)
+#define CYGMEM_REGION_rom_SIZE (0x00400000)
+#define CYGMEM_REGION_rom_ATTR (CYGMEM_REGION_ATTR_R)
+
+#if 0
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vectors) [];
+#endif
+#define CYGMEM_SECTION_reserved_vectors (CYG_LABEL_NAME (__reserved_vectors))
+#define CYGMEM_SECTION_reserved_vectors_SIZE (0x3000)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vsr_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_vsr_table (CYG_LABEL_NAME (__reserved_vsr_table))
+#define CYGMEM_SECTION_reserved_vsr_table_SIZE (0x200)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_virtual_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_virtual_table (CYG_LABEL_NAME (__reserved_virtual_table))
+#define CYGMEM_SECTION_reserved_virtual_table_SIZE (0x100)
+#endif
+
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__heap1) [];
+#endif
+#define CYGMEM_SECTION_heap1 (CYG_LABEL_NAME (__heap1))
+#define CYGMEM_SECTION_heap1_SIZE (CYGMEM_REGION_ram_SIZE - ((size_t) CYG_LABEL_NAME (__heap1) - CYGMEM_REGION_ram) )
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.ldi ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.ldi
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.ldi	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/pkgconf/mlt_openrisc_or1200_soc_rom.ldi	2010-02-17 12:34:51.525537000 -0800
@@ -0,0 +1,26 @@
+// eCos memory layout
+
+#include <cyg/infra/cyg_type.inc>
+
+MEMORY
+{
+    ram         : ORIGIN = 0x00000000, LENGTH = 0x00080000
+    rom         : ORIGIN = 0x20000000, LENGTH = 0x00400000
+    mem_bank_3  : ORIGIN = 0x30000000, LENGTH = 0x00080000
+}
+
+SECTIONS
+{
+    SECTIONS_BEGIN
+    SECTION_vectors (rom, 0x20000000, LMA_EQ_VMA)
+    SECTION_text (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fini (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata1 (rom, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_rodata (rom, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_fixup (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_gcc_except_table (rom, ALIGN (0x1), LMA_EQ_VMA)
+    SECTION_data (mem_bank_3, 0x30001000, FOLLOWING (.gcc_except_table))
+    SECTION_bss (mem_bank_3, ALIGN (0x10), LMA_EQ_VMA)
+    CYG_LABEL_DEFN(__heap1) = ALIGN (0x8);
+    SECTIONS_END
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/platform.inc ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/platform.inc
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/platform.inc	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/platform.inc	2010-02-09 17:21:33.758015400 -0800
@@ -0,0 +1,124 @@
+##==========================================================================
+##
+##      platform.inc
+##
+##      OpenRISC Reference Platform (ORP) board-specific defines
+##
+##==========================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+##==========================================================================
+#######DESCRIPTIONBEGIN####
+##
+## Author(s):    sfurman
+## Contributors: qaztronic
+## Date:         2003-01-20
+## Purpose:      ORP platform-specific init
+## Description:  This file handles the post-reset hardware initialization
+##               that is specific to the ORP platform (but not specific to
+##               the OpenRISC processor itself).  So far, it only
+##               initializes the memory controller so as to map Flash and
+##               SDRAM into the memory space.
+##
+######DESCRIPTIONEND####
+##
+##==========================================================================
+
+#ifndef _PLATFORM_INC_
+#define _PLATFORM_INC_
+
+#include <cyg/hal/mc.h>
+#include CYGHWR_MEMORY_LAYOUT_H
+
+/* Memory organization */
+#define SDRAM_BASE_ADD  CYGMEM_REGION_ram
+#define FLASH_BASE_ADD  CYGMEM_REGION_rom
+
+/* Memory Controller's base address */
+#define MC_BASE_ADD     0x93000000
+
+/* Memory controller initialize magic values */
+#define MC_CSR_VAL      0x0B000300
+#define MC_MASK_VAL     0x000003f0
+#define FLASH_TMS_VAL   0x00000103
+#define SDRAM_TMS_VAL   0x19220057
+#define FLASH_CSC_VAL   (((FLASH_BASE_ADD>>6) & 0x07ff0000) | 0x0025)
+#define SDRAM_CSC_VAL   (((SDRAM_BASE_ADD>>6) & 0x07ff0000) | 0x0411)
+                
+
+        # Platform-specific, post-reset hardware initialization
+        .macro  hal_hardware_init
+        
+init_func:
+        # pause sim 
+        load32i r3,0x5ffffffc
+        load32i r5,0xcea5e0ff
+        l.sw    (0)(r3),r5
+        
+# init_mc:
+#         load32i r3,MC_BASE_ADD
+
+#         # Program Flash chip-select 
+#         load32i r5,FLASH_CSC_VAL
+#         l.sw    MC_CSC(0)(r3),r5
+
+#         # Init flash timing 
+#         load32i r5,FLASH_TMS_VAL
+#         l.sw    MC_TMS(0)(r3),r5
+
+#         # Start decoding memory addresses to generate chip-selects
+#         l.addi  r5,r0,MC_MASK_VAL
+#         l.sw    MC_BA_MASK(r3),r5
+
+#         load32i r5, MC_CSR_VAL
+#         l.sw    MC_CSR(r3),r5
+
+#         # Init DRAM timing 
+#         load32i r5, SDRAM_TMS_VAL
+#         l.sw    MC_TMS(1)(r3),r5
+
+#         # Program DRAM chip-select 
+#         load32i r5, SDRAM_CSC_VAL
+#         l.sw    MC_CSC(1)(r3),r5
+
+#         # Wait for SDRAM
+#         l.addi  r3,r0,0x1000
+# 1:      l.sfeqi r3,0
+#         l.bnf   1b
+#         l.addi  r3,r3,-1
+        
+        .endm
+        
+#endif /* ifndef _PLATFORM_INC_ */
+
+#undef CYGIMP_FORCE_INTERRUPT_HANDLING_CODE_IN_RAM
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_intr.h ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_intr.h
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_intr.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_intr.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,80 @@
+#ifndef CYGONCE_HAL_PLF_INTR_H
+#define CYGONCE_HAL_PLF_INTR_H
+
+//==========================================================================
+//
+//      plf_intr.h
+//
+//      OpenRISC ORP platform-specific interrupt definitions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: 
+// Date:         2002-02-28
+// Purpose:      Define platform specific interrupt support
+//              
+// Usage:
+//              #include <cyg/hal/plf_intr.h>
+//              ...
+//              
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+
+//----------------------------------------------------------------------------
+// Reset.
+
+// This function should perform a hardware reset
+// For now, it does nothing.
+#define HAL_PLATFORM_RESET() CYG_EMPTY_STATEMENT
+
+// If no HW reset exists, jump to this location instead.
+// The current value is the ROM reset entry point.
+#define HAL_PLATFORM_RESET_ENTRY 0xF0001000
+
+// Define PIC interrupt numbers for peripherals
+#define CYGNUM_HAL_INTERRUPT_SERIAL_CONSOLE    CYGNUM_HAL_INTERRUPT_2
+#define CYGNUM_HAL_INTERRUPT_SERIAL_DEBUGGER   CYGNUM_HAL_INTERRUPT_3
+
+
+//--------------------------------------------------------------------------
+#endif // ifndef CYGONCE_HAL_PLF_INTR_H
+// End of plf_intr.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_stub.h ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_stub.h
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_stub.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/include/plf_stub.h	2010-02-05 17:08:20.269461800 -0800
@@ -0,0 +1,69 @@
+//=============================================================================
+//
+//      plf_stub.h
+//
+//      Platform header for GDB stub support.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   sfurman
+// Contributors:jskov
+// Date:        2003-02-28
+// Purpose:     Platform HAL stub support for PowerPC/VIPER board.
+// Usage:       #include <cyg/hal/plf_stub.h>
+//              
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#ifndef CYGONCE_HAL_PLF_STUB_H
+#define CYGONCE_HAL_PLF_STUB_H
+
+#include <pkgconf/hal.h>
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+
+#include <cyg/infra/cyg_type.h>         // CYG_UNUSED_PARAM
+#include <cyg/hal/openrisc_stub.h>
+
+//----------------------------------------------------------------------------
+// Stub initializer.
+
+#endif // ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+//-----------------------------------------------------------------------------
+#endif // CYGONCE_HAL_PLF_STUB_H
+// End of plf_stub.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_aux.c ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_aux.c
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_aux.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_aux.c	2010-02-09 17:15:23.343252500 -0800
@@ -0,0 +1,72 @@
+//=============================================================================
+//
+//      hal_aux.c
+//
+//      HAL auxiliary objects and code; per platform
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   hmt
+// Contributors:hmt
+// Date:        2003-02-28
+// Purpose:     HAL aux objects: startup tables.
+// Description: Tables for per-platform initialization
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#include <cyg/hal/hal_if.h>
+
+//--------------------------------------------------------------------------
+// Platform init code.
+void
+hal_platform_init(void)
+{
+    // Basic hardware initialization has already taken place
+    
+	*((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+
+    hal_if_init();   // Initialize logical I/O layer (virtual vector support)
+    
+	*((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+    
+}
+
+// EOF hal_aux.c
+
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_diag.c ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_diag.c
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_diag.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/hal_diag.c	2010-02-09 16:59:00.002758000 -0800
@@ -0,0 +1,589 @@
+//=============================================================================
+//
+//      hal_diag.c
+//
+//      Simple polling driver for the 16c550c serial controller(s) in the ORP,
+//      to be used for diagnostic I/O and gdb remote debugging.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   sfurman
+// Contributors:dmoseley
+// Date:        2003-02-28
+// Description: Simple polling driver for the 16c550c serial controller(s) in the ORP,
+//              to be used for diagnostic I/O and gdb remote debugging.
+//      
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/hal/hal_arch.h>           // SAVE/RESTORE GP macros
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_if.h>             // interface API
+#include <cyg/hal/hal_intr.h>           // HAL_ENABLE/MASK/UNMASK_INTERRUPTS
+#include <cyg/hal/hal_misc.h>           // Helper functions
+#include <cyg/hal/drv_api.h>            // CYG_ISR_HANDLED
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+//-----------------------------------------------------------------------------
+// Base addresses for each 16550 UART in the system
+#define SERIAL_16550_CONSOLE_BASE_ADDR    0x50000000
+
+//-----------------------------------------------------------------------------
+// Define the 16550C serial registers.
+#define SER_16550_RBR 0x00   // receiver buffer register, read, dlab = 0
+#define SER_16550_THR 0x00   // transmitter holding register, write, dlab = 0
+#define SER_16550_DLL 0x00   // divisor latch (LS), read/write, dlab = 1
+#define SER_16550_IER 0x01   // interrupt enable register, read/write, dlab = 0
+#define SER_16550_DLM 0x01   // divisor latch (MS), read/write, dlab = 1
+#define SER_16550_IIR 0x02   // interrupt identification reg, read, dlab = 0
+#define SER_16550_FCR 0x02   // fifo control register, write, dlab = 0
+#define SER_16550_AFR 0x02   // alternate function reg, read/write, dlab = 1
+#define SER_16550_LCR 0x03   // line control register, read/write
+#define SER_16550_MCR 0x04   // modem control register, read/write
+#define SER_16550_LSR 0x05   // line status register, read
+#define SER_16550_MSR 0x06   // modem status register, read
+#define SER_16550_SCR 0x07   // scratch pad register
+
+// The interrupt enable register bits.
+#define SIO_IER_ERDAI   0x01            // enable received data available irq
+#define SIO_IER_ETHREI  0x02            // enable THR empty interrupt
+#define SIO_IER_ELSI    0x04            // enable receiver line status irq
+#define SIO_IER_EMSI    0x08            // enable modem status interrupt
+
+// The interrupt identification register bits.
+#define SIO_IIR_IP      0x01            // 0 if interrupt pending
+#define SIO_IIR_ID_MASK 0x0e            // mask for interrupt ID bits
+
+// The line status register bits.
+#define SIO_LSR_DR      0x01            // data ready
+#define SIO_LSR_OE      0x02            // overrun error
+#define SIO_LSR_PE      0x04            // parity error
+#define SIO_LSR_FE      0x08            // framing error
+#define SIO_LSR_BI      0x10            // break interrupt
+#define SIO_LSR_THRE    0x20            // transmitter holding register empty
+#define SIO_LSR_TEMT    0x40            // transmitter register empty
+#define SIO_LSR_ERR     0x80            // any error condition
+
+// The modem status register bits.
+#define SIO_MSR_DCTS  0x01              // delta clear to send
+#define SIO_MSR_DDSR  0x02              // delta data set ready
+#define SIO_MSR_TERI  0x04              // trailing edge ring indicator
+#define SIO_MSR_DDCD  0x08              // delta data carrier detect
+#define SIO_MSR_CTS   0x10              // clear to send
+#define SIO_MSR_DSR   0x20              // data set ready
+#define SIO_MSR_RI    0x40              // ring indicator
+#define SIO_MSR_DCD   0x80              // data carrier detect
+
+// The line control register bits.
+#define SIO_LCR_WLS0   0x01             // word length select bit 0
+#define SIO_LCR_WLS1   0x02             // word length select bit 1
+#define SIO_LCR_STB    0x04             // number of stop bits
+#define SIO_LCR_PEN    0x08             // parity enable
+#define SIO_LCR_EPS    0x10             // even parity select
+#define SIO_LCR_SP     0x20             // stick parity
+#define SIO_LCR_SB     0x40             // set break
+#define SIO_LCR_DLAB   0x80             // divisor latch access bit
+
+// The FIFO control register
+#define SIO_FCR_FCR0   0x01             // enable xmit and rcvr fifos
+#define SIO_FCR_FCR1   0x02             // clear RCVR FIFO
+#define SIO_FCR_FCR2   0x04             // clear XMIT FIFO
+
+/////////////////////////////////////////
+// Interrupt Enable Register
+#define IER_RCV 0x01
+#define IER_XMT 0x02
+#define IER_LS  0x04
+#define IER_MS  0x08
+
+// Line Control Register
+#define LCR_WL5 0x00    // Word length
+#define LCR_WL6 0x01
+#define LCR_WL7 0x02
+#define LCR_WL8 0x03
+#define LCR_SB1 0x00    // Number of stop bits
+#define LCR_SB1_5 0x04  // 1.5 -> only valid with 5 bit words
+#define LCR_SB2 0x04
+#define LCR_PN  0x00    // Parity mode - none
+#define LCR_PE  0x0C    // Parity mode - even
+#define LCR_PO  0x08    // Parity mode - odd
+#define LCR_PM  0x28    // Forced "mark" parity
+#define LCR_PS  0x38    // Forced "space" parity
+#define LCR_DL  0x80    // Enable baud rate latch
+
+// Line Status Register
+#define LSR_RSR 0x01
+#define LSR_THE 0x20
+
+// Modem Control Register
+#define MCR_DTR 0x01
+#define MCR_RTS 0x02
+#define MCR_INT 0x08   // Enable interrupts
+
+// Interrupt status register
+#define ISR_None             0x01
+#define ISR_Rx_Line_Status   0x06
+#define ISR_Rx_Avail         0x04
+#define ISR_Rx_Char_Timeout  0x0C
+#define ISR_Tx_Empty         0x02
+#define ISR_Modem_Status     0x00
+
+// FIFO control register
+#define FCR_ENABLE     0x01
+#define FCR_CLEAR_RCVR 0x02
+#define FCR_CLEAR_XMIT 0x04
+
+// Assume the UART is driven 1/16 CPU frequency
+#define UART_CLOCK    ((CYGHWR_HAL_OPENRISC_CPU_FREQ)*1.0e6/16.0)
+
+#define DIVISOR(baud) ((int)((UART_CLOCK)/baud))
+
+#ifdef CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD
+#define CYG_DEV_SERIAL_BAUD_DIVISOR   \
+    DIVISOR(CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD)
+#else
+#error Missing/incorrect serial baud rate defined - CDL error?
+#endif
+
+
+//-----------------------------------------------------------------------------
+typedef struct {
+    cyg_uint8* base;
+    cyg_int32 msec_timeout;
+    int isr_vector;
+} channel_data_t;
+
+static channel_data_t channels[] = {
+    { (cyg_uint8*)SERIAL_16550_CONSOLE_BASE_ADDR,
+      1000,
+      CYGNUM_HAL_INTERRUPT_SERIAL_CONSOLE
+    }
+};
+
+//-----------------------------------------------------------------------------
+// Set the baud rate
+
+static void
+cyg_hal_plf_serial_set_baud(cyg_uint8* port, cyg_uint16 baud_divisor)
+{
+    cyg_uint8 _lcr;
+
+    HAL_READ_UINT8(port+SER_16550_LCR, _lcr);
+    _lcr |= LCR_DL;
+    HAL_WRITE_UINT8(port+SER_16550_LCR, _lcr);
+
+    HAL_WRITE_UINT8(port+SER_16550_DLM, baud_divisor >> 8);
+    HAL_WRITE_UINT8(port+SER_16550_DLL, baud_divisor & 0xff);
+
+    _lcr &= ~LCR_DL;
+    HAL_WRITE_UINT8(port+SER_16550_LCR, _lcr);
+}
+
+//-----------------------------------------------------------------------------
+// The minimal init, get and put functions. All by polling.
+
+void
+cyg_hal_plf_serial_init_channel(void* __ch_data)
+{
+    cyg_uint8* port;
+    cyg_uint8 _lcr;
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    port = ((channel_data_t*)__ch_data)->base;
+
+    // Disable port interrupts while changing hardware
+    HAL_WRITE_UINT8(port+SER_16550_IER, 0);
+
+    // Set databits, stopbits and parity.
+    _lcr = LCR_WL8 | LCR_SB1 | LCR_PN;
+    HAL_WRITE_UINT8(port+SER_16550_LCR, _lcr);
+
+    // Set baud rate.
+    cyg_hal_plf_serial_set_baud(port, CYG_DEV_SERIAL_BAUD_DIVISOR);
+
+    // Enable and clear FIFO
+    HAL_WRITE_UINT8(port+SER_16550_FCR, (FCR_ENABLE | FCR_CLEAR_RCVR | FCR_CLEAR_XMIT));
+
+    // enable RTS to keep host side happy
+    HAL_WRITE_UINT8( port+SER_16550_MCR, MCR_RTS );
+    
+    // Don't allow interrupts.
+    HAL_WRITE_UINT8(port+SER_16550_IER, 0);
+}
+
+void
+cyg_hal_plf_serial_putc(void* __ch_data, cyg_uint8 __ch)
+{
+    cyg_uint8* port;
+    cyg_uint8 _lsr;
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    port = ((channel_data_t*)__ch_data)->base;
+
+    CYGARC_HAL_SAVE_GP();
+
+    do {
+        HAL_READ_UINT8(port+SER_16550_LSR, _lsr);
+    } while ((_lsr & SIO_LSR_THRE) == 0);
+
+    // Now, the transmit buffer is empty
+    HAL_WRITE_UINT8(port+SER_16550_THR, __ch);
+
+    // Hang around until the character has been safely sent.
+    do {
+        HAL_READ_UINT8(port+SER_16550_LSR, _lsr);
+    } while ((_lsr & SIO_LSR_THRE) == 0);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static int lsr_global;
+
+static cyg_bool
+cyg_hal_plf_serial_getc_nonblock(void* __ch_data, cyg_uint8* ch)
+{
+    cyg_uint8* port;
+    cyg_uint8 _lsr;
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    port = ((channel_data_t*)__ch_data)->base;
+
+    HAL_READ_UINT8(port+SER_16550_LSR, _lsr);
+    if ((_lsr & SIO_LSR_DR) == 0)
+        return false;
+    lsr_global = _lsr;
+    CYG_ASSERT((_lsr & SIO_LSR_OE) == 0 , "UART receiver overrun error");
+    HAL_READ_UINT8(port+SER_16550_RBR, *ch);
+
+    return true;
+}
+
+cyg_uint8
+cyg_hal_plf_serial_getc(void* __ch_data)
+{
+    cyg_uint8 ch;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    while(!cyg_hal_plf_serial_getc_nonblock(__ch_data, &ch));
+
+    CYGARC_HAL_RESTORE_GP();
+    return ch;
+}
+
+static void
+cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf, 
+                         cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    while(__len-- > 0)
+        cyg_hal_plf_serial_putc(__ch_data, *__buf++);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static void
+cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf, cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    while(__len-- > 0)
+        *__buf++ = cyg_hal_plf_serial_getc(__ch_data);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+
+cyg_bool
+cyg_hal_plf_serial_getc_timeout(void* __ch_data, cyg_uint8* ch)
+{
+    int delay_count;
+    channel_data_t* chan;
+    cyg_bool res;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    chan = (channel_data_t*)__ch_data;
+
+    delay_count = chan->msec_timeout; // delay in 1000 us steps
+
+    for(;;) {
+        res = cyg_hal_plf_serial_getc_nonblock(__ch_data, ch);
+        if (res || 0 == delay_count--)
+            break;
+        CYGACC_CALL_IF_DELAY_US(1000);
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static int
+cyg_hal_plf_serial_control(void *__ch_data, __comm_control_cmd_t __func, ...)
+{
+    static int irq_state = 0;
+    channel_data_t* chan;
+    cyg_uint8 ier;
+    int ret = 0;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    chan = (channel_data_t*)__ch_data;
+
+    switch (__func) {
+    case __COMMCTL_IRQ_ENABLE:
+        irq_state = 1;
+
+        HAL_READ_UINT8(chan->base + SER_16550_IER, ier);
+        ier |= SIO_IER_ERDAI;
+        HAL_WRITE_UINT8(chan->base + SER_16550_IER, ier);
+
+        HAL_INTERRUPT_SET_LEVEL(chan->isr_vector, 1);
+        HAL_INTERRUPT_UNMASK(chan->isr_vector);
+        break;
+    case __COMMCTL_IRQ_DISABLE:
+        ret = irq_state;
+        irq_state = 0;
+
+        HAL_READ_UINT8(chan->base + SER_16550_IER, ier);
+        ier &= ~SIO_IER_ERDAI;
+        HAL_WRITE_UINT8(chan->base + SER_16550_IER, ier);
+
+        HAL_INTERRUPT_MASK(chan->isr_vector);
+        break;
+    case __COMMCTL_DBG_ISR_VECTOR:
+        ret = chan->isr_vector;
+        break;
+    case __COMMCTL_SET_TIMEOUT:
+    {
+        va_list ap;
+
+        va_start(ap, __func);
+
+        ret = chan->msec_timeout;
+        chan->msec_timeout = va_arg(ap, cyg_uint32);
+
+        va_end(ap);
+    }        
+    break;
+    case __COMMCTL_SETBAUD:
+    {
+        cyg_uint32 baud_rate;
+        cyg_uint16 baud_divisor;
+        cyg_uint8* port = chan->base;
+        va_list ap;
+
+        va_start(ap, __func);
+        baud_rate = va_arg(ap, cyg_uint32);
+        va_end(ap);
+
+        switch (baud_rate)
+        {
+        case 110:    baud_divisor = DIVISOR(110);    break;
+        case 150:    baud_divisor = DIVISOR(150);    break;
+        case 300:    baud_divisor = DIVISOR(300);    break;
+        case 600:    baud_divisor = DIVISOR(600);    break;
+        case 1200:   baud_divisor = DIVISOR(1200);   break;
+        case 2400:   baud_divisor = DIVISOR(2400);   break;
+        case 4800:   baud_divisor = DIVISOR(4800);   break;
+        case 7200:   baud_divisor = DIVISOR(7200);   break;
+        case 9600:   baud_divisor = DIVISOR(9600);   break;
+        case 14400:  baud_divisor = DIVISOR(14400);  break;
+        case 19200:  baud_divisor = DIVISOR(19200);  break;
+        case 38400:  baud_divisor = DIVISOR(38400);  break;
+        case 57600:  baud_divisor = DIVISOR(57600);  break;
+        case 115200: baud_divisor = DIVISOR(115200); break;
+        case 230400: baud_divisor = DIVISOR(230400); break;
+        default:     return -1;                      break; // Invalid baud rate selected
+        }
+
+        // Disable port interrupts while changing hardware
+        HAL_READ_UINT8(port+SER_16550_IER, ier);
+        HAL_WRITE_UINT8(port+SER_16550_IER, 0);
+
+        // Set baud rate.
+        cyg_hal_plf_serial_set_baud(port, baud_divisor);
+
+        // Reenable interrupts if necessary
+        HAL_WRITE_UINT8(port+SER_16550_IER, ier);
+    }
+    break;
+
+    case __COMMCTL_GETBAUD:
+        break;
+    default:
+        break;
+    }
+    CYGARC_HAL_RESTORE_GP();
+    return ret;
+}
+
+static int
+cyg_hal_plf_serial_isr(void *__ch_data, int* __ctrlc, 
+                       CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
+{
+    int res = 0;
+    cyg_uint8 _iir, c;
+    channel_data_t* chan;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    chan = (channel_data_t*)__ch_data;
+
+    HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
+
+    HAL_READ_UINT8(chan->base + SER_16550_IIR, _iir);
+    _iir &= SIO_IIR_ID_MASK;
+
+    *__ctrlc = 0;
+    if ((_iir == ISR_Rx_Avail) || (_iir == ISR_Rx_Char_Timeout)) {
+
+        HAL_READ_UINT8(chan->base + SER_16550_RBR, c);
+    
+        if( cyg_hal_is_break( &c , 1 ) )
+            *__ctrlc = 1;
+
+        res = CYG_ISR_HANDLED;
+    }
+
+    /* sfurman - Hmmm.  Under or1ksim, we sometimes receive interrupts
+       when no characters are in the FIFO.  I think this is a SW bug
+       and not a problem w/ or1ksim, but until the problem is solved,
+       we always consume the interrupt */
+    res = CYG_ISR_HANDLED;
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static void
+cyg_hal_plf_serial_init(void)
+{
+    int i;
+    hal_virtual_comm_table_t* comm;
+    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
+
+    //#define NUM_CHANNELS (sizeof(channels)/sizeof(channels[0]))
+#define NUM_CHANNELS CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS
+    for (i = 0; i < NUM_CHANNELS; i++) {
+
+    // Disable interrupts.
+    HAL_INTERRUPT_MASK(channels[i].isr_vector);
+
+    // Init channels
+    cyg_hal_plf_serial_init_channel((void*)&channels[i]);
+    
+    // Setup procs in the vector table
+
+    // Set COMM callbacks for channel
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(i);
+    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
+    CYGACC_COMM_IF_CH_DATA_SET(*comm, &channels[i]);
+    CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
+    CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
+    CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
+    CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_serial_getc);
+    CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_serial_control);
+    CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_serial_isr);
+    CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_serial_getc_timeout);
+    }
+
+    // Restore original console
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
+}
+
+void
+cyg_hal_plf_comms_init(void)
+{
+    static int initialized = 0;
+
+    if (initialized)
+        return;
+
+    initialized = 1;
+
+    cyg_hal_plf_serial_init();
+}
+
+//-----------------------------------------------------------------------------
+// end of ser16c550c.c
+
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/redboot_cmds.c ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/redboot_cmds.c
--- /opt/ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/redboot_cmds.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/or1200_soc/v3_0/src/redboot_cmds.c	2010-02-17 11:05:35.234723400 -0800
@@ -0,0 +1,73 @@
+//==========================================================================
+//
+//      redboot_cmds.c
+//
+//      custom redboot commands
+//
+//==========================================================================
+// ####ECOSGPLCOPYRIGHTBEGIN####                                            
+// -------------------------------------------                              
+// This file is part of eCos, the Embedded Configurable Operating System.   
+// Copyright (C) 2004 Free Software Foundation, Inc.                        
+//
+// eCos is free software; you can redistribute it and/or modify it under    
+// the terms of the GNU General Public License as published by the Free     
+// Software Foundation; either version 2 or (at your option) any later      
+// version.                                                                 
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT      
+// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    
+// for more details.                                                        
+//
+// You should have received a copy of the GNU General Public License        
+// along with eCos; if not, write to the Free Software Foundation, Inc.,    
+// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.            
+//
+// As a special exception, if other files instantiate templates or use      
+// macros or inline functions from this file, or you compile this file      
+// and link it with other works to produce a work based on this file,       
+// this file does not by itself cause the resulting work to be covered by   
+// the GNU General Public License. However the source code for this file    
+// must still be made available in accordance with section (3) of the GNU   
+// General Public License v2.                                               
+//
+// This exception does not invalidate any other reasons why a work based    
+// on this file might be covered by the GNU General Public License.         
+// -------------------------------------------                              
+// ####ECOSGPLCOPYRIGHTEND####                                              
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    
+// Contributors: 
+// Date:         
+// Purpose:      
+// Description:  
+//              
+// This code is part of RedBoot (tm).
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+
+#include <redboot.h>
+#include <cyg/hal/hal_io.h>
+
+// CLI functions
+static void do_test_led(int argc, char *argv[]);
+RedBoot_cmd ( "test_led",
+              "Test the leds.",
+              " ", 
+              do_test_led
+             );
+
+static void
+do_test_led(int argc, char *argv[])
+{
+  
+	*((volatile unsigned int *)(0x60000014)) = 0xffffffff;
+	*((volatile unsigned int *)(0x60000008)) = 0xffffffff;
+
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/ChangeLog ./ecos-3.0/packages/hal/openrisc/orp/v3_0/ChangeLog
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/ChangeLog	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/ChangeLog	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,39 @@
+2003-03-06  Scott Furman <sfurman@rosum.com>
+
+        Initial port of eCos to OpenRISC Reference Platform (ORP)
+
+//===========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//===========================================================================
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/cdl/hal_openrisc_orp.cdl ./ecos-3.0/packages/hal/openrisc/orp/v3_0/cdl/hal_openrisc_orp.cdl
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/cdl/hal_openrisc_orp.cdl	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/cdl/hal_openrisc_orp.cdl	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,335 @@
+# ====================================================================
+#
+#      hal_openrisc_orp.cdl
+#
+#      OpenRISC Reference Platform (ORP) HAL package configuration data
+#
+# ====================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+# ====================================================================
+######DESCRIPTIONBEGIN####
+#
+# Author(s):      sfurman
+# Contributors:
+# Date:           2003-01-20
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_HAL_OPENRISC_ORP {
+    display  "OpenRISC Reference Platform"
+    parent        CYGPKG_HAL_OPENRISC
+    include_dir   cyg/hal
+    hardware
+    description   "
+           The ORP HAL package should be used when targetting the
+           OpenRISC Reference Platform."
+
+    compile       hal_diag.c hal_aux.c
+
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS
+    implements    CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+    implements    CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT
+
+    define_proc {
+        puts $::cdl_system_header "#define CYGBLD_HAL_TARGET_H   <pkgconf/hal_openrisc.h>"
+        puts $::cdl_system_header "#define CYGBLD_HAL_PLATFORM_H <pkgconf/hal_openrisc_orp.h>"
+    }
+
+    cdl_component CYG_HAL_STARTUP {
+        display       "Startup type"
+        flavor        data
+        legal_values  {"RAM" "ROM"}
+        default_value {"ROM"}
+        no_define
+        define -file system.h CYG_HAL_STARTUP
+        description   "
+            Selects whether code initially runs from ROM or RAM.  In the case of ROM startup,
+            it's possible for the code to be copied into RAM and executed there."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD {
+        display       "Diagnostic serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200 230400 460800 921600
+        default_value 115200
+        description   "
+            This option selects the baud rate used for the diagnostic console.
+            Note: this should match the value chosen for the GDB port if the
+            diagnostic and GDB port are the same.
+            Note: very high baud rates are useful during simulation."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_BAUD {
+        display       "GDB serial port baud rate"
+        flavor        data
+        legal_values  9600 19200 38400 57600 115200 230400 460800 921600
+        default_value 115200
+        description   "
+            This option controls the baud rate used for the GDB connection.
+            Note: very high baud rates are useful during simulation."
+    }
+
+    # Real-time clock/counter specifics
+    cdl_component CYGNUM_HAL_RTC_CONSTANTS {
+        display       "Real-time clock constants."
+        flavor        none
+    
+        cdl_option CYGNUM_HAL_RTC_NUMERATOR {
+            display       "Real-time clock numerator"
+            flavor        data
+            calculated    1000000000
+        }
+        cdl_option CYGNUM_HAL_RTC_DENOMINATOR {
+            display       "Real-time clock denominator"
+            flavor        data
+            calculated    100
+        }
+        cdl_option CYGNUM_HAL_RTC_PERIOD {
+            display       "Real-time clock period"
+            flavor        data
+# sfurman: Probably ought be "calculated" - not "default_value"
+# However, it is handy to override this value during simulator-based testing
+            default_value {CYGHWR_HAL_OPENRISC_CPU_FREQ * 1000000 / CYGNUM_HAL_RTC_DENOMINATOR}
+            description   "
+                The tick timer facility is used
+                to drive the eCos kernel RTC. The count register
+                increments at the CPU clock speed.  By default, 100 Hz"
+        }
+    }
+
+    cdl_option CYGBLD_BUILD_GDB_STUBS {
+        display "Build GDB stub ROM image"
+        default_value 0
+        parent CYGBLD_GLOBAL_OPTIONS
+        requires { CYG_HAL_STARTUP == "ROM" }
+        requires CYGSEM_HAL_ROM_MONITOR
+        requires CYGBLD_BUILD_COMMON_GDB_STUBS
+        requires CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+        requires ! CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+        requires ! CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+        requires ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+        requires ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+        no_define
+        description "
+                This option enables the building of the GDB stubs for the
+                board. The common HAL controls takes care of most of the
+                build process, but the final conversion from ELF image to
+                binary data is handled by the platform CDL, allowing
+                relocation of the data if necessary."
+
+        make -priority 320 {
+            <PREFIX>/bin/gdb_module.bin : <PREFIX>/bin/gdb_module.img
+            $(OBJCOPY) -O binary $< $@
+        }
+    }
+
+
+    cdl_option CYGNUM_HAL_BREAKPOINT_LIST_SIZE {
+        display       "Number of breakpoints supported by the HAL."
+        flavor        data
+        default_value 25
+        description   "
+            This option determines the number of breakpoints supported by the HAL."
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS {
+        display      "Number of communication channels on the board"
+        flavor       data
+        default_value  1
+    }
+
+    cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL {
+        display          "Debug serial port"
+        active_if        CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE
+        flavor data
+        legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+        default_value    0
+        description      "
+           The ORP platform has at least one serial port, but it can potentially have several.
+           This option chooses which port will be used to connect to a host
+           running GDB."
+    }
+ 
+     cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL {
+        display          "Diagnostic serial port"
+        active_if        CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+        flavor data
+        legal_values     0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+        default_value    0
+        description      "
+           The ORP platform has at least one serial port, but it can potentially have several.
+           This option chooses which port will be used for diagnostic output."
+     }
+
+    cdl_component CYGBLD_GLOBAL_OPTIONS {
+        display "Global build options"
+        flavor  none
+        description   "
+            Global build options including control over
+            compiler flags, linker flags and choice of toolchain."
+
+
+        parent  CYGPKG_NONE
+
+        cdl_option CYGBLD_GLOBAL_COMMAND_PREFIX {
+            display "Global command prefix"
+            flavor  data
+            no_define
+            default_value { "or32-elf" }
+            description "
+                This option specifies the command prefix used when
+                invoking the build tools."
+        }
+
+        cdl_option CYGBLD_GLOBAL_CFLAGS {
+            display "Global compiler flags"
+            flavor  data
+            no_define
+            default_value { "-msoft-float -Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -fno-omit-frame-pointer -fno-rtti -fno-exceptions -fvtable-gc -finit-priority" }
+            description   "
+                This option controls the global compiler flags which
+                are used to compile all packages by
+                default. Individual packages may define
+                options which override these global flags."
+        }
+
+        cdl_option CYGBLD_GLOBAL_LDFLAGS {
+            display "Global linker flags"
+            flavor  data
+            no_define
+            default_value { "-msoft-float -g -nostdlib -Wl,--gc-sections -Wl,-static" }
+            description   "
+                This option controls the global linker flags. Individual
+                packages may define options which override these global flags."
+        }
+    }
+
+    cdl_component CYGHWR_MEMORY_LAYOUT {
+        display "Memory layout"
+        flavor data
+        no_define
+        calculated { CYG_HAL_STARTUP == "RAM" ? "openrisc_orp_ram" : \
+                                                "openrisc_orp_rom" }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_LDI {
+            display "Memory layout linker script fragment"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_LDI
+            calculated { CYG_HAL_STARTUP == "RAM" ? "<pkgconf/mlt_openrisc_orp_ram.ldi>" : \
+                                                    "<pkgconf/mlt_openrisc_orp_rom.ldi>" }
+        }
+
+        cdl_option CYGHWR_MEMORY_LAYOUT_H {
+            display "Memory layout header file"
+            flavor data
+            no_define
+            define -file system.h CYGHWR_MEMORY_LAYOUT_H
+            calculated { CYG_HAL_STARTUP == "RAM" ? "<pkgconf/mlt_openrisc_orp_ram.h>" : \
+                                                    "<pkgconf/mlt_openrisc_orp_rom.h>" }
+        }
+    }
+
+    cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
+        display       "Work with a ROM monitor"
+        flavor        booldata
+        legal_values  { "Generic" "CygMon" "GDB_stubs" }
+        default_value { CYG_HAL_STARTUP == "RAM" ? "CygMon" : 0 }
+        parent        CYGPKG_HAL_ROM_MONITOR
+        requires      { CYG_HAL_STARTUP == "RAM" }
+        description   "
+            Support can be enabled for three different varieties of ROM monitor.
+            This support changes various eCos semantics such as the encoding
+            of diagnostic output, or the overriding of hardware interrupt
+            vectors.
+            Firstly there is \"Generic\" support which prevents the HAL
+            from overriding the hardware vectors that it does not use, to
+            instead allow an installed ROM monitor to handle them. This is
+            the most basic support which is likely to be common to most
+            implementations of ROM monitor.
+            \"CygMon\" provides support for the Cygnus ROM Monitor.
+            And finally, \"GDB_stubs\" provides support when GDB stubs are
+            included in the ROM monitor or boot ROM."
+    }
+
+    cdl_option CYGSEM_HAL_ROM_MONITOR {
+        display       "Behave as a ROM monitor"
+        flavor        bool
+        default_value 1
+        parent        CYGPKG_HAL_ROM_MONITOR
+        requires      { CYG_HAL_STARTUP == "ROM" }
+        description   "
+            Enable this option if this program is to be used as a ROM monitor,
+            i.e. applications will be loaded into RAM on the board, and this
+            ROM monitor may process exceptions or interrupts generated from the
+            application. This enables features such as utilizing a separate
+            interrupt stack when exceptions are generated."
+    }
+
+    cdl_component CYGPKG_REDBOOT_HAL_OPTIONS {
+        display       "Redboot HAL options"
+        flavor        none
+        no_define
+        parent        CYGPKG_REDBOOT
+        active_if     CYGPKG_REDBOOT
+        description   "
+            This option lists the target's requirements for a valid Redboot
+            configuration."
+
+        cdl_option CYGBLD_BUILD_REDBOOT_BIN {
+            display       "Build Redboot ROM binary image"
+            active_if     CYGBLD_BUILD_REDBOOT
+            default_value 1
+            no_define
+            description "This option enables the conversion of the Redboot ELF
+                         image to a binary image suitable for ROM programming."
+    
+            compile -library=libextras.a
+    
+            make -priority 325 {
+                <PREFIX>/bin/redboot.srec : <PREFIX>/bin/redboot.elf
+                $(OBJCOPY) --strip-all $< $(@:.srec=.img)
+                $(OBJCOPY) -O srec $< $@
+            }
+        }
+    }
+
+    define_proc {
+        puts $cdl_header "#define CYGHWR_HAL_VSR_TABLE    0"
+        puts $cdl_header "#define CYGHWR_HAL_VIRTUAL_VECTOR_TABLE 0xF00"
+    }
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/doc/README.html ./ecos-3.0/packages/hal/openrisc/orp/v3_0/doc/README.html
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/doc/README.html	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/doc/README.html	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,13 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+                           
+  <meta http-equiv="refresh"
+ content="1;URL=&quot;../../../arch/current/doc/README.html">
+  <title>README - eCos OpenRISC Port</title>
+    
+</head>
+<body>
+ Redirecting to OpenRISC eCos README...              
+</body>
+</html>
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/hal_diag.h ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/hal_diag.h
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/hal_diag.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/hal_diag.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,69 @@
+#ifndef CYGONCE_HAL_HAL_DIAG_H
+#define CYGONCE_HAL_HAL_DIAG_H
+
+//=============================================================================
+//
+//      hal_diag.h
+//
+//      HAL Support for Kernel Diagnostic Routines
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   nickg
+// Contributors:nickg
+// Date:        2003-02-28
+// Purpose:     HAL Support for Kernel Diagnostic Routines
+// Description: Diagnostic routines for use during kernel development.
+// Usage:       #include <cyg/hal/hal_diag.h>
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#include <pkgconf/hal.h>
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/hal/hal_if.h>
+
+#define HAL_DIAG_INIT() hal_if_diag_init()
+#define HAL_DIAG_WRITE_CHAR(_c_) hal_if_diag_write_char(_c_)
+#define HAL_DIAG_READ_CHAR(_c_) hal_if_diag_read_char(&_c_)
+
+//-----------------------------------------------------------------------------
+// end of hal_diag.h
+#endif // CYGONCE_HAL_HAL_DIAG_H
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/mc.h ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/mc.h
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/mc.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/mc.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,143 @@
+//==========================================================================
+//
+//      mc.h
+//
+//      OpenCores.org memory controller definitions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: Marko Mlinar
+// Date:         2003-01-17
+// Purpose:      Define OpenRISC architecture special-purpose registers
+// Usage:        #include <cyg/hal/hal_arch.h>
+//              
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+/* Prototypes */
+#ifndef __MC_H
+#define __MC_H
+
+#define N_CE        (8)
+
+#define MC_CSR      (0x00)
+#define MC_POC      (0x04)
+#define MC_BA_MASK  (0x08)
+#define MC_CSC(i)   (0x10 + (i) * 8)
+#define MC_TMS(i)   (0x14 + (i) * 8)
+
+#define MC_ADDR_SPACE (MC_CSC(N_CE))
+
+/* POC register field definition */
+#define MC_POC_EN_BW_OFFSET     0
+#define MC_POC_EN_BW_WIDTH      2
+#define MC_POC_EN_MEMTYPE_OFFSET        2
+#define MC_POC_EN_MEMTYPE_WIDTH 2
+
+/* CSC register field definition */
+#define MC_CSC_EN_OFFSET        0
+#define MC_CSC_MEMTYPE_OFFSET   1
+#define MC_CSC_MEMTYPE_WIDTH    2
+#define MC_CSC_BW_OFFSET        4
+#define MC_CSC_BW_WIDTH         2
+#define MC_CSC_MS_OFFSET        6
+#define MC_CSC_MS_WIDTH         2
+#define MC_CSC_WP_OFFSET        8
+#define MC_CSC_BAS_OFFSET       9
+#define MC_CSC_KRO_OFFSET       10
+#define MC_CSC_PEN_OFFSET       11
+#define MC_CSC_SEL_OFFSET       16
+#define MC_CSC_SEL_WIDTH        8
+
+#define MC_CSC_MEMTYPE_SDRAM  0
+#define MC_CSC_MEMTYPE_SSRAM  1
+#define MC_CSC_MEMTYPE_ASYNC  2
+#define MC_CSC_MEMTYPE_SYNC   3
+
+#define MC_CSR_VALID            0xFF000703LU
+#define MC_POC_VALID            0x0000000FLU
+#define MC_BA_MASK_VALID        0x000000FFLU
+#define MC_CSC_VALID            0x00FF0FFFLU
+#define MC_TMS_SDRAM_VALID      0x0FFF83FFLU
+#define MC_TMS_SSRAM_VALID      0x00000000LU
+#define MC_TMS_ASYNC_VALID      0x03FFFFFFLU
+#define MC_TMS_SYNC_VALID       0x01FFFFFFLU
+#define MC_TMS_VALID            0xFFFFFFFFLU /* reg test compat. */
+
+/* TMS register field definition SDRAM */
+#define MC_TMS_SDRAM_TRFC_OFFSET        24
+#define MC_TMS_SDRAM_TRFC_WIDTH         4
+#define MC_TMS_SDRAM_TRP_OFFSET         20
+#define MC_TMS_SDRAM_TRP_WIDTH          4
+#define MC_TMS_SDRAM_TRCD_OFFSET        17
+#define MC_TMS_SDRAM_TRCD_WIDTH         4
+#define MC_TMS_SDRAM_TWR_OFFSET         15
+#define MC_TMS_SDRAM_TWR_WIDTH          2
+#define MC_TMS_SDRAM_WBL_OFFSET         9
+#define MC_TMS_SDRAM_OM_OFFSET          7
+#define MC_TMS_SDRAM_OM_WIDTH           2
+#define MC_TMS_SDRAM_CL_OFFSET          4
+#define MC_TMS_SDRAM_CL_WIDTH           3
+#define MC_TMS_SDRAM_BT_OFFSET          3
+#define MC_TMS_SDRAM_BL_OFFSET          0
+#define MC_TMS_SDRAM_BL_WIDTH           3
+
+/* TMS register field definition ASYNC */
+#define MC_TMS_ASYNC_TWWD_OFFSET        20
+#define MC_TMS_ASYNC_TWWD_WIDTH         6
+#define MC_TMS_ASYNC_TWD_OFFSET         16
+#define MC_TMS_ASYNC_TWD_WIDTH          4
+#define MC_TMS_ASYNC_TWPW_OFFSET        12
+#define MC_TMS_ASYNC_TWPW_WIDTH         4
+#define MC_TMS_ASYNC_TRDZ_OFFSET        8
+#define MC_TMS_ASYNC_TRDZ_WIDTH         4
+#define MC_TMS_ASYNC_TRDV_OFFSET        0
+#define MC_TMS_ASYNC_TRDV_WIDTH         8
+
+/* TMS register field definition SYNC  */
+#define MC_TMS_SYNC_TTO_OFFSET          16
+#define MC_TMS_SYNC_TTO_WIDTH           9
+#define MC_TMS_SYNC_TWR_OFFSET          12
+#define MC_TMS_SYNC_TWR_WIDTH           4
+#define MC_TMS_SYNC_TRDZ_OFFSET         8
+#define MC_TMS_SYNC_TRDZ_WIDTH          4
+#define MC_TMS_SYNC_TRDV_OFFSET         0
+#define MC_TMS_SYNC_TRDV_WIDTH          8
+
+#endif
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.h ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.h
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,37 @@
+// eCos memory layout
+
+#ifndef __ASSEMBLER__
+#include <cyg/infra/cyg_type.h>
+#include <stddef.h>
+
+#endif
+#define CYGMEM_REGION_ram (0)
+#define CYGMEM_REGION_ram_SIZE (0x00400000)
+#define CYGMEM_REGION_ram_ATTR (CYGMEM_REGION_ATTR_R | CYGMEM_REGION_ATTR_W)
+#define CYGMEM_REGION_rom (0xf0000000)
+#define CYGMEM_REGION_rom_SIZE (0x10000000)
+#define CYGMEM_REGION_rom_ATTR (CYGMEM_REGION_ATTR_R)
+
+#if 0
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vectors) [];
+#endif
+#define CYGMEM_SECTION_reserved_vectors (CYG_LABEL_NAME (__reserved_vectors))
+#define CYGMEM_SECTION_reserved_vectors_SIZE (0x3000)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vsr_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_vsr_table (CYG_LABEL_NAME (__reserved_vsr_table))
+#define CYGMEM_SECTION_reserved_vsr_table_SIZE (0x200)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_virtual_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_virtual_table (CYG_LABEL_NAME (__reserved_virtual_table))
+#define CYGMEM_SECTION_reserved_virtual_table_SIZE (0x100)
+#endif
+
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__heap1) [];
+#endif
+#define CYGMEM_SECTION_heap1 (CYG_LABEL_NAME (__heap1))
+#define CYGMEM_SECTION_heap1_SIZE (CYGMEM_REGION_ram_SIZE - (size_t) CYG_LABEL_NAME (__heap1))
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.ldi ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.ldi
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.ldi	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_ram.ldi	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,25 @@
+// eCos memory layout
+
+#include <cyg/infra/cyg_type.inc>
+
+MEMORY
+{
+    ram : ORIGIN = 0x00000000, LENGTH = 0x00400000
+    rom : ORIGIN = 0xF0000000, LENGTH = 0x10000000
+}
+
+SECTIONS
+{
+    SECTIONS_BEGIN
+    SECTION_vectors (ram, 0x00000100, LMA_EQ_VMA)
+    SECTION_text (ram, 0x00008000, LMA_EQ_VMA)
+    SECTION_fini (ram, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata1 (ram, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_rodata (ram, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_fixup (ram, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_gcc_except_table (ram, ALIGN (0x1), LMA_EQ_VMA)
+    SECTION_data (ram, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_bss (ram, ALIGN (0x10), LMA_EQ_VMA)
+    CYG_LABEL_DEFN(__heap1) = ALIGN (0x8);
+    SECTIONS_END
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.h ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.h
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,37 @@
+// eCos memory layout
+
+#ifndef __ASSEMBLER__
+#include <cyg/infra/cyg_type.h>
+#include <stddef.h>
+
+#endif
+#define CYGMEM_REGION_ram (0)
+#define CYGMEM_REGION_ram_SIZE (0x00400000)
+#define CYGMEM_REGION_ram_ATTR (CYGMEM_REGION_ATTR_R | CYGMEM_REGION_ATTR_W)
+#define CYGMEM_REGION_rom (0xf0000000)
+#define CYGMEM_REGION_rom_SIZE (0x10000000)
+#define CYGMEM_REGION_rom_ATTR (CYGMEM_REGION_ATTR_R)
+
+#if 0
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vectors) [];
+#endif
+#define CYGMEM_SECTION_reserved_vectors (CYG_LABEL_NAME (__reserved_vectors))
+#define CYGMEM_SECTION_reserved_vectors_SIZE (0x3000)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_vsr_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_vsr_table (CYG_LABEL_NAME (__reserved_vsr_table))
+#define CYGMEM_SECTION_reserved_vsr_table_SIZE (0x200)
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__reserved_virtual_table) [];
+#endif
+#define CYGMEM_SECTION_reserved_virtual_table (CYG_LABEL_NAME (__reserved_virtual_table))
+#define CYGMEM_SECTION_reserved_virtual_table_SIZE (0x100)
+#endif
+
+#ifndef __ASSEMBLER__
+extern char CYG_LABEL_NAME (__heap1) [];
+#endif
+#define CYGMEM_SECTION_heap1 (CYG_LABEL_NAME (__heap1))
+#define CYGMEM_SECTION_heap1_SIZE (CYGMEM_REGION_ram_SIZE - (size_t) CYG_LABEL_NAME (__heap1))
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.ldi ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.ldi
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.ldi	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/pkgconf/mlt_openrisc_orp_rom.ldi	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,25 @@
+// eCos memory layout
+
+#include <cyg/infra/cyg_type.inc>
+
+MEMORY
+{
+    ram : ORIGIN = 0x00000000, LENGTH = 0x00400000
+    rom : ORIGIN = 0xF0000000, LENGTH = 0x10000000
+}
+
+SECTIONS
+{
+    SECTIONS_BEGIN
+    SECTION_vectors (rom, 0xF0000100, LMA_EQ_VMA)
+    SECTION_text (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_fini (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_rodata1 (rom, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_rodata (rom, ALIGN (0x8), LMA_EQ_VMA)
+    SECTION_fixup (rom, ALIGN (0x4), LMA_EQ_VMA)
+    SECTION_gcc_except_table (rom, ALIGN (0x1), LMA_EQ_VMA)
+    SECTION_data (ram, 0x1000, FOLLOWING (.gcc_except_table))
+    SECTION_bss (ram, ALIGN (0x10), LMA_EQ_VMA)
+    CYG_LABEL_DEFN(__heap1) = ALIGN (0x8);
+    SECTIONS_END
+}
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/platform.inc ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/platform.inc
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/platform.inc	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/platform.inc	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,116 @@
+##==========================================================================
+##
+##      platform.inc
+##
+##      OpenRISC Reference Platform (ORP) board-specific defines
+##
+##==========================================================================
+#####ECOSGPLCOPYRIGHTBEGIN####
+## -------------------------------------------
+## This file is part of eCos, the Embedded Configurable Operating System.
+## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+##
+## eCos is free software; you can redistribute it and/or modify it under
+## the terms of the GNU General Public License as published by the Free
+## Software Foundation; either version 2 or (at your option) any later version.
+##
+## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+## WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License along
+## with eCos; if not, write to the Free Software Foundation, Inc.,
+## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+##
+## As a special exception, if other files instantiate templates or use macros
+## or inline functions from this file, or you compile this file and link it
+## with other works to produce a work based on this file, this file does not
+## by itself cause the resulting work to be covered by the GNU General Public
+## License. However the source code for this file must still be made available
+## in accordance with section (3) of the GNU General Public License.
+##
+## This exception does not invalidate any other reasons why a work based on
+## this file might be covered by the GNU General Public License.
+##
+## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+## at http://sources.redhat.com/ecos/ecos-license/
+## -------------------------------------------
+#####ECOSGPLCOPYRIGHTEND####
+##==========================================================================
+#######DESCRIPTIONBEGIN####
+##
+## Author(s):    sfurman
+## Contributors: 
+## Date:         2003-01-20
+## Purpose:      ORP platform-specific init
+## Description:  This file handles the post-reset hardware initialization
+##               that is specific to the ORP platform (but not specific to
+##               the OpenRISC processor itself).  So far, it only
+##               initializes the memory controller so as to map Flash and
+##               SDRAM into the memory space.
+##
+######DESCRIPTIONEND####
+##
+##==========================================================================
+
+#ifndef _PLATFORM_INC_
+#define _PLATFORM_INC_
+
+#include <cyg/hal/mc.h>
+#include CYGHWR_MEMORY_LAYOUT_H
+
+/* Memory organization */
+#define SDRAM_BASE_ADD  CYGMEM_REGION_ram
+#define FLASH_BASE_ADD  CYGMEM_REGION_rom
+
+/* Memory Controller's base address */
+#define MC_BASE_ADD     0x93000000
+
+/* Memory controller initialize magic values */
+#define MC_CSR_VAL      0x0B000300
+#define MC_MASK_VAL     0x000003f0
+#define FLASH_TMS_VAL   0x00000103
+#define SDRAM_TMS_VAL   0x19220057
+#define FLASH_CSC_VAL   (((FLASH_BASE_ADD>>6) & 0x07ff0000) | 0x0025)
+#define SDRAM_CSC_VAL   (((SDRAM_BASE_ADD>>6) & 0x07ff0000) | 0x0411)
+                
+
+        # Platform-specific, post-reset hardware initialization
+        .macro  hal_hardware_init
+init_mc:
+        load32i r3,MC_BASE_ADD
+
+        # Program Flash chip-select 
+        load32i r5,FLASH_CSC_VAL
+        l.sw    MC_CSC(0)(r3),r5
+
+        # Init flash timing 
+        load32i r5,FLASH_TMS_VAL
+        l.sw    MC_TMS(0)(r3),r5
+
+        # Start decoding memory addresses to generate chip-selects
+        l.addi  r5,r0,MC_MASK_VAL
+        l.sw    MC_BA_MASK(r3),r5
+
+        load32i r5, MC_CSR_VAL
+        l.sw    MC_CSR(r3),r5
+
+        # Init DRAM timing 
+        load32i r5, SDRAM_TMS_VAL
+        l.sw    MC_TMS(1)(r3),r5
+
+        # Program DRAM chip-select 
+        load32i r5, SDRAM_CSC_VAL
+        l.sw    MC_CSC(1)(r3),r5
+
+        # Wait for SDRAM
+        l.addi  r3,r0,0x1000
+1:      l.sfeqi r3,0
+        l.bnf   1b
+        l.addi  r3,r3,-1
+        .endm
+        
+#endif /* ifndef _PLATFORM_INC_ */
+
+#undef CYGIMP_FORCE_INTERRUPT_HANDLING_CODE_IN_RAM
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_intr.h ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_intr.h
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_intr.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_intr.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,80 @@
+#ifndef CYGONCE_HAL_PLF_INTR_H
+#define CYGONCE_HAL_PLF_INTR_H
+
+//==========================================================================
+//
+//      plf_intr.h
+//
+//      OpenRISC ORP platform-specific interrupt definitions
+//
+//==========================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//==========================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):    sfurman
+// Contributors: 
+// Date:         2002-02-28
+// Purpose:      Define platform specific interrupt support
+//              
+// Usage:
+//              #include <cyg/hal/plf_intr.h>
+//              ...
+//              
+//
+//####DESCRIPTIONEND####
+//
+//==========================================================================
+
+
+//----------------------------------------------------------------------------
+// Reset.
+
+// This function should perform a hardware reset
+// For now, it does nothing.
+#define HAL_PLATFORM_RESET() CYG_EMPTY_STATEMENT
+
+// If no HW reset exists, jump to this location instead.
+// The current value is the ROM reset entry point.
+#define HAL_PLATFORM_RESET_ENTRY 0xF0001000
+
+// Define PIC interrupt numbers for peripherals
+#define CYGNUM_HAL_INTERRUPT_SERIAL_CONSOLE    CYGNUM_HAL_INTERRUPT_2
+#define CYGNUM_HAL_INTERRUPT_SERIAL_DEBUGGER   CYGNUM_HAL_INTERRUPT_3
+
+
+//--------------------------------------------------------------------------
+#endif // ifndef CYGONCE_HAL_PLF_INTR_H
+// End of plf_intr.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_stub.h ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_stub.h
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_stub.h	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/include/plf_stub.h	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,69 @@
+//=============================================================================
+//
+//      plf_stub.h
+//
+//      Platform header for GDB stub support.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   sfurman
+// Contributors:jskov
+// Date:        2003-02-28
+// Purpose:     Platform HAL stub support for PowerPC/VIPER board.
+// Usage:       #include <cyg/hal/plf_stub.h>
+//              
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#ifndef CYGONCE_HAL_PLF_STUB_H
+#define CYGONCE_HAL_PLF_STUB_H
+
+#include <pkgconf/hal.h>
+
+#ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+
+#include <cyg/infra/cyg_type.h>         // CYG_UNUSED_PARAM
+#include <cyg/hal/openrisc_stub.h>
+
+//----------------------------------------------------------------------------
+// Stub initializer.
+
+#endif // ifdef CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+//-----------------------------------------------------------------------------
+#endif // CYGONCE_HAL_PLF_STUB_H
+// End of plf_stub.h
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_aux.c ./ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_aux.c
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_aux.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_aux.c	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,67 @@
+//=============================================================================
+//
+//      hal_aux.c
+//
+//      HAL auxiliary objects and code; per platform
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+// Copyright (C) 2002 Gary Thomas
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   hmt
+// Contributors:hmt
+// Date:        2003-02-28
+// Purpose:     HAL aux objects: startup tables.
+// Description: Tables for per-platform initialization
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#include <cyg/hal/hal_if.h>
+
+//--------------------------------------------------------------------------
+// Platform init code.
+void
+hal_platform_init(void)
+{
+    // Basic hardware initialization has already taken place
+
+    hal_if_init();   // Initialize logical I/O layer (virtual vector support)
+}
+
+// EOF hal_aux.c
+
diff -NaurbBw /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_diag.c ./ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_diag.c
--- /opt/ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_diag.c	1969-12-31 16:00:00.000000000 -0800
+++ ./ecos-3.0/packages/hal/openrisc/orp/v3_0/src/hal_diag.c	2009-09-16 14:06:24.000000000 -0700
@@ -0,0 +1,594 @@
+//=============================================================================
+//
+//      hal_diag.c
+//
+//      Simple polling driver for the 16c550c serial controller(s) in the ORP,
+//      to be used for diagnostic I/O and gdb remote debugging.
+//
+//=============================================================================
+//####ECOSGPLCOPYRIGHTBEGIN####
+// -------------------------------------------
+// This file is part of eCos, the Embedded Configurable Operating System.
+// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
+//
+// eCos is free software; you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation; either version 2 or (at your option) any later version.
+//
+// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with eCos; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+//
+// As a special exception, if other files instantiate templates or use macros
+// or inline functions from this file, or you compile this file and link it
+// with other works to produce a work based on this file, this file does not
+// by itself cause the resulting work to be covered by the GNU General Public
+// License. However the source code for this file must still be made available
+// in accordance with section (3) of the GNU General Public License.
+//
+// This exception does not invalidate any other reasons why a work based on
+// this file might be covered by the GNU General Public License.
+//
+// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
+// at http://sources.redhat.com/ecos/ecos-license/
+// -------------------------------------------
+//####ECOSGPLCOPYRIGHTEND####
+//=============================================================================
+//#####DESCRIPTIONBEGIN####
+//
+// Author(s):   sfurman
+// Contributors:dmoseley
+// Date:        2003-02-28
+// Description: Simple polling driver for the 16c550c serial controller(s) in the ORP,
+//              to be used for diagnostic I/O and gdb remote debugging.
+//      
+//
+//####DESCRIPTIONEND####
+//
+//=============================================================================
+
+#include <pkgconf/hal.h>
+#include <pkgconf/system.h>
+#include CYGBLD_HAL_PLATFORM_H
+
+#include <cyg/hal/hal_arch.h>           // SAVE/RESTORE GP macros
+#include <cyg/hal/hal_io.h>             // IO macros
+#include <cyg/hal/hal_if.h>             // interface API
+#include <cyg/hal/hal_intr.h>           // HAL_ENABLE/MASK/UNMASK_INTERRUPTS
+#include <cyg/hal/hal_misc.h>           // Helper functions
+#include <cyg/hal/drv_api.h>            // CYG_ISR_HANDLED
+#include <cyg/infra/cyg_ass.h>          // assertion macros
+
+//-----------------------------------------------------------------------------
+// Base addresses for each 16550 UART in the system
+#define SERIAL_16550_CONSOLE_BASE_ADDR    0x90000000
+#define SERIAL_16550_DEBUGGER_BASE_ADDR   0x90000008
+
+//-----------------------------------------------------------------------------
+// Define the 16550C serial registers.
+#define SER_16550_RBR 0x00   // receiver buffer register, read, dlab = 0
+#define SER_16550_THR 0x00   // transmitter holding register, write, dlab = 0
+#define SER_16550_DLL 0x00   // divisor latch (LS), read/write, dlab = 1
+#define SER_16550_IER 0x01   // interrupt enable register, read/write, dlab = 0
+#define SER_16550_DLM 0x01   // divisor latch (MS), read/write, dlab = 1
+#define SER_16550_IIR 0x02   // interrupt identification reg, read, dlab = 0
+#define SER_16550_FCR 0x02   // fifo control register, write, dlab = 0
+#define SER_16550_AFR 0x02   // alternate function reg, read/write, dlab = 1
+#define SER_16550_LCR 0x03   // line control register, read/write
+#define SER_16550_MCR 0x04   // modem control register, read/write
+#define SER_16550_LSR 0x05   // line status register, read
+#define SER_16550_MSR 0x06   // modem status register, read
+#define SER_16550_SCR 0x07   // scratch pad register
+
+// The interrupt enable register bits.
+#define SIO_IER_ERDAI   0x01            // enable received data available irq
+#define SIO_IER_ETHREI  0x02            // enable THR empty interrupt
+#define SIO_IER_ELSI    0x04            // enable receiver line status irq
+#define SIO_IER_EMSI    0x08            // enable modem status interrupt
+
+// The interrupt identification register bits.
+#define SIO_IIR_IP      0x01            // 0 if interrupt pending
+#define SIO_IIR_ID_MASK 0x0e            // mask for interrupt ID bits
+
+// The line status register bits.
+#define SIO_LSR_DR      0x01            // data ready
+#define SIO_LSR_OE      0x02            // overrun error
+#define SIO_LSR_PE      0x04            // parity error
+#define SIO_LSR_FE      0x08            // framing error
+#define SIO_LSR_BI      0x10            // break interrupt
+#define SIO_LSR_THRE    0x20            // transmitter holding register empty
+#define SIO_LSR_TEMT    0x40            // transmitter register empty
+#define SIO_LSR_ERR     0x80            // any error condition
+
+// The modem status register bits.
+#define SIO_MSR_DCTS  0x01              // delta clear to send
+#define SIO_MSR_DDSR  0x02              // delta data set ready
+#define SIO_MSR_TERI  0x04              // trailing edge ring indicator
+#define SIO_MSR_DDCD  0x08              // delta data carrier detect
+#define SIO_MSR_CTS   0x10              // clear to send
+#define SIO_MSR_DSR   0x20              // data set ready
+#define SIO_MSR_RI    0x40              // ring indicator
+#define SIO_MSR_DCD   0x80              // data carrier detect
+
+// The line control register bits.
+#define SIO_LCR_WLS0   0x01             // word length select bit 0
+#define SIO_LCR_WLS1   0x02             // word length select bit 1
+#define SIO_LCR_STB    0x04             // number of stop bits
+#define SIO_LCR_PEN    0x08             // parity enable
+#define SIO_LCR_EPS    0x10             // even parity select
+#define SIO_LCR_SP     0x20             // stick parity
+#define SIO_LCR_SB     0x40             // set break
+#define SIO_LCR_DLAB   0x80             // divisor latch access bit
+
+// The FIFO control register
+#define SIO_FCR_FCR0   0x01             // enable xmit and rcvr fifos
+#define SIO_FCR_FCR1   0x02             // clear RCVR FIFO
+#define SIO_FCR_FCR2   0x04             // clear XMIT FIFO
+
+/////////////////////////////////////////
+// Interrupt Enable Register
+#define IER_RCV 0x01
+#define IER_XMT 0x02
+#define IER_LS  0x04
+#define IER_MS  0x08
+
+// Line Control Register
+#define LCR_WL5 0x00    // Word length
+#define LCR_WL6 0x01
+#define LCR_WL7 0x02
+#define LCR_WL8 0x03
+#define LCR_SB1 0x00    // Number of stop bits
+#define LCR_SB1_5 0x04  // 1.5 -> only valid with 5 bit words
+#define LCR_SB2 0x04
+#define LCR_PN  0x00    // Parity mode - none
+#define LCR_PE  0x0C    // Parity mode - even
+#define LCR_PO  0x08    // Parity mode - odd
+#define LCR_PM  0x28    // Forced "mark" parity
+#define LCR_PS  0x38    // Forced "space" parity
+#define LCR_DL  0x80    // Enable baud rate latch
+
+// Line Status Register
+#define LSR_RSR 0x01
+#define LSR_THE 0x20
+
+// Modem Control Register
+#define MCR_DTR 0x01
+#define MCR_RTS 0x02
+#define MCR_INT 0x08   // Enable interrupts
+
+// Interrupt status register
+#define ISR_None             0x01
+#define ISR_Rx_Line_Status   0x06
+#define ISR_Rx_Avail         0x04
+#define ISR_Rx_Char_Timeout  0x0C
+#define ISR_Tx_Empty         0x02
+#define ISR_Modem_Status     0x00
+
+// FIFO control register
+#define FCR_ENABLE     0x01
+#define FCR_CLEAR_RCVR 0x02
+#define FCR_CLEAR_XMIT 0x04
+
+// Assume the UART is driven 1/16 CPU frequency
+#define UART_CLOCK    ((CYGHWR_HAL_OPENRISC_CPU_FREQ)*1.0e6/16.0)
+
+#define DIVISOR(baud) ((int)((UART_CLOCK)/baud))
+
+#ifdef CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD
+#define CYG_DEV_SERIAL_BAUD_DIVISOR   \
+    DIVISOR(CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD)
+#else
+#error Missing/incorrect serial baud rate defined - CDL error?
+#endif
+
+
+//-----------------------------------------------------------------------------
+typedef struct {
+    cyg_uint8* base;
+    cyg_int32 msec_timeout;
+    int isr_vector;
+} channel_data_t;
+
+static channel_data_t channels[] = {
+    { (cyg_uint8*)SERIAL_16550_CONSOLE_BASE_ADDR,
+      1000,
+      CYGNUM_HAL_INTERRUPT_SERIAL_CONSOLE
+    },
+    { (cyg_uint8*)SERIAL_16550_DEBUGGER_BASE_ADDR,
+      1000,
+      CYGNUM_HAL_INTERRUPT_SERIAL_DEBUGGER
+    }
+};
+
+//-----------------------------------------------------------------------------
+// Set the baud rate
+
+static void
+cyg_hal_plf_serial_set_baud(cyg_uint8* port, cyg_uint16 baud_divisor)
+{
+    cyg_uint8 _lcr;
+
+    HAL_READ_UINT8(port+SER_16550_LCR, _lcr);
+    _lcr |= LCR_DL;
+    HAL_WRITE_UINT8(port+SER_16550_LCR, _lcr);
+
+    HAL_WRITE_UINT8(port+SER_16550_DLM, baud_divisor >> 8);
+    HAL_WRITE_UINT8(port+SER_16550_DLL, baud_divisor & 0xff);
+
+    _lcr &= ~LCR_DL;
+    HAL_WRITE_UINT8(port+SER_16550_LCR, _lcr);
+}
+
+//-----------------------------------------------------------------------------
+// The minimal init, get and put functions. All by polling.
+
+void
+cyg_hal_plf_serial_init_channel(void* __ch_data)
+{
+    cyg_uint8* port;
+    cyg_uint8 _lcr;
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    port = ((channel_data_t*)__ch_data)->base;
+
+    // Disable port interrupts while changing hardware
+    HAL_WRITE_UINT8(port+SER_16550_IER, 0);
+
+    // Set databits, stopbits and parity.
+    _lcr = LCR_WL8 | LCR_SB1 | LCR_PN;
+    HAL_WRITE_UINT8(port+SER_16550_LCR, _lcr);
+
+    // Set baud rate.
+    cyg_hal_plf_serial_set_baud(port, CYG_DEV_SERIAL_BAUD_DIVISOR);
+
+    // Enable and clear FIFO
+    HAL_WRITE_UINT8(port+SER_16550_FCR, (FCR_ENABLE | FCR_CLEAR_RCVR | FCR_CLEAR_XMIT));
+
+    // enable RTS to keep host side happy
+    HAL_WRITE_UINT8( port+SER_16550_MCR, MCR_RTS );
+    
+    // Don't allow interrupts.
+    HAL_WRITE_UINT8(port+SER_16550_IER, 0);
+}
+
+void
+cyg_hal_plf_serial_putc(void* __ch_data, cyg_uint8 __ch)
+{
+    cyg_uint8* port;
+    cyg_uint8 _lsr;
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    port = ((channel_data_t*)__ch_data)->base;
+
+    CYGARC_HAL_SAVE_GP();
+
+    do {
+        HAL_READ_UINT8(port+SER_16550_LSR, _lsr);
+    } while ((_lsr & SIO_LSR_THRE) == 0);
+
+    // Now, the transmit buffer is empty
+    HAL_WRITE_UINT8(port+SER_16550_THR, __ch);
+
+    // Hang around until the character has been safely sent.
+    do {
+        HAL_READ_UINT8(port+SER_16550_LSR, _lsr);
+    } while ((_lsr & SIO_LSR_THRE) == 0);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static int lsr_global;
+
+static cyg_bool
+cyg_hal_plf_serial_getc_nonblock(void* __ch_data, cyg_uint8* ch)
+{
+    cyg_uint8* port;
+    cyg_uint8 _lsr;
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    port = ((channel_data_t*)__ch_data)->base;
+
+    HAL_READ_UINT8(port+SER_16550_LSR, _lsr);
+    if ((_lsr & SIO_LSR_DR) == 0)
+        return false;
+    lsr_global = _lsr;
+    CYG_ASSERT((_lsr & SIO_LSR_OE) == 0 , "UART receiver overrun error");
+    HAL_READ_UINT8(port+SER_16550_RBR, *ch);
+
+    return true;
+}
+
+cyg_uint8
+cyg_hal_plf_serial_getc(void* __ch_data)
+{
+    cyg_uint8 ch;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    while(!cyg_hal_plf_serial_getc_nonblock(__ch_data, &ch));
+
+    CYGARC_HAL_RESTORE_GP();
+    return ch;
+}
+
+static void
+cyg_hal_plf_serial_write(void* __ch_data, const cyg_uint8* __buf, 
+                         cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    while(__len-- > 0)
+        cyg_hal_plf_serial_putc(__ch_data, *__buf++);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+static void
+cyg_hal_plf_serial_read(void* __ch_data, cyg_uint8* __buf, cyg_uint32 __len)
+{
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    while(__len-- > 0)
+        *__buf++ = cyg_hal_plf_serial_getc(__ch_data);
+
+    CYGARC_HAL_RESTORE_GP();
+}
+
+
+cyg_bool
+cyg_hal_plf_serial_getc_timeout(void* __ch_data, cyg_uint8* ch)
+{
+    int delay_count;
+    channel_data_t* chan;
+    cyg_bool res;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    chan = (channel_data_t*)__ch_data;
+
+    delay_count = chan->msec_timeout; // delay in 1000 us steps
+
+    for(;;) {
+        res = cyg_hal_plf_serial_getc_nonblock(__ch_data, ch);
+        if (res || 0 == delay_count--)
+            break;
+        CYGACC_CALL_IF_DELAY_US(1000);
+    }
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static int
+cyg_hal_plf_serial_control(void *__ch_data, __comm_control_cmd_t __func, ...)
+{
+    static int irq_state = 0;
+    channel_data_t* chan;
+    cyg_uint8 ier;
+    int ret = 0;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    chan = (channel_data_t*)__ch_data;
+
+    switch (__func) {
+    case __COMMCTL_IRQ_ENABLE:
+        irq_state = 1;
+
+        HAL_READ_UINT8(chan->base + SER_16550_IER, ier);
+        ier |= SIO_IER_ERDAI;
+        HAL_WRITE_UINT8(chan->base + SER_16550_IER, ier);
+
+        HAL_INTERRUPT_SET_LEVEL(chan->isr_vector, 1);
+        HAL_INTERRUPT_UNMASK(chan->isr_vector);
+        break;
+    case __COMMCTL_IRQ_DISABLE:
+        ret = irq_state;
+        irq_state = 0;
+
+        HAL_READ_UINT8(chan->base + SER_16550_IER, ier);
+        ier &= ~SIO_IER_ERDAI;
+        HAL_WRITE_UINT8(chan->base + SER_16550_IER, ier);
+
+        HAL_INTERRUPT_MASK(chan->isr_vector);
+        break;
+    case __COMMCTL_DBG_ISR_VECTOR:
+        ret = chan->isr_vector;
+        break;
+    case __COMMCTL_SET_TIMEOUT:
+    {
+        va_list ap;
+
+        va_start(ap, __func);
+
+        ret = chan->msec_timeout;
+        chan->msec_timeout = va_arg(ap, cyg_uint32);
+
+        va_end(ap);
+    }        
+    break;
+    case __COMMCTL_SETBAUD:
+    {
+        cyg_uint32 baud_rate;
+        cyg_uint16 baud_divisor;
+        cyg_uint8* port = chan->base;
+        va_list ap;
+
+        va_start(ap, __func);
+        baud_rate = va_arg(ap, cyg_uint32);
+        va_end(ap);
+
+        switch (baud_rate)
+        {
+        case 110:    baud_divisor = DIVISOR(110);    break;
+        case 150:    baud_divisor = DIVISOR(150);    break;
+        case 300:    baud_divisor = DIVISOR(300);    break;
+        case 600:    baud_divisor = DIVISOR(600);    break;
+        case 1200:   baud_divisor = DIVISOR(1200);   break;
+        case 2400:   baud_divisor = DIVISOR(2400);   break;
+        case 4800:   baud_divisor = DIVISOR(4800);   break;
+        case 7200:   baud_divisor = DIVISOR(7200);   break;
+        case 9600:   baud_divisor = DIVISOR(9600);   break;
+        case 14400:  baud_divisor = DIVISOR(14400);  break;
+        case 19200:  baud_divisor = DIVISOR(19200);  break;
+        case 38400:  baud_divisor = DIVISOR(38400);  break;
+        case 57600:  baud_divisor = DIVISOR(57600);  break;
+        case 115200: baud_divisor = DIVISOR(115200); break;
+        case 230400: baud_divisor = DIVISOR(230400); break;
+        default:     return -1;                      break; // Invalid baud rate selected
+        }
+
+        // Disable port interrupts while changing hardware
+        HAL_READ_UINT8(port+SER_16550_IER, ier);
+        HAL_WRITE_UINT8(port+SER_16550_IER, 0);
+
+        // Set baud rate.
+        cyg_hal_plf_serial_set_baud(port, baud_divisor);
+
+        // Reenable interrupts if necessary
+        HAL_WRITE_UINT8(port+SER_16550_IER, ier);
+    }
+    break;
+
+    case __COMMCTL_GETBAUD:
+        break;
+    default:
+        break;
+    }
+    CYGARC_HAL_RESTORE_GP();
+    return ret;
+}
+
+static int
+cyg_hal_plf_serial_isr(void *__ch_data, int* __ctrlc, 
+                       CYG_ADDRWORD __vector, CYG_ADDRWORD __data)
+{
+    int res = 0;
+    cyg_uint8 _iir, c;
+    channel_data_t* chan;
+    CYGARC_HAL_SAVE_GP();
+
+    // Some of the diagnostic print code calls through here with no idea what the ch_data is.
+    // Go ahead and assume it is channels[0].
+    if (__ch_data == 0)
+      __ch_data = (void*)&channels[0];
+
+    chan = (channel_data_t*)__ch_data;
+
+    HAL_INTERRUPT_ACKNOWLEDGE(chan->isr_vector);
+
+    HAL_READ_UINT8(chan->base + SER_16550_IIR, _iir);
+    _iir &= SIO_IIR_ID_MASK;
+
+    *__ctrlc = 0;
+    if ((_iir == ISR_Rx_Avail) || (_iir == ISR_Rx_Char_Timeout)) {
+
+        HAL_READ_UINT8(chan->base + SER_16550_RBR, c);
+    
+        if( cyg_hal_is_break( &c , 1 ) )
+            *__ctrlc = 1;
+
+        res = CYG_ISR_HANDLED;
+    }
+
+    /* sfurman - Hmmm.  Under or1ksim, we sometimes receive interrupts
+       when no characters are in the FIFO.  I think this is a SW bug
+       and not a problem w/ or1ksim, but until the problem is solved,
+       we always consume the interrupt */
+    res = CYG_ISR_HANDLED;
+
+    CYGARC_HAL_RESTORE_GP();
+    return res;
+}
+
+static void
+cyg_hal_plf_serial_init(void)
+{
+    int i;
+    hal_virtual_comm_table_t* comm;
+    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
+
+    //#define NUM_CHANNELS (sizeof(channels)/sizeof(channels[0]))
+#define NUM_CHANNELS CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS
+    for (i = 0; i < NUM_CHANNELS; i++) {
+
+	// Disable interrupts.
+	HAL_INTERRUPT_MASK(channels[i].isr_vector);
+
+	// Init channels
+	cyg_hal_plf_serial_init_channel((void*)&channels[i]);
+    
+	// Setup procs in the vector table
+
+	// Set COMM callbacks for channel
+	CYGACC_CALL_IF_SET_CONSOLE_COMM(i);
+	comm = CYGACC_CALL_IF_CONSOLE_PROCS();
+	CYGACC_COMM_IF_CH_DATA_SET(*comm, &channels[i]);
+	CYGACC_COMM_IF_WRITE_SET(*comm, cyg_hal_plf_serial_write);
+	CYGACC_COMM_IF_READ_SET(*comm, cyg_hal_plf_serial_read);
+	CYGACC_COMM_IF_PUTC_SET(*comm, cyg_hal_plf_serial_putc);
+	CYGACC_COMM_IF_GETC_SET(*comm, cyg_hal_plf_serial_getc);
+	CYGACC_COMM_IF_CONTROL_SET(*comm, cyg_hal_plf_serial_control);
+	CYGACC_COMM_IF_DBG_ISR_SET(*comm, cyg_hal_plf_serial_isr);
+	CYGACC_COMM_IF_GETC_TIMEOUT_SET(*comm, cyg_hal_plf_serial_getc_timeout);
+    }
+
+    // Restore original console
+    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
+}
+
+void
+cyg_hal_plf_comms_init(void)
+{
+    static int initialized = 0;
+
+    if (initialized)
+        return;
+
+    initialized = 1;
+
+    cyg_hal_plf_serial_init();
+}
+
+//-----------------------------------------------------------------------------
+// end of ser16c550c.c
+
