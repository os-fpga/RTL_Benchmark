diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/Makefile u-boot-2009.03/Makefile
--- u-boot-2009.03_orig/Makefile	2009-03-21 14:04:41.000000000 -0700
+++ u-boot-2009.03/Makefile	2009-04-15 18:02:26.232734800 -0700
@@ -182,7 +182,10 @@
 endif
 ifeq ($(ARCH),sparc)
 CROSS_COMPILE = sparc-elf-
-endif	# sparc
+endif
+ifeq ($(ARCH),or1200)
+CROSS_COMPILE = or32-uclinux-
+endif	# or1200
 endif	# HOSTARCH,ARCH
 endif	# CROSS_COMPILE
 
@@ -279,7 +282,7 @@
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
 SUBDIRS	= tools \
-	  examples \
+# 	  examples \
 	  api_examples
 
 .PHONY : $(SUBDIRS)
@@ -336,7 +339,7 @@
 		$(obj)tools/ubsha1 $(obj)u-boot.bin
 
 $(obj)u-boot.dis:	$(obj)u-boot
-		$(OBJDUMP) -d $< > $@
+		$(OBJDUMP) -D $< > $@
 
 $(obj)u-boot:		depend $(SUBDIRS) $(OBJS) $(LIBBOARD) $(LIBS) $(LDSCRIPT)
 		UNDEF_SYM=`$(OBJDUMP) -x $(LIBBOARD) $(LIBS) | \
@@ -3457,6 +3460,21 @@
 grsim_leon2_config : unconfig
 	@$(MKCONFIG) $(@:_config=) sparc leon2 grsim_leon2 gaisler
 
+	
+#========================================================================
+# qaz
+#========================================================================
+de1_or1k_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_DE1_OR1K" > $(obj)include/config.h
+	@$(MKCONFIG) -a $(@:_config=) or1200 or1200 de1_or1k qaz
+	
+Dev_Kit_060804_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_DEV_KIT_060804" > $(obj)include/config.h
+	@$(MKCONFIG) -a $(@:_config=) or1200 or1200 Dev_Kit_060804 qaz
+	
+
 #########################################################################
 #########################################################################
 #########################################################################
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/board/qaz/Dev_Kit_060804/Dev_Kit_060804.c u-boot-2009.03/board/qaz/Dev_Kit_060804/Dev_Kit_060804.c
--- u-boot-2009.03_orig/board/qaz/Dev_Kit_060804/Dev_Kit_060804.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/board/qaz/Dev_Kit_060804/Dev_Kit_060804.c	2009-03-24 13:34:53.471013000 -0700
@@ -0,0 +1,100 @@
+/*
+ * (C) Copyright ????
+ * XXX, XXX@XXX.org
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+// extern unsigned int _data_start, _data_lma_start, _data_end;
+// extern unsigned int _bss_start, _bss_end;
+
+int board_early_init_f (void)
+{
+//   memcpy( (void *)_data_start, (void *)_data_lma_start, (_data_end - _data_start) );
+  
+//   memset ( (void *)_bss_start, 0, ( _bss_end - _bss_start ) );
+
+	return 0;
+}
+
+
+/*
+ * Check Board Identity:
+ */
+int checkboard (void)
+{
+	char str[64];
+	int i = getenv_r ("serial#", str, sizeof(str));
+
+	puts ("Board: ");
+
+	if (i == -1) {
+		puts ("### No HW ID - assuming ???");
+	} else {
+		puts(str);
+	}
+
+	putc ('\n');
+
+	return 0;
+}
+
+
+
+/*
+ * post code for de1 board
+ */
+void set_de1_post( unsigned int post_code )
+{
+	gd->bd->post_code = post_code;
+  
+  *((volatile unsigned int *)(0x5ffffffc)) = gd->bd->post_code;
+  *((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+}
+
+
+void init_de1_post( void )
+{
+	gd->bd->post_code = 0;
+  
+  *((volatile unsigned int *)(0x5ffffffc)) = gd->bd->post_code;
+  *((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+}
+
+
+int de1_post_incr( void )
+{
+	gd->bd->post_code++;
+  
+  *((volatile unsigned int *)(0x5ffffffc)) = gd->bd->post_code;
+  *((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+  
+  return(0);
+}
+
+
+
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/board/qaz/Dev_Kit_060804/Makefile u-boot-2009.03/board/qaz/Dev_Kit_060804/Makefile
--- u-boot-2009.03_orig/board/qaz/Dev_Kit_060804/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/board/qaz/Dev_Kit_060804/Makefile	2009-03-24 13:34:53.471013000 -0700
@@ -0,0 +1,50 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= Dev_Kit_060804.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/board/qaz/Dev_Kit_060804/u-boot.lds u-boot-2009.03/board/qaz/Dev_Kit_060804/u-boot.lds
--- u-boot-2009.03_orig/board/qaz/Dev_Kit_060804/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/board/qaz/Dev_Kit_060804/u-boot.lds	2009-03-24 13:34:53.455424000 -0700
@@ -0,0 +1,67 @@
+/* ------------------------------ */
+/* link script */
+/* ------------------------------ */
+
+MEMORY
+        {
+        boot_rom_1        : ORIGIN = 0x00000000, LENGTH = 0x00020000
+        mem_bank_3        : ORIGIN = 0x30000000, LENGTH = 0x00010000
+        }
+        
+ENTRY(_start)
+
+SECTIONS
+{
+        .text ALIGN(0x4):
+        {
+          . = 0x100;
+          *(.vectors)
+  		    __text_start = .;
+          . = 0x2000;  
+          *(.text)
+      		__text_end = .;
+        } > boot_rom_1
+
+        .rodata ALIGN(0x4):
+        {
+      		__rodata_start = .;
+          *(.rodata)
+          *(.rodata.*)
+      		__rodata_end = .;
+        } > boot_rom_1
+
+      	.u_boot_cmd ALIGN(0x4):
+      	{
+      		. = .;
+      	  ___u_boot_cmd_start = .;
+      		*(.u_boot_cmd)
+      	  ___u_boot_cmd_end = .;
+      	} > boot_rom_1
+
+      	. = ALIGN(4);
+      		__data_lma_start = .;
+        .data : 
+        {
+      		__data_start = .;
+          *(.data)
+      		__data_end = .;
+        } > boot_rom_1
+        
+      	. = ALIGN(4);
+        .bss (NOLOAD):
+        {
+      		__bss_start = .;
+          *(.bss)
+      		__bss_end = .;
+        } > mem_bank_3
+
+      	. = ALIGN(4);
+        .stack (NOLOAD) :
+        {
+      		__stack_start = .;
+          *(.stack)
+      		__stack_end = .;
+        } > mem_bank_3
+        
+      	__end = . ;
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/board/qaz/de1_or1k/Makefile u-boot-2009.03/board/qaz/de1_or1k/Makefile
--- u-boot-2009.03_orig/board/qaz/de1_or1k/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/board/qaz/de1_or1k/Makefile	2009-03-24 13:34:53.096877000 -0700
@@ -0,0 +1,50 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= de1_or1k.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/board/qaz/de1_or1k/de1_or1k.c u-boot-2009.03/board/qaz/de1_or1k/de1_or1k.c
--- u-boot-2009.03_orig/board/qaz/de1_or1k/de1_or1k.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/board/qaz/de1_or1k/de1_or1k.c	2009-04-15 16:16:19.652035300 -0700
@@ -0,0 +1,100 @@
+/*
+ * (C) Copyright ????
+ * XXX, XXX@XXX.org
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+// extern unsigned int _data_start, _data_lma_start, _data_end;
+// extern unsigned int _bss_start, _bss_end;
+
+int board_early_init_f (void)
+{
+//   memcpy( (void *)_data_start, (void *)_data_lma_start, (_data_end - _data_start) );
+  
+//   memset ( (void *)_bss_start, 0, ( _bss_end - _bss_start ) );
+
+	return 0;
+}
+
+
+/*
+ * Check Board Identity:
+ */
+int checkboard (void)
+{
+	char str[64];
+	int i = getenv_r ("serial#", str, sizeof(str));
+
+	puts ("Board: ");
+
+	if (i == -1) {
+		puts ("### No HW ID - assuming DE1_OR1k");
+	} else {
+		puts(str);
+	}
+
+	putc ('\n');
+
+	return 0;
+}
+
+
+
+/*
+ * post code for de1 board
+ */
+void set_de1_post( unsigned int post_code )
+{
+	gd->bd->post_code = post_code;
+  
+  *((volatile unsigned int *)(0x5ffffffc)) = gd->bd->post_code;
+  *((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+}
+
+
+void init_de1_post( void )
+{
+	gd->bd->post_code = 0;
+  
+  *((volatile unsigned int *)(0x5ffffffc)) = gd->bd->post_code;
+  *((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+}
+
+
+int de1_post_incr( void )
+{
+	gd->bd->post_code++;
+  
+  *((volatile unsigned int *)(0x5ffffffc)) = gd->bd->post_code;
+  *((volatile unsigned int *)(0x5ffffffc)) = 0xcea5e0ff;
+  
+  return(0);
+}
+
+
+
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/board/qaz/de1_or1k/u-boot.lds u-boot-2009.03/board/qaz/de1_or1k/u-boot.lds
--- u-boot-2009.03_orig/board/qaz/de1_or1k/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/board/qaz/de1_or1k/u-boot.lds	2009-03-24 13:34:53.455424000 -0700
@@ -0,0 +1,67 @@
+/* ------------------------------ */
+/* link script */
+/* ------------------------------ */
+
+MEMORY
+        {
+        boot_rom_1        : ORIGIN = 0x00000000, LENGTH = 0x00020000
+        mem_bank_3        : ORIGIN = 0x30000000, LENGTH = 0x00010000
+        }
+        
+ENTRY(_start)
+
+SECTIONS
+{
+        .text ALIGN(0x4):
+        {
+          . = 0x100;
+          *(.vectors)
+  		    __text_start = .;
+          . = 0x2000;  
+          *(.text)
+      		__text_end = .;
+        } > boot_rom_1
+
+        .rodata ALIGN(0x4):
+        {
+      		__rodata_start = .;
+          *(.rodata)
+          *(.rodata.*)
+      		__rodata_end = .;
+        } > boot_rom_1
+
+      	.u_boot_cmd ALIGN(0x4):
+      	{
+      		. = .;
+      	  ___u_boot_cmd_start = .;
+      		*(.u_boot_cmd)
+      	  ___u_boot_cmd_end = .;
+      	} > boot_rom_1
+
+      	. = ALIGN(4);
+      		__data_lma_start = .;
+        .data : 
+        {
+      		__data_start = .;
+          *(.data)
+      		__data_end = .;
+        } > boot_rom_1
+        
+      	. = ALIGN(4);
+        .bss (NOLOAD):
+        {
+      		__bss_start = .;
+          *(.bss)
+      		__bss_end = .;
+        } > mem_bank_3
+
+      	. = ALIGN(4);
+        .stack (NOLOAD) :
+        {
+      		__stack_start = .;
+          *(.stack)
+      		__stack_end = .;
+        } > mem_bank_3
+        
+      	__end = . ;
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/common/cmd_bootm.c u-boot-2009.03/common/cmd_bootm.c
--- u-boot-2009.03_orig/common/cmd_bootm.c	2009-03-21 14:04:41.000000000 -0700
+++ u-boot-2009.03/common/cmd_bootm.c	2009-03-25 16:25:04.705123000 -0700
@@ -191,6 +191,8 @@
   #define IH_INITRD_ARCH IH_ARCH_SH
 #elif defined(__sparc__)
   #define IH_INITRD_ARCH IH_ARCH_SPARC
+#elif defined(__or1200__)
+  #define IH_INITRD_ARCH IH_ARCH_INVALID
 #else
 # error Unknown CPU type
 #endif
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/cpu/or1200/Makefile u-boot-2009.03/cpu/or1200/Makefile
--- u-boot-2009.03_orig/cpu/or1200/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/cpu/or1200/Makefile	2009-03-24 13:32:29.713725000 -0700
@@ -0,0 +1,57 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2007
+# Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
+#
+# (C) Copyright 2007
+# Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(CPU).a
+
+SOBJS	= start.o
+COBJS	= interrupts.o watchdog.o time.o cpu.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/cpu/or1200/cpu.c u-boot-2009.03/cpu/or1200/cpu.c
--- u-boot-2009.03_orig/cpu/or1200/cpu.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/cpu/or1200/cpu.c	2009-03-24 13:32:29.713725000 -0700
@@ -0,0 +1,35 @@
+/*
+ * (C) Copyright 2004, Psyent Corporation <www.psyent.com>
+ * Scott McNutt <smcnutt@psyent.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+
+int do_reset (void)
+{
+	void (*rst)(void) = (void(*)(void))0x00000000;
+// 	void (*rst)(void) = (void(*)(void))CFG_RESET_ADDR;
+	disable_interrupts ();
+	rst();
+	return(0);
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/cpu/or1200/interrupts.c u-boot-2009.03/cpu/or1200/interrupts.c
--- u-boot-2009.03_orig/cpu/or1200/interrupts.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/cpu/or1200/interrupts.c	2009-03-24 13:32:29.698200000 -0700
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2007
+ * Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
+ *
+ * (C) Copyright 2007
+ * Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+int interrupt_init(void)
+{
+	return 0;
+}
+
+void enable_interrupts(void)
+{
+
+}
+
+int disable_interrupts(void)
+{
+	return 0;
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/cpu/or1200/start.S u-boot-2009.03/cpu/or1200/start.S
--- u-boot-2009.03_orig/cpu/or1200/start.S	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/cpu/or1200/start.S	2009-03-24 13:32:29.713725000 -0700
@@ -0,0 +1,27 @@
+/*  */
+/*  */
+
+#include <config.h>
+
+.section .stack, "aw", @nobits
+.space  0x8000
+_stack:
+
+.section .vectors, "ax"
+  
+	.global	_start
+_start:
+
+  /* Set stack pointer */
+  l.movhi r1,hi(_stack)
+  l.ori   r1,r1,lo(_stack)
+  
+  /* Jump to main */
+  l.movhi r2,hi(_board_init)
+  l.ori   r2,r2,lo(_board_init)
+  l.jr    r2
+  l.nop
+
+
+  
+  
\ No newline at end of file
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/cpu/or1200/time.c u-boot-2009.03/cpu/or1200/time.c
--- u-boot-2009.03_orig/cpu/or1200/time.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/cpu/or1200/time.c	2009-03-25 17:31:06.263350000 -0700
@@ -0,0 +1,39 @@
+/*
+ * (C) Copyright 2007 Michal Simek
+ * (C) Copyright 2004 Atmark Techno, Inc.
+ *
+ * Michal  SIMEK <monstr@monstr.eu>
+ * Yasushi SHOJI <yashi@atmark-techno.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+void udelay (unsigned long usec)
+{
+	unsigned int i;
+	for (i = 0; i < (usec * CONFIG_HZ / 10000000); i++);
+}
+
+
+ulong get_timer (ulong base_ticks)
+{
+	return 0;
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/cpu/or1200/watchdog.c u-boot-2009.03/cpu/or1200/watchdog.c
--- u-boot-2009.03_orig/cpu/or1200/watchdog.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/cpu/or1200/watchdog.c	2009-03-24 13:32:29.698200000 -0700
@@ -0,0 +1,33 @@
+/*
+ * (C) Copyright 2007
+ * Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+
+int watchdog_init(void)
+{
+	return 0;
+}
+
+void reset_cpu(unsigned long ignored)
+{
+	while (1)
+		;
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/bitops.h u-boot-2009.03/include/asm-or1200/bitops.h
--- u-boot-2009.03_orig/include/asm-or1200/bitops.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/bitops.h	2008-08-26 18:13:42.783673400 -0700
@@ -0,0 +1,554 @@
+/* asm/bitops.h for Linux/or32
+ *
+ * __PHX__ TODO: asm versions
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef _OR32_BITOPS_H
+#define _OR32_BITOPS_H
+
+#include <asm/system.h>
+#include <asm/byteorder.h>
+// #include <linux/compiler.h>
+
+
+static __inline__ int set_bit(int nr, volatile void * a)
+{
+	int 	* addr = (void *)a;
+	int	mask, retval;
+	unsigned long flags;
+
+	addr += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *addr) != 0;
+	*addr |= mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+ * non-atomic version
+ */
+static __inline__ void __set_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = 1 << (nr & 0x1f);
+	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
+
+	*p |= mask;
+}
+
+static __inline__ int clear_bit(int nr, volatile void * a)
+{
+	int 	* addr = (void *)a;
+	int	mask, retval;
+	unsigned long flags;
+
+	addr += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *addr) != 0;
+	*addr &= ~mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+ * non-atomic version
+ */
+static __inline__ void __clear_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = 1 << (nr & 0x1f);
+	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
+
+	*p &= ~mask;
+}
+
+static __inline__ unsigned long change_bit(unsigned long nr,  void *addr)
+{
+	int mask;
+  unsigned long flags;
+	unsigned long *ADDR = (unsigned long *) addr;
+	unsigned long oldbit;
+
+	ADDR += nr >> 5;
+	mask = 1 << (nr & 31);
+	local_irq_save(flags);
+	oldbit = (mask & *ADDR);
+	*ADDR ^= mask;
+	local_irq_restore(flags);
+	return oldbit != 0;
+}
+
+/*
+ * non-atomic version
+ */
+static __inline__ void __change_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = 1 << (nr & 0x1f);
+	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
+
+	*p ^= mask;
+}
+
+static __inline__ int test_bit(int nr, const void *a)
+{
+	unsigned int mask;
+        unsigned int *adr = (unsigned int *)a;
+         
+        adr += nr >> 5;
+        mask = 1 << (nr & 0x1f);
+        return ((mask & *adr) != 0);
+}
+
+static __inline__ int test_and_set_bit(int nr, void *addr)
+{
+	unsigned int mask, retval;
+	unsigned long flags;
+	unsigned int *adr = (unsigned int *)addr;
+	
+	adr += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *adr) != 0;
+	*adr |= mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+ * non-atomic version
+ */
+static __inline__ int __test_and_set_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = 1 << (nr & 0x1f);
+	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
+	unsigned long old = *p;
+
+	*p = old | mask;
+	return (old & mask) != 0;
+}
+
+
+static __inline__ int test_and_clear_bit(int nr, void *addr)
+{
+	unsigned int mask, retval;
+	unsigned long flags;
+	unsigned int *adr = (unsigned int *)addr;
+	
+	adr += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *adr) != 0;
+	*adr &= ~mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+ * non-atomic version
+ */
+static __inline__ int __test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = 1 << (nr & 0x1f);
+	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
+	unsigned long old = *p;
+
+	*p = old & ~mask;
+	return (old & mask) != 0;
+}
+
+static __inline__ int test_and_change_bit(int nr, void *addr)
+{
+	unsigned int mask, retval;
+	unsigned long flags;
+	unsigned int *adr = (unsigned int *)addr;
+	adr += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	local_irq_save(flags);
+	retval = (mask & *adr) != 0;
+	*adr ^= mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+ * non-atomic version
+ */
+static __inline__ int __test_and_change_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = 1 << (nr & 0x1f);
+	unsigned long *p = ((unsigned long *)addr) + (nr >> 5);
+	unsigned long old = *p;
+
+	*p = old ^ mask;
+	return (old & mask) != 0;
+}
+
+#define __change_bit(nr, addr) (void)__test_and_change_bit(nr, addr)
+
+/*
+ * Find-bit routines..
+ */
+
+/*
+ * fls: find last bit set.
+ */
+
+#define fls(x) generic_fls(x)
+
+/* The easy/cheese version for now. */
+static __inline__ unsigned long ffz(unsigned long word)
+{
+	unsigned long result = 0;
+
+	while(word & 1) {
+		result++;
+		word >>= 1;
+	}
+	return result;
+}
+
+/*
+ * ffs: find first bit set. This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+
+#define ffs(x) generic_ffs(x)
+
+/*
+ * hweightN - returns the hamming weight of a N-bit word
+ * @x: the word to weigh
+ *
+ * The Hamming Weight of a number is the total number of bits set in it.
+ */
+#if 0 /*RGD*/
+#define hweight32(x) generic_hweight32(x)
+#define hweight16(x) generic_hweight16(x)
+#define hweight8(x) generic_hweight8(x)
+#endif
+/**
+ * __ffs - find first bit in word.
+ * @word: The word to search
+ *
+ * Undefined if no bit exists, so code should check against 0 first.
+ */
+static __inline__ int __ffs(unsigned long word)
+{
+	int num = 0;
+
+	if ((word & 0xffff) == 0) {
+		num += 16;
+		word >>= 16;
+	}
+	if ((word & 0xff) == 0) {
+		num += 8;
+		word >>= 8;
+	}
+	if ((word & 0xf) == 0) {
+		num += 4;
+		word >>= 4;
+	}
+	if ((word & 0x3) == 0) {
+		num += 2;
+		word >>= 2;
+	}
+	if ((word & 0x1) == 0)
+		num += 1;
+	return num;
+}
+
+// /*
+//  * Every architecture must define this function. It's the fastest
+//  * way of searching a 140-bit bitmap where the first 100 bits are
+//  * unlikely to be set. It's guaranteed that at least one of the 140
+//  * bits is cleared.
+//  */
+// static __inline__ int sched_find_first_bit(unsigned long *b)
+// {
+
+// 	if (unlikely(b[0]))
+// 		return __ffs(b[0]);
+// 	if (unlikely(b[1]))
+// 		return __ffs(b[1]) + 32;
+// 	if (unlikely(b[2]))
+// 		return __ffs(b[2]) + 64;
+// 	if (b[3])
+// 		return __ffs(b[3]) + 96;
+// 	return __ffs(b[4]) + 128;
+// }
+
+/**
+ *  * find_next_bit - find the next set bit in a memory region
+ *  * @addr: The address to base the search on
+ *  * @offset: The bitnumber to start searching at
+ *  * @size: The maximum size to search
+ *  */
+static __inline__ unsigned long find_next_bit(const unsigned long *addr,
+					              unsigned long size, unsigned long offset)
+{
+	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
+	unsigned int result = offset & ~31UL;
+	unsigned int tmp;
+	
+	if (offset >= size)
+	  return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *p++;
+		tmp &= ~0UL << offset;
+		if (size < 32)
+		  goto found_first;
+		if (tmp)
+		  goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size >= 32) {
+		if ((tmp = *p++) != 0)
+		  goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+	  return result;
+	tmp = *p;
+	
+	found_first:
+	tmp &= ~0UL >> (32 - size);
+	if (tmp == 0UL)        /* Are any bits set? */
+	  return result + size; /* Nope. */
+	found_middle:
+	return result + __ffs(tmp);
+}
+
+
+/* find_next_zero_bit() finds the first zero bit in a bit string of length
+ * 'size' bits, starting the search at bit 'offset'. This is largely based
+ * on Linus's ALPHA routines, which are pretty portable BTW.
+ */
+
+static __inline__ unsigned long find_next_zero_bit(const unsigned long *addr,
+						   unsigned long size, 
+						   unsigned long offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *(p++);
+		tmp |= ~0UL >> (32-offset);
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	tmp |= ~0UL >> size;
+found_middle:
+	return result + ffz(tmp);
+}
+
+/**
+ * find_first_bit - find the first set bit in a memory region
+ * @addr: The address to start the search at
+ * @size: The maximum size to search
+ *
+ * Returns the bit-number of the first set bit, not the number of the byte
+ * containing a bit.
+ */
+#define find_first_bit(addr, size) \
+        find_next_bit((addr), (size), 0)
+               
+
+/* Linus sez that gcc can optimize the following correctly, we'll see if this
+ * holds on the Sparc as it does for the ALPHA.
+ */
+
+#define find_first_zero_bit(addr, size) \
+        find_next_zero_bit((addr), (size), 0)
+
+/* Now for the ext2 filesystem bit operations and helper routines. */
+
+static __inline__ int ext2_set_bit(int nr,void * addr)
+{
+	int		mask, retval;
+  unsigned long flags;
+	unsigned char	*ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	local_irq_save(flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR |= mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+static __inline__ int ext2_clear_bit(int nr, void * addr)
+{
+	int		mask, retval;
+  unsigned long flags;
+	unsigned char	*ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	local_irq_save(flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR &= ~mask;
+	local_irq_restore(flags);
+	return retval;
+}
+
+static __inline__ int ext2_test_bit(int nr, const void * addr)
+{
+	int			mask;
+	const unsigned char	*ADDR = (const unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	return ((mask & *ADDR) != 0);
+}
+
+#define ext2_find_first_zero_bit(addr, size) \
+        ext2_find_next_zero_bit((addr), (size), 0)
+
+static __inline__ unsigned long ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if(offset) {
+		tmp = *(p++);
+		tmp |= ~0UL << (32-offset);
+		if(size < 32)
+			goto found_first;
+		if(~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while(size & ~31UL) {
+		if(~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if(!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	tmp |= ~0UL << size;
+found_middle:
+	tmp = ((tmp>>24) | ((tmp>>8)&0xff00) | ((tmp<<8)&0xff0000) | (tmp<<24));
+	return result + ffz(tmp);
+}
+
+#define __ext2_set_bit ext2_set_bit
+#define __ext2_clear_bit ext2_clear_bit
+
+static __inline__ int __ext2_test_bit(int nr, __const__ void * addr)
+{
+	int			mask;
+	__const__ unsigned char	*ADDR = (__const__ unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	return ((mask & *ADDR) != 0);
+}
+
+#define __ext2_find_first_zero_bit(addr, size) \
+        __ext2_find_next_zero_bit((addr), (size), 0)
+
+static __inline__ unsigned long __ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if(offset) {
+		tmp = *(p++);
+		tmp |= __swab32(~0UL >> (32-offset));
+		if(size < 32)
+			goto found_first;
+		if(~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while(size & ~31UL) {
+		if(~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if(!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	return result + ffz(__swab32(tmp) | (~0UL << size));
+found_middle:
+	return result + ffz(__swab32(tmp));
+}
+
+#define ext2_set_bit_atomic(lock, nr, addr)             \
+        ({                                              \
+                int ret;                                \
+                spin_lock(lock);                        \
+                ret = ext2_set_bit((nr), (unsigned long *)(addr)); \
+                spin_unlock(lock);                      \
+                ret;                                    \
+        })
+ 
+#define ext2_clear_bit_atomic(lock, nr, addr)           \
+        ({                                              \
+                int ret;                                \
+                spin_lock(lock);                        \
+                ret = ext2_clear_bit((nr), (unsigned long *)(addr)); \
+                spin_unlock(lock);                      \
+                ret;                                    \
+        })
+
+/*
+ * clear_bit() doesn't provide any barrier for the compiler.
+ */
+
+#define smp_mb__before_clear_bit()      barrier()
+#define smp_mb__after_clear_bit()       barrier()
+// #include <asm-generic/bitops/ffs.h>
+// #include <asm-generic/bitops/fls.h>
+// #include <asm-generic/bitops/hweight.h>
+// #include <asm-generic/bitops/fls64.h>
+#endif /* _OR32_BITOPS_H */
+#endif /* __KERNEL__ */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/byteorder.h u-boot-2009.03/include/asm-or1200/byteorder.h
--- u-boot-2009.03_orig/include/asm-or1200/byteorder.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/byteorder.h	2008-07-02 09:36:01.937500000 -0700
@@ -0,0 +1,13 @@
+#ifndef _OR32_BYTEORDER_H
+#define _OR32_BYTEORDER_H
+
+#include <asm/types.h>
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#include <linux/byteorder/big_endian.h>
+
+#endif /* _OR32_BYTEORDER_H */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/config.h u-boot-2009.03/include/asm-or1200/config.h
--- u-boot-2009.03_orig/include/asm-or1200/config.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/config.h	2009-03-25 15:52:40.248817600 -0700
@@ -0,0 +1,5 @@
+/*
+
+*/
+
+
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/global_data.h u-boot-2009.03/include/asm-or1200/global_data.h
--- u-boot-2009.03_orig/include/asm-or1200/global_data.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/global_data.h	2008-09-05 09:56:50.625000000 -0700
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2004 Atmark Techno, Inc.
+ *
+ * Yasushi SHOJI <yashi@atmark-techno.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	__ASM_GBL_DATA_H
+#define __ASM_GBL_DATA_H
+/*
+ * The following data structure is placed in some memory wich is
+ * available very early after boot (like DPRAM on MPC8xx/MPC82xx, or
+ * some locked parts of the data cache) to allow for a minimum set of
+ * global variables during system initialization (until we have set
+ * up the memory controller so that we can use RAM).
+ *
+ * Keep it *SMALL* and remember to set CFG_GBL_DATA_SIZE > sizeof(gd_t)
+ */
+
+typedef	struct	global_data {
+	bd_t		*bd;
+	unsigned long	flags;
+	unsigned long	baudrate;
+	unsigned long	have_console;	/* serial_init() was called */
+	unsigned long	reloc_off;	/* Relocation Offset */
+	unsigned long	env_addr;	/* Address  of Environment struct */
+	unsigned long	env_valid;	/* Checksum of Environment valid? */
+	unsigned long	fb_base;	/* base address of frame buffer */
+	void		**jt;		/* jump table */
+} gd_t;
+
+/*
+ * Global Data Flags
+ */
+#define	GD_FLG_RELOC	0x00001		/* Code was relocated to RAM		*/
+#define	GD_FLG_DEVINIT	0x00002		/* Devices have been initialized	*/
+#define	GD_FLG_SILENT	0x00004		/* Silent mode				*/
+
+#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r30")
+
+#endif /* __ASM_GBL_DATA_H */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/io.h u-boot-2009.03/include/asm-or1200/io.h
--- u-boot-2009.03_orig/include/asm-or1200/io.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/io.h	2008-07-02 09:36:02.031250000 -0700
@@ -0,0 +1,90 @@
+#ifndef _OR32_IO_H
+#define _OR32_IO_H
+
+#include <asm/page.h>   /* for __va, __pa */
+
+
+/*
+ * Change virtual addresses to physical addresses and vv.
+ */
+
+static inline unsigned long virt_to_phys(volatile void * address)
+{
+	return __pa(address);
+}
+
+static inline void * phys_to_virt(unsigned long address)
+{
+	return __va(address);
+}
+
+extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
+
+extern inline void * ioremap(unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, 0);
+}
+
+/* #define _PAGE_CI       0x002 */
+extern inline void * ioremap_nocache(unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, 0x002);
+}
+
+extern void iounmap(void *addr);
+
+#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
+
+/*
+ * IO bus memory addresses are also 1:1 with the physical address
+ */
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the or32 architecture, we just read/write the
+ * memory location directly.
+ */
+#define readb(addr) (*(volatile unsigned char *) (addr))
+#define readw(addr) (*(volatile unsigned short *) (addr))
+#define readl(addr) (*(volatile unsigned int *) (addr))
+
+#define writeb(b,addr) ((*(volatile unsigned char *) (addr)) = (b))
+#define writew(b,addr) ((*(volatile unsigned short *) (addr)) = (b))
+#define writel(b,addr) ((*(volatile unsigned int *) (addr)) = (b))
+#define __raw_writel writel /*RGD*/
+
+#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
+#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+
+/*
+ * Again, or32 does not require mem IO specific function.
+ */
+
+#define eth_io_copy_and_sum(a,b,c,d)	eth_copy_and_sum((a),(void *)(b),(c),(d))
+
+#define IO_BASE			0x0
+#define IO_SPACE_LIMIT 		0xffffffff
+
+#define inb(port)		(*(volatile unsigned char *) (port+IO_BASE))
+#define outb(value,port)	((*(volatile unsigned char *) (port+IO_BASE)) = (value))	
+
+#define inb_p(port)             inb((port))
+#define outb_p(val, port)       outb((val), (port))
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+
+#endif
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/page.h u-boot-2009.03/include/asm-or1200/page.h
--- u-boot-2009.03_orig/include/asm-or1200/page.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/page.h	2008-07-02 09:36:02.140625000 -0700
@@ -0,0 +1,107 @@
+#ifndef _OR32_PAGE_H
+#define _OR32_PAGE_H
+
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT		13
+#define PAGE_SIZE		(1UL << PAGE_SHIFT)
+#define PAGE_MASK		(~(PAGE_SIZE-1))
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+#define PAGE_OFFSET		0xc0000000	
+#define KERNELBASE  		PAGE_OFFSET
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+#define clear_page(page)        memset((void *)(page), 0, PAGE_SIZE)
+#define copy_page(to,from)      memcpy((void *)(to), (void *)(from), PAGE_SIZE)
+
+#define clear_user_page(page, vaddr, pg)    clear_page(page)
+#define copy_user_page(to, from, vaddr, pg) copy_page(to, from)
+
+#define STRICT_MM_TYPECHECKS
+#ifdef  STRICT_MM_TYPECHECKS
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((x).pmd)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) } )
+#define __pmd(x)	((pmd_t) { (x) } )
+#define __pgd(x)	((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+#else /* STRICT_MM_TYPECHECKS */
+/*
+ * .. while these make it easier on the compiler
+ */
+typedef unsigned long pte_t;
+typedef unsigned long pmd_t;
+typedef unsigned long pgd_t;
+typedef unsigned long pgprot_t;
+
+#define pte_val(x)	(x)
+#define pmd_val(x)	(x)
+#define pgd_val(x)	(x)
+#define pgprot_val(x)	(x)
+
+#define __pte(x)	(x)
+#define __pmd(x)	(x)
+#define __pgd(x)	(x)
+#define __pgprot(x)	(x)
+
+#endif /* STRICT_MM_TYPECHECKS */
+
+
+/* Pure 2^n version of get_order */
+static __inline__ int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size-1) >> (PAGE_SHIFT-1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+	return order;
+}
+
+
+/* macros to convert between really physical and virtual addresses
+ */
+
+#define __pa(x)                 ((unsigned long)(x) - PAGE_OFFSET)
+#define __va(x)                 ((void *)((unsigned long)(x) + PAGE_OFFSET))
+
+#define pfn_to_page(pfn)	(mem_map + (pfn))
+#define page_to_pfn(page)	((unsigned long)((page) - mem_map))
+
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define page_to_virt(page)	__va(page_to_pfn(page) << PAGE_SHIFT)
+
+#define pfn_valid(pfn)		((pfn) < max_mapnr)
+#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+
+/* from linker script */
+
+extern unsigned long dram_start, dram_end;
+
+#endif /* __ASSEMBLY__ */
+
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#endif /* __KERNEL__ */
+
+#endif /* _OR32_PAGE_H */
+
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/posix_types.h u-boot-2009.03/include/asm-or1200/posix_types.h
--- u-boot-2009.03_orig/include/asm-or1200/posix_types.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/posix_types.h	2008-08-26 18:22:31.441162400 -0700
@@ -0,0 +1,142 @@
+#ifndef _OR32_POSIX_TYPES_H
+#define _OR32_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned int __kernel_dev_t;
+
+typedef unsigned int    __kernel_ino_t;
+typedef unsigned int    __kernel_mode_t;
+typedef unsigned short  __kernel_nlink_t;
+typedef long            __kernel_off_t;
+typedef int             __kernel_pid_t;
+typedef unsigned int    __kernel_uid_t;
+typedef unsigned int    __kernel_gid_t;
+typedef unsigned int    __kernel_size_t;
+typedef int             __kernel_ssize_t;
+typedef long            __kernel_ptrdiff_t;
+typedef long            __kernel_time_t;
+typedef long            __kernel_suseconds_t;
+typedef long            __kernel_clock_t;
+typedef int             __kernel_timer_t;
+typedef int             __kernel_clockid_t;
+typedef int             __kernel_daddr_t;
+typedef char *          __kernel_caddr_t;
+typedef short           __kernel_ipc_pid_t;
+typedef unsigned short  __kernel_uid16_t;
+typedef unsigned short  __kernel_gid16_t;
+typedef unsigned int    __kernel_uid32_t;
+typedef unsigned int    __kernel_gid32_t;
+
+typedef unsigned int    __kernel_old_uid_t;
+typedef unsigned int    __kernel_old_gid_t;
+typedef unsigned short  __kernel_old_dev_t;
+
+/* i386, cris version
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short  __kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long            __kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short  __kernel_uid16_t;
+typedef unsigned short  __kernel_gid16_t;
+typedef unsigned int    __kernel_uid32_t;
+typedef unsigned int    __kernel_gid32_t;
+
+typedef unsigned short  __kernel_old_uid_t;
+typedef unsigned short  __kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+*/
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+	int	val[2];
+} __kernel_fsid_t;
+
+#ifndef __GNUC__
+
+#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
+#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
+#define	__FD_ISSET(d, set)	((set)->fds_bits[__FDELT(d)] & __FDMASK(d))
+#define	__FD_ZERO(set)	\
+  ((void) memset ((__ptr_t) (set), 0, sizeof (__kernel_fd_set)))
+
+#else /* __GNUC__ */
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) \
+    || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 0)
+/* With GNU C, use inline functions instead so args are evaluated only once: */
+
+#undef __FD_SET
+static __inline__ void __FD_SET(unsigned long fd, __kernel_fd_set *fdsetp)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
+}
+
+#undef __FD_CLR
+static __inline__ void __FD_CLR(unsigned long fd, __kernel_fd_set *fdsetp)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
+}
+
+#undef __FD_ISSET
+static __inline__ int __FD_ISSET(unsigned long fd, __kernel_fd_set *p)
+{ 
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant case (8 ints,
+ * for a 256-bit fd_set)
+ */
+#undef __FD_ZERO
+static __inline__ void __FD_ZERO(__kernel_fd_set *p)
+{
+	unsigned int *tmp = (unsigned int *)p->fds_bits;
+	int i;
+
+	if (__builtin_constant_p(__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+			case 8:
+				tmp[0] = 0; tmp[1] = 0; tmp[2] = 0; tmp[3] = 0;
+				tmp[4] = 0; tmp[5] = 0; tmp[6] = 0; tmp[7] = 0;
+				return;
+		}
+	}
+	i = __FDSET_LONGS;
+	while (i) {
+		i--;
+		*tmp = 0;
+		tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+#endif /* __GNUC__ */
+#endif /* _OR32_POSIX_TYPES_H */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/processor.h u-boot-2009.03/include/asm-or1200/processor.h
--- u-boot-2009.03_orig/include/asm-or1200/processor.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/processor.h	2008-07-02 09:36:02.187500000 -0700
@@ -0,0 +1,119 @@
+/*
+ * include/asm-or32/processor.h
+ *
+ * Based on:
+ * include/asm-cris/processor.h
+ * Copyright (C) 2000, 2001, 2002 Axis Communications AB
+ *
+ */
+
+#ifndef _OR32_PROCESSOR_H
+#define _OR32_PROCESSOR_H
+
+#include <asm/spr_defs.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
+
+/* Kernel and user SR register setting */
+#define KERNEL_SR (SPR_SR_DME | SPR_SR_IME | SPR_SR_ICE | SPR_SR_DCE | SPR_SR_SM)
+#define USER_SR   (SPR_SR_DME | SPR_SR_IME | SPR_SR_ICE | SPR_SR_DCE | SPR_SR_IEE | SPR_SR_TEE)
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+/* or32has no problems with write protection */
+
+#define wp_works_ok 1
+
+/*
+ * User space process size. This is hardcoded into a few places,
+ * so don't change it unless you know what you are doing.
+ */
+
+#define TASK_SIZE       (0x80000000UL)
+
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE      (TASK_SIZE / 8 * 3)
+
+/* THREAD_SIZE is the size of the task_struct/kernel_stack combo.
+ * normally, the stack is found by doing something like p + THREAD_SIZE
+ * in or32, a page is 8192 bytes, which seems like a sane size
+ */
+
+#define THREAD_SIZE       PAGE_SIZE
+
+#ifndef __ASSEMBLY__
+
+struct task_struct;
+
+typedef struct {
+        unsigned long seg;
+} mm_segment_t;
+
+struct thread_struct {
+	unsigned long  usp;     /* user space pointer */
+	unsigned long  ksp;     /* kernel stack pointer */
+	struct pt_regs *regs;   /* pointer to saved register state */
+        mm_segment_t   fs;      /* for get_fs() validation */
+	signed long    last_syscall;
+};
+
+/*
+ * At user->kernel entry, the pt_regs struct is stacked on the top of the kernel-stack.
+ * This macro allows us to find those regs for a task.
+ * Notice that subsequent pt_regs stackings, like recursive interrupts occuring while
+ * we're in the kernel, won't affect this - only the first user->kernel transition
+ * registers are reached by this.
+ */
+#define user_regs(thread_info) (((struct pt_regs *)((unsigned long)(thread_info) + THREAD_SIZE)) - 1)
+
+/*
+ * Dito but for the currently running task
+ */
+
+#define current_regs() user_regs(current->thread_info)
+
+extern inline void prepare_to_copy(struct task_struct *tsk)
+{
+}
+
+#define INIT_SP         (sizeof(init_stack) + (unsigned long) &init_stack)
+
+#define INIT_THREAD  { \
+   0, INIT_SP, NULL, KERNEL_DS, 0 }
+
+
+#define KSTK_EIP(tsk)   ((tsk)->thread.regs? (tsk)->thread.regs->pc: 0)
+#define KSTK_ESP(tsk)   ((tsk)->thread.regs? (tsk)->thread.regs->sp: 0)
+
+
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+void start_thread(struct pt_regs *regs, unsigned long nip, unsigned long sp);
+void release_thread(struct task_struct *);
+unsigned long get_wchan(struct task_struct *p);
+
+/*
+ * Free current thread data structures etc..
+ */
+ 
+extern inline void exit_thread(void)
+{
+         /* Nothing needs to be done.  */
+}
+
+/*
+ * Return saved PC of a blocked thread. For now, this is the "user" PC
+ */
+extern unsigned long thread_saved_pc(struct task_struct *t);
+
+#define init_stack      (init_thread_union.stack)
+
+#define cpu_relax()     do { } while (0)
+
+#endif /* __ASSEMBLY__ */
+#endif /* _OR32_PROCESSOR_H */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/ptrace.h u-boot-2009.03/include/asm-or1200/ptrace.h
--- u-boot-2009.03_orig/include/asm-or1200/ptrace.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/ptrace.h	2008-07-02 09:36:02.187500000 -0700
@@ -0,0 +1,86 @@
+#ifndef _OR32_PTRACE_H
+#define _OR32_PTRACE_H
+
+#include <asm/spr_defs.h>
+/*
+ * This struct defines the way the registers are stored on the
+ * kernel stack during a system call or other kernel entry.
+ *
+ * this should only contain volatile regs
+ * since we can keep non-volatile in the thread_struct
+ * should set this up when only volatiles are saved
+ * by intr code.
+ *
+ * Since this is going on the stack, *CARE MUST BE TAKEN* to insure
+ * that the overall structure is a multiple of 16 bytes in length.
+ *
+ * Note that the offsets of the fields in this struct correspond with
+ * the values below.
+ */
+
+#ifndef __ASSEMBLY__
+
+struct pt_regs {
+	long  pc;
+	long  sr;
+	long  sp;
+	long  gprs[30];
+	long  orig_gpr3;  /* Used for restarting system calls */
+	long  result;     /* Result of a system call */
+	long  syscallno;  /* Syscall no. (used by strace) */
+};
+#endif /* __ASSEMBLY__ */
+
+#ifdef __KERNEL__
+#define STACK_FRAME_OVERHEAD  0  /* size of minimum stack frame */
+
+/* Size of stack frame allocated when calling signal handler. */
+#define __SIGNAL_FRAMESIZE  64
+
+#define instruction_pointer(regs) ((regs)->pc)
+#define user_mode(regs) (((regs)->sr & SPR_SR_SM) == 0)
+#define profile_pc(regs) instruction_pointer(regs)
+
+#endif /* __KERNEL__ */
+
+/*
+ * Offsets used by 'ptrace' system call interface.
+ */
+#define PC        0
+#define SR        4
+#define SP        8
+#define GPR2      12
+#define GPR3      16
+#define GPR4      20
+#define GPR5      24
+#define GPR6      28
+#define GPR7      32
+#define GPR8      36
+#define GPR9      40
+#define GPR10     44
+#define GPR11     48
+#define GPR12     52
+#define GPR13     56
+#define GPR14     60
+#define GPR15     64
+#define GPR16     68
+#define GPR17     72
+#define GPR18     76
+#define GPR19     80
+#define GPR20     84
+#define GPR21     88
+#define GPR22     92
+#define GPR23     96
+#define GPR24     100
+#define GPR25     104
+#define GPR26     108
+#define GPR27     112
+#define GPR28     116
+#define GPR29     120
+#define GPR30     124
+#define GPR31     128
+#define ORIG_GPR3 132
+#define RESULT    136
+#define SYSCALLNO 140
+
+#endif /* _OR32_PTRACE_H */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/spr_defs.h u-boot-2009.03/include/asm-or1200/spr_defs.h
--- u-boot-2009.03_orig/include/asm-or1200/spr_defs.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/spr_defs.h	2008-07-02 09:36:02.296875000 -0700
@@ -0,0 +1,438 @@
+/* spr_defs.h -- Defines OR1K architecture specific special-purpose registers
+   Copyright (C) 1999 Damjan Lampret, lampret@opencores.org
+
+    For more information about OpenRISC processors, licensing and
+    design services you may contact Beyond Semiconductor at
+    sales@bsemi.com or visit website http://www.bsemi.com.
+   
+This file is part of OpenRISC 1000 Architectural Simulator.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+/* This file is also used by microkernel test bench. Among
+others it is also used in assembly file(s). */
+
+/* Definition of special-purpose registers (SPRs) */
+
+#ifndef _SPR_DEFS_H
+#define _SPR_DEFS_H
+
+#define MAX_GRPS (32)
+#define MAX_SPRS_PER_GRP_BITS (11)
+#define MAX_SPRS_PER_GRP (1 << MAX_SPRS_PER_GRP_BITS)
+#define MAX_SPRS (0x10000)
+ 
+/* Base addresses for the groups */
+#define SPRGROUP_SYS    (0<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_DMMU   (1<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_IMMU   (2<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_DC     (3<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_IC     (4<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_MAC    (5<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_D      (6<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_PC     (7<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_PM     (8<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_PIC    (9<< MAX_SPRS_PER_GRP_BITS)
+#define SPRGROUP_TT     (10<< MAX_SPRS_PER_GRP_BITS)
+
+/* System control and status group */
+#define SPR_VR          (SPRGROUP_SYS + 0)
+#define SPR_UPR         (SPRGROUP_SYS + 1)
+#define SPR_PC          (SPRGROUP_SYS + 16)  /* CZ 21/06/01 */
+#define SPR_SR          (SPRGROUP_SYS + 17)  /* CZ 21/06/01 */
+#define SPR_EPCR_BASE   (SPRGROUP_SYS + 32)  /* CZ 21/06/01 */
+#define SPR_EPCR_LAST   (SPRGROUP_SYS + 47)  /* CZ 21/06/01 */
+#define SPR_EEAR_BASE   (SPRGROUP_SYS + 48)
+#define SPR_EEAR_LAST   (SPRGROUP_SYS + 63)
+#define SPR_ESR_BASE    (SPRGROUP_SYS + 64)
+#define SPR_ESR_LAST    (SPRGROUP_SYS + 79)
+
+#if 0
+/* Data MMU group */
+#define SPR_DMMUCR      (SPRGROUP_DMMU + 0)
+#define SPR_DTLBMR_BASE(WAY)    (SPRGROUP_DMMU + 0x200 + (WAY) * 0x200)
+#define SPR_DTLBMR_LAST(WAY)    (SPRGROUP_DMMU + 0x2ff + (WAY) * 0x200)
+#define SPR_DTLBTR_BASE(WAY)    (SPRGROUP_DMMU + 0x300 + (WAY) * 0x200)
+#define SPR_DTLBTR_LAST(WAY)    (SPRGROUP_DMMU + 0x3ff + (WAY) * 0x200)
+
+/* Instruction MMU group */
+#define SPR_IMMUCR      (SPRGROUP_IMMU + 0)
+#define SPR_ITLBMR_BASE(WAY)    (SPRGROUP_IMMU + 0x200 + (WAY) * 0x200)
+#define SPR_ITLBMR_LAST(WAY)    (SPRGROUP_IMMU + 0x2ff + (WAY) * 0x200)
+#define SPR_ITLBTR_BASE(WAY)    (SPRGROUP_IMMU + 0x300 + (WAY) * 0x200)
+#define SPR_ITLBTR_LAST(WAY)    (SPRGROUP_IMMU + 0x3ff + (WAY) * 0x200)
+#else
+/* Data MMU group */
+#define SPR_DMMUCR      (SPRGROUP_DMMU + 0)
+#define SPR_DTLBMR_BASE(WAY)    (SPRGROUP_DMMU + 0x200 + (WAY) * 0x100)
+#define SPR_DTLBMR_LAST(WAY)    (SPRGROUP_DMMU + 0x27f + (WAY) * 0x100)
+#define SPR_DTLBTR_BASE(WAY)    (SPRGROUP_DMMU + 0x280 + (WAY) * 0x100)
+#define SPR_DTLBTR_LAST(WAY)    (SPRGROUP_DMMU + 0x2ff + (WAY) * 0x100)
+
+/* Instruction MMU group */
+#define SPR_IMMUCR      (SPRGROUP_IMMU + 0)
+#define SPR_ITLBMR_BASE(WAY)    (SPRGROUP_IMMU + 0x200 + (WAY) * 0x100)
+#define SPR_ITLBMR_LAST(WAY)    (SPRGROUP_IMMU + 0x27f + (WAY) * 0x100)
+#define SPR_ITLBTR_BASE(WAY)    (SPRGROUP_IMMU + 0x280 + (WAY) * 0x100)
+#define SPR_ITLBTR_LAST(WAY)    (SPRGROUP_IMMU + 0x2ff + (WAY) * 0x100)
+#endif
+
+/* Data cache group */
+#define SPR_DCCR        (SPRGROUP_DC + 0)
+#define SPR_DCBPR       (SPRGROUP_DC + 1)
+#define SPR_DCBFR       (SPRGROUP_DC + 2)
+#define SPR_DCBIR       (SPRGROUP_DC + 3)
+#define SPR_DCBWR       (SPRGROUP_DC + 4)
+#define SPR_DCBLR       (SPRGROUP_DC + 5)
+#define SPR_DCR_BASE(WAY)       (SPRGROUP_DC + 0x200 + (WAY) * 0x200)
+#define SPR_DCR_LAST(WAY)       (SPRGROUP_DC + 0x3ff + (WAY) * 0x200)
+
+/* Instruction cache group */
+#define SPR_ICCR        (SPRGROUP_IC + 0)
+#define SPR_ICBPR       (SPRGROUP_IC + 1)
+#define SPR_ICBIR       (SPRGROUP_IC + 2)
+#define SPR_ICBLR       (SPRGROUP_IC + 3)
+#define SPR_ICR_BASE(WAY)       (SPRGROUP_IC + 0x200 + (WAY) * 0x200)
+#define SPR_ICR_LAST(WAY)       (SPRGROUP_IC + 0x3ff + (WAY) * 0x200)
+
+/* MAC group */
+#define SPR_MACLO       (SPRGROUP_MAC + 1)
+#define SPR_MACHI       (SPRGROUP_MAC + 2)
+
+/* Debug group */
+#define SPR_DVR(N)      (SPRGROUP_D + (N))
+#define SPR_DCR(N)      (SPRGROUP_D + 8 + (N))
+#define SPR_DMR1        (SPRGROUP_D + 16)
+#define SPR_DMR2        (SPRGROUP_D + 17)
+#define SPR_DWCR0       (SPRGROUP_D + 18)
+#define SPR_DWCR1       (SPRGROUP_D + 19)
+#define SPR_DSR         (SPRGROUP_D + 20)
+#define SPR_DRR         (SPRGROUP_D + 21)
+#define SPR_DIR         (SPRGROUP_D + 22)
+
+/* Performance counters group */
+#define SPR_PCCR(N)     (SPRGROUP_PC + (N))
+#define SPR_PCMR(N)     (SPRGROUP_PC + 8 + (N))
+
+/* Power management group */
+#define SPR_PMR (SPRGROUP_PM + 0)
+
+/* PIC group */
+#define SPR_PICMR (SPRGROUP_PIC + 0)
+#define SPR_PICPR (SPRGROUP_PIC + 1)
+#define SPR_PICSR (SPRGROUP_PIC + 2)
+
+/* Tick Timer group */
+#define SPR_TTMR (SPRGROUP_TT + 0)
+#define SPR_TTCR (SPRGROUP_TT + 1)
+
+/*
+ * Bit definitions for the Version Register
+ *
+ */
+#define SPR_VR_VER      0xffff0000  /* Processor version */
+#define SPR_VR_REV      0x0000003f  /* Processor revision */
+
+/*
+ * Bit definitions for the Unit Present Register
+ *
+ */
+#define SPR_UPR_UP      0x00000001  /* UPR present */
+#define SPR_UPR_DCP     0x00000002  /* Data cache present */
+#define SPR_UPR_ICP     0x00000004  /* Instruction cache present */
+#define SPR_UPR_DMP     0x00000008  /* Data MMU present */
+#define SPR_UPR_IMP     0x00000010  /* Instruction MMU present */
+#define SPR_UPR_OB32P   0x00000020  /* ORBIS32 present */
+#define SPR_UPR_OB64P   0x00000040  /* ORBIS64 present */
+#define SPR_UPR_OF32P   0x00000080  /* ORFPX32 present */
+#define SPR_UPR_OF64P   0x00000100  /* ORFPX64 present */
+#define SPR_UPR_OV32P   0x00000200  /* ORVDX32 present */
+#define SPR_UPR_OV64P   0x00000400  /* ORVDX64 present */
+#define SPR_UPR_DUP     0x00000800  /* Debug unit present */
+#define SPR_UPR_PCUP    0x00001000  /* Performance counters unit present */
+#define SPR_UPR_PMP     0x00002000  /* Power management present */
+#define SPR_UPR_PICP    0x00004000  /* PIC present */
+#define SPR_UPR_TTP     0x00008000  /* Tick timer present */
+#define SPR_UPR_SRP     0x00010000  /* Shadow registers present */
+#define SPR_UPR_RES     0x00fe0000  /* ORVDX32 present */
+#define SPR_UPR_CUST    0xff000000  /* Custom units */
+
+/*
+ * Bit definitions for the Supervision Register
+ *
+ */
+#define SPR_SR_CID      0xf0000000  /* Context ID */
+#define SPR_SR_FO       0x00008000  /* Fixed one */
+#define SPR_SR_EPH      0x00004000  /* Exception Prefixi High */
+#define SPR_SR_DSX      0x00002000  /* Delay Slot Exception */
+#define SPR_SR_OVE      0x00001000  /* Overflow flag Exception */
+#define SPR_SR_OV       0x00000800  /* Overflow flag */
+#define SPR_SR_CY       0x00000400  /* Carry flag */
+#define SPR_SR_F        0x00000200  /* Condition Flag */
+#define SPR_SR_CE       0x00000100  /* CID Enable */
+#define SPR_SR_LEE      0x00000080  /* Little Endian Enable */
+#define SPR_SR_IME      0x00000040  /* Instruction MMU Enable */
+#define SPR_SR_DME      0x00000020  /* Data MMU Enable */
+#define SPR_SR_ICE      0x00000010  /* Instruction Cache Enable */
+#define SPR_SR_DCE      0x00000008  /* Data Cache Enable */
+#define SPR_SR_IEE      0x00000004  /* Interrupt Exception Enable */
+#define SPR_SR_TEE      0x00000002  /* Tick timer Exception Enable */
+#define SPR_SR_SM       0x00000001  /* Supervisor Mode */
+#define SPR_SR_FO_BIT    15
+#define SPR_SR_EPH_BIT   14
+#define SPR_SR_DSX_BIT   13
+#define SPR_SR_OVE_BIT   12
+#define SPR_SR_OV_BIT    11
+#define SPR_SR_CY_BIT    10
+#define SPR_SR_F_BIT     9
+#define SPR_SR_CE_BIT    8
+#define SPR_SR_LEE_BIT   7
+#define SPR_SR_IME_BIT   6
+#define SPR_SR_DME_BIT   5
+#define SPR_SR_ICE_BIT   4
+#define SPR_SR_DCE_BIT   3
+#define SPR_SR_IEE_BIT   2
+#define SPR_SR_TEE_BIT   1
+#define SPR_SR_SM_BIT    0
+
+
+/*
+ * Bit definitions for the Data MMU Control Register
+ *
+ */
+#define SPR_DMMUCR_P2S  0x0000003e  /* Level 2 Page Size */
+#define SPR_DMMUCR_P1S  0x000007c0  /* Level 1 Page Size */
+#define SPR_DMMUCR_VADDR_WIDTH  0x0000f800  /* Virtual ADDR Width */
+#define SPR_DMMUCR_PADDR_WIDTH  0x000f0000  /* Physical ADDR Width */
+
+/*
+ * Bit definitions for the Instruction MMU Control Register
+ *
+ */
+#define SPR_IMMUCR_P2S  0x0000003e  /* Level 2 Page Size */
+#define SPR_IMMUCR_P1S  0x000007c0  /* Level 1 Page Size */
+#define SPR_IMMUCR_VADDR_WIDTH  0x0000f800  /* Virtual ADDR Width */
+#define SPR_IMMUCR_PADDR_WIDTH  0x000f0000  /* Physical ADDR Width */
+
+/*
+ * Bit definitions for the Data TLB Match Register
+ *
+ */
+#define SPR_DTLBMR_V    0x00000001  /* Valid */
+#define SPR_DTLBMR_PL1  0x00000002  /* Page Level 1 (if 0 then PL2) */
+#define SPR_DTLBMR_CID  0x0000003c  /* Context ID */
+#define SPR_DTLBMR_LRU  0x000000c0  /* Least Recently Used */
+#define SPR_DTLBMR_VPN  0xfffff000  /* Virtual Page Number */
+
+/*
+ * Bit definitions for the Data TLB Translate Register
+ *
+ */
+#define SPR_DTLBTR_CC   0x00000001  /* Cache Coherency */
+#define SPR_DTLBTR_CI   0x00000002  /* Cache Inhibit */
+#define SPR_DTLBTR_WBC  0x00000004  /* Write-Back Cache */
+#define SPR_DTLBTR_WOM  0x00000008  /* Weakly-Ordered Memory */
+#define SPR_DTLBTR_A    0x00000010  /* Accessed */
+#define SPR_DTLBTR_D    0x00000020  /* Dirty */
+#define SPR_DTLBTR_URE  0x00000040  /* User Read Enable */
+#define SPR_DTLBTR_UWE  0x00000080  /* User Write Enable */
+#define SPR_DTLBTR_SRE  0x00000100  /* Supervisor Read Enable */
+#define SPR_DTLBTR_SWE  0x00000200  /* Supervisor Write Enable */
+#define SPR_DTLBTR_PPN  0xfffff000  /* Physical Page Number */
+#define DTLBTR_NO_LIMIT ( SPR_DTLBTR_URE |  \
+                          SPR_DTLBTR_UWE |  \
+                          SPR_DTLBTR_SRE |  \
+                          SPR_DTLBTR_SWE )
+
+/*
+ * Bit definitions for the Instruction TLB Match Register
+ *
+ */
+#define SPR_ITLBMR_V    0x00000001  /* Valid */
+#define SPR_ITLBMR_PL1  0x00000002  /* Page Level 1 (if 0 then PL2) */
+#define SPR_ITLBMR_CID  0x0000003c  /* Context ID */
+#define SPR_ITLBMR_LRU  0x000000c0  /* Least Recently Used */
+#define SPR_ITLBMR_VPN  0xfffff000  /* Virtual Page Number */
+
+/*
+ * Bit definitions for the Instruction TLB Translate Register
+ *
+ */
+#define SPR_ITLBTR_CC   0x00000001  /* Cache Coherency */
+#define SPR_ITLBTR_CI   0x00000002  /* Cache Inhibit */
+#define SPR_ITLBTR_WBC  0x00000004  /* Write-Back Cache */
+#define SPR_ITLBTR_WOM  0x00000008  /* Weakly-Ordered Memory */
+#define SPR_ITLBTR_A    0x00000010  /* Accessed */
+#define SPR_ITLBTR_D    0x00000020  /* Dirty */
+#define SPR_ITLBTR_SXE  0x00000040  /* User Read Enable */
+#define SPR_ITLBTR_UXE  0x00000080  /* User Write Enable */
+#define SPR_ITLBTR_PPN  0xfffff000  /* Physical Page Number */
+#define ITLBTR_NO_LIMIT (SPR_ITLBTR_SXE | SPR_ITLBTR_UXE)
+
+/*
+ * Bit definitions for Data Cache Control register
+ *
+ */
+#define SPR_DCCR_EW     0x000000ff  /* Enable ways */
+
+/*
+ * Bit definitions for Insn Cache Control register
+ *
+ */
+#define SPR_ICCR_EW     0x000000ff  /* Enable ways */
+
+/*
+ * Bit definitions for Debug Control registers
+ *
+ */
+#define SPR_DCR_DP      0x00000001  /* DVR/DCR present */
+#define SPR_DCR_CC      0x0000000e  /* Compare condition */
+#define SPR_DCR_SC      0x00000010  /* Signed compare */
+#define SPR_DCR_CT      0x000000e0  /* Compare to */
+
+/*
+ * Bit definitions for Debug Mode 1 register
+ *
+ */
+#define SPR_DMR1_CW0    0x00000003  /* Chain watchpoint 0 */
+#define SPR_DMR1_CW1    0x0000000c  /* Chain watchpoint 1 */
+#define SPR_DMR1_CW2    0x00000030  /* Chain watchpoint 2 */
+#define SPR_DMR1_CW3    0x000000c0  /* Chain watchpoint 3 */
+#define SPR_DMR1_CW4    0x00000300  /* Chain watchpoint 4 */
+#define SPR_DMR1_CW5    0x00000c00  /* Chain watchpoint 5 */
+#define SPR_DMR1_CW6    0x00003000  /* Chain watchpoint 6 */
+#define SPR_DMR1_CW7    0x0000c000  /* Chain watchpoint 7 */
+#define SPR_DMR1_CW8    0x00030000  /* Chain watchpoint 8 */
+#define SPR_DMR1_CW9    0x000c0000  /* Chain watchpoint 9 */
+#define SPR_DMR1_CW10   0x00300000  /* Chain watchpoint 10 */
+#define SPR_DMR1_ST     0x00400000  /* Single-step trace*/
+#define SPR_DMR1_BT     0x00800000  /* Branch trace */
+#define SPR_DMR1_DXFW   0x01000000  /* Disable external force watchpoint */
+
+/*
+ * Bit definitions for Debug Mode 2 register
+ *
+ */
+#define SPR_DMR2_WCE0   0x00000001  /* Watchpoint counter 0 enable */
+#define SPR_DMR2_WCE1   0x00000002  /* Watchpoint counter 0 enable */
+#define SPR_DMR2_AWTC   0x00001ffc  /* Assign watchpoints to counters */
+#define SPR_DMR2_WGB    0x00ffe000  /* Watchpoints generating breakpoint */
+
+/*
+ * Bit definitions for Debug watchpoint counter registers
+ *
+ */
+#define SPR_DWCR_COUNT  0x0000ffff  /* Count */
+#define SPR_DWCR_MATCH  0xffff0000  /* Match */
+
+/*
+ * Bit definitions for Debug stop register
+ *
+ */
+#define SPR_DSR_RSTE    0x00000001  /* Reset exception */
+#define SPR_DSR_BUSEE   0x00000002  /* Bus error exception */
+#define SPR_DSR_DPFE    0x00000004  /* Data Page Fault exception */
+#define SPR_DSR_IPFE    0x00000008  /* Insn Page Fault exception */
+#define SPR_DSR_LPINTE  0x00000010  /* Low priority interrupt exception */
+#define SPR_DSR_AE      0x00000020  /* Alignment exception */
+#define SPR_DSR_IIE     0x00000040  /* Illegal Instruction exception */
+#define SPR_DSR_HPINTE  0x00000080  /* High priority interrupt exception */
+#define SPR_DSR_DME     0x00000100  /* DTLB miss exception */
+#define SPR_DSR_IME     0x00000200  /* ITLB miss exception */
+#define SPR_DSR_RE      0x00000400  /* Range exception */
+#define SPR_DSR_SCE     0x00000800  /* System call exception */
+#define SPR_DSR_BE      0x00001000  /* Breakpoint exception */
+
+/*
+ * Bit definitions for Debug reason register
+ *
+ */
+#define SPR_DRR_RSTE    0x00000001  /* Reset exception */
+#define SPR_DRR_BUSEE   0x00000002  /* Bus error exception */
+#define SPR_DRR_DPFE    0x00000004  /* Data Page Fault exception */
+#define SPR_DRR_IPFE    0x00000008  /* Insn Page Fault exception */
+#define SPR_DRR_LPINTE  0x00000010  /* Low priority interrupt exception */
+#define SPR_DRR_AE      0x00000020  /* Alignment exception */
+#define SPR_DRR_IIE     0x00000040  /* Illegal Instruction exception */
+#define SPR_DRR_HPINTE  0x00000080  /* High priority interrupt exception */
+#define SPR_DRR_DME     0x00000100  /* DTLB miss exception */
+#define SPR_DRR_IME     0x00000200  /* ITLB miss exception */
+#define SPR_DRR_RE      0x00000400  /* Range exception */
+#define SPR_DRR_SCE     0x00000800  /* System call exception */
+#define SPR_DRR_BE      0x00001000  /* Breakpoint exception */
+
+/*
+ * Bit definitions for Performance counters mode registers
+ *
+ */
+#define SPR_PCMR_CP     0x00000001  /* Counter present */
+#define SPR_PCMR_UMRA   0x00000002  /* User mode read access */
+#define SPR_PCMR_CISM   0x00000004  /* Count in supervisor mode */
+#define SPR_PCMR_CIUM   0x00000008  /* Count in user mode */
+#define SPR_PCMR_LA     0x00000010  /* Load access event */
+#define SPR_PCMR_SA     0x00000020  /* Store access event */
+#define SPR_PCMR_IF     0x00000040  /* Instruction fetch event*/
+#define SPR_PCMR_DCM    0x00000080  /* Data cache miss event */
+#define SPR_PCMR_ICM    0x00000100  /* Insn cache miss event */
+#define SPR_PCMR_IFS    0x00000200  /* Insn fetch stall event */
+#define SPR_PCMR_LSUS   0x00000400  /* LSU stall event */
+#define SPR_PCMR_BS     0x00000800  /* Branch stall event */
+#define SPR_PCMR_DTLBM  0x00001000  /* DTLB miss event */
+#define SPR_PCMR_ITLBM  0x00002000  /* ITLB miss event */
+#define SPR_PCMR_DDS    0x00004000  /* Data dependency stall event */
+#define SPR_PCMR_WPE    0x03ff8000  /* Watchpoint events */
+
+/* 
+ * Bit definitions for the Power management register
+ *
+ */
+#define SPR_PMR_SDF     0x00000001  /* Slow down factor */
+#define SPR_PMR_DME     0x00000002  /* Doze mode enable */
+#define SPR_PMR_SME     0x00000004  /* Sleep mode enable */
+#define SPR_PMR_DCGE    0x00000008  /* Dynamic clock gating enable */
+#define SPR_PMR_SUME    0x00000010  /* Suspend mode enable */
+
+/*
+ * Bit definitions for PICMR
+ *
+ */
+#define SPR_PICMR_IUM   0xfffffffc  /* Interrupt unmask */
+
+/*
+ * Bit definitions for PICPR
+ *
+ */
+#define SPR_PICPR_IPRIO 0xfffffffc  /* Interrupt priority */
+
+/*
+ * Bit definitions for PICSR
+ *
+ */
+#define SPR_PICSR_IS    0xffffffff  /* Interrupt status */
+
+/*
+ * Bit definitions for Tick Timer Control Register
+ *
+ */
+#define SPR_TTCR_PERIOD 0x0fffffff  /* Time Period */
+#define SPR_TTMR_PERIOD SPR_TTCR_PERIOD
+#define SPR_TTMR_IP 0x10000000  /* Interrupt Pending */
+#define SPR_TTMR_IE 0x20000000  /* Interrupt Enable */
+#define SPR_TTMR_RT 0x40000000  /* Restart tick */
+#define SPR_TTMR_SR     0x80000000  /* Single run */
+#define SPR_TTMR_CR     0xc0000000  /* Continuous run */
+#define SPR_TTMR_M      0xc0000000  /* Tick mode */
+
+#endif
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/string.h u-boot-2009.03/include/asm-or1200/string.h
--- u-boot-2009.03_orig/include/asm-or1200/string.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/string.h	2008-07-02 09:36:02.312500000 -0700
@@ -0,0 +1,18 @@
+#ifndef _OR32_STRING_H
+#define _OR32_STRING_H
+
+
+/* __PHX_TODO__: these are optimizations, will do later */
+#if 0
+
+#define __HAVE_ARCH_MEMCPY
+extern void *memcpy(void *, const void *, size_t);
+
+/* New and improved.  In arch/cris/lib/memset.c */
+
+#define __HAVE_ARCH_MEMSET
+extern void *memset(void *, int, size_t);
+
+#endif
+
+#endif
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/system.h u-boot-2009.03/include/asm-or1200/system.h
--- u-boot-2009.03_orig/include/asm-or1200/system.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/system.h	2008-07-02 09:36:02.312500000 -0700
@@ -0,0 +1,124 @@
+/*
+ * Based on:
+ * include/asm-ppc/system.h
+ * Copyright (C) 1999 Cort Dougan <cort@cs.nmt.edu>
+ */
+#ifndef __OR32_SYSTEM_H
+#define __OR32_SYSTEM_H
+
+#include <asm/processor.h>
+
+/* Memory bariers */
+#define barrier() __asm__ __volatile__("": : :"memory")
+#define mb() barrier()
+#define rmb() mb()
+#define wmb() mb()
+#define read_barrier_depends() do { } while(0)
+#define set_mb(var, value)  do { var = value; mb(); } while (0)
+#define set_wmb(var, value) do { var = value; wmb(); } while (0)
+
+#ifdef CONFIG_SMP
+#define smp_mb()        mb()
+#define smp_rmb()       rmb()
+#define smp_wmb()       wmb()
+#define smp_read_barrier_depends()     read_barrier_depends()
+#else
+#define smp_mb()        barrier()
+#define smp_rmb()       barrier()
+#define smp_wmb()       barrier()
+#define smp_read_barrier_depends()     do { } while(0)
+#endif
+
+#define nop() __asm__ __volatile__ ("l.nop"::)
+
+#ifdef __KERNEL__
+
+struct task_struct;
+extern unsigned int rtas_data;
+struct pt_regs;
+
+extern void show_regs(struct pt_regs * regs);
+
+extern void __save_flags(unsigned long *flags);
+extern void __restore_flags(unsigned long flags);
+extern void __save_and_cli(unsigned long *flags);
+extern void __sti(void);
+extern void __cli(void);
+
+
+#define local_irq_disable()		__cli()
+#define local_irq_enable()		__sti()
+#define local_irq_save(flags)		__save_and_cli(&(flags))
+#define local_irq_restore(flags)	__restore_flags(flags)
+#define local_save_flags(flags)         __save_flags(&(flags))
+
+#define prepare_to_switch()	do { } while(0)
+#define switch_to(prev,next,last) _switch_to((prev),(next),&(last))
+
+extern void _switch_to(struct task_struct *, struct task_struct *,
+		       struct task_struct **);
+
+struct __xchg_dummy { unsigned long a[100]; };
+#define __xg(x) ((volatile struct __xchg_dummy *)(x))
+#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+#define tas(ptr) (xchg((ptr),1))
+
+static inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
+{
+  unsigned long tmp, flags;
+
+  local_irq_save(flags);
+
+  switch (size) {
+  case 1:
+    __asm__ __volatile__
+    ("l.lbz %0,%2\n\t"
+     "l.sb %2,%1"
+    : "=&r" (tmp) : "r" (x), "m" (*__xg(ptr)) : "memory");
+    break;
+  case 2:
+    __asm__ __volatile__
+    ("l.lhz %0,%2\n\t"
+     "l.sh %2,%1"
+    : "=&r" (tmp) : "r" (x), "m" (*__xg(ptr)) : "memory");
+    break;
+  case 4:
+    __asm__ __volatile__
+    ("l.lwz %0,%2\n\t"
+     "l.sw %2,%1"
+    : "=&r" (tmp) : "r" (x), "m" (*__xg(ptr)) : "memory");
+    break;
+  }
+
+  local_irq_restore(flags);
+  return tmp;
+}
+
+extern inline void * xchg_ptr(void * m, void * val)
+{
+	return (void *) __xchg((unsigned long)m, val, sizeof(unsigned long));
+}
+
+static inline void mtspr(unsigned long add, unsigned long val)
+{
+	__asm__ __volatile__ ("l.mtspr %0,%1,0" :: "r" (add), "r" (val));
+}
+
+static inline unsigned long mfspr(unsigned long add)
+{
+	unsigned long ret;
+	__asm__ __volatile__ ("l.mfspr %0,%1,0" : "=r" (ret) : "r" (add));
+	return ret;
+}
+
+#define irqs_disabled() ((mfspr(SPR_SR) & (SPR_SR_IEE | SPR_SR_TEE)) == 0)
+
+#define arch_align_stack(x) (x)
+
+/*
+ * debugging aid
+ */
+extern void __print(const char *fmt, ...);
+
+#endif /* __KERNEL__ */
+#endif /* __OR32_SYSTEM_H */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/types.h u-boot-2009.03/include/asm-or1200/types.h
--- u-boot-2009.03_orig/include/asm-or1200/types.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/types.h	2008-08-26 18:29:36.849449500 -0700
@@ -0,0 +1,62 @@
+#ifndef _ETRAX_TYPES_H
+#define _ETRAX_TYPES_H
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+/*typedef unsigned atomic_long_t;RGD I don't get this now using generic*/
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+/* Dma addresses are 32-bits wide, just like our other addresses.  */
+ 
+typedef u32 dma_addr_t;
+typedef u32 dma64_addr_t;
+
+typedef unsigned long phys_addr_t;
+typedef unsigned long phys_size_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/asm-or1200/u-boot.h u-boot-2009.03/include/asm-or1200/u-boot.h
--- u-boot-2009.03_orig/include/asm-or1200/u-boot.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/asm-or1200/u-boot.h	2008-09-05 09:57:00.265625000 -0700
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright 2004 Atmark Techno, Inc.
+ *
+ * Yasushi SHOJI <yashi@atmark-techno.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ ********************************************************************
+ * NOTE: This header file defines an interface to U-Boot. Including
+ * this (unmodified) header file in another file is considered normal
+ * use of U-Boot, and does *not* fall under the heading of "derived
+ * work".
+ ********************************************************************
+ */
+
+#ifndef _U_BOOT_H_
+#define _U_BOOT_H_
+
+typedef struct bd_info {
+	unsigned long	bi_boot_params;	/* start of DRAM memory */
+	unsigned long	bi_memstart;	/* start of DRAM memory */
+	unsigned long	bi_memsize;	/* size	 of DRAM memory in bytes */
+	unsigned long	bi_flashstart;	/* start of FLASH memory */
+	unsigned long	bi_flashsize;	/* size	 of FLASH memory */
+	unsigned long	bi_flashoffset; /* reserved area for startup monitor */
+	unsigned long	bi_sramstart;	/* start of SRAM memory */
+	unsigned long	bi_sramsize;	/* size	 of SRAM memory */
+	unsigned long	bi_ip_addr;	/* IP Address */
+	unsigned char	bi_enetaddr[6]; /* Ethernet adress */
+	unsigned long	bi_baudrate;	/* Console Baudrate */
+	unsigned long	post_code;	
+} bd_t;
+
+
+#endif	/* _U_BOOT_H_ */
+
+
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/configs/Dev_Kit_060804.h u-boot-2009.03/include/configs/Dev_Kit_060804.h
--- u-boot-2009.03_orig/include/configs/Dev_Kit_060804.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/configs/Dev_Kit_060804.h	2009-03-03 14:14:42.654084000 -0800
@@ -0,0 +1,152 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+
+/*-----------------------------------------------------------------------
+ * misc configuration.
+ */
+
+#undef  CONFIG_BZIP2
+
+#undef  CONFIG_WATCHDOG
+
+#define CFG_MHZ 24
+#define CFG_HZ  (CFG_MHZ * 1000000)
+
+
+/*-----------------------------------------------------------------------
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_AUTOSCRIPT	/* Autoscript Support		*/
+#undef CONFIG_CMD_BDI		/* bdinfo			*/
+#undef CONFIG_CMD_BOOTD	/* bootd			*/
+// #undef CONFIG_CMD_CONSOLE	/* coninfo			*/
+#undef CONFIG_CMD_ECHO		/* echo arguments		*/
+#undef CONFIG_CMD_ENV		/* saveenv			*/
+#undef CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#undef CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+#undef CONFIG_CMD_LOADB	/* loadb			*/
+#undef CONFIG_CMD_LOADS	/* loads			*/
+// #undef CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop mtest */
+#undef CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+#undef CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+#undef CONFIG_CMD_RUN		/* run command in env variable	*/
+#undef CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
+#undef CONFIG_CMD_XIMG		/* Load part of Multi Image	*/
+
+
+/*-----------------------------------------------------------------------
+ * environment data configuration.
+ */
+#define	CFG_ENV_IS_NOWHERE	
+#define CFG_ENV_SIZE  1024
+#define CFG_NO_FLASH
+
+ 
+/*-----------------------------------------------------------------------
+ * boot configuration.
+ */
+#undef	CONFIG_BOOTARGS
+
+#define CONFIG_BOOTDELAY	10	/* autoboot after 10 seconds	*/
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+
+
+/*-----------------------------------------------------------------------
+ * Console configuration.
+ */
+#define	CFG_PROMPT		"Dev_Kit_060804 # "	/* Monitor Command Prompt    */
+
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+// #define CFG_HUSH_PARSER
+// #define CFG_PROMPT_HUSH_PS2	"> "
+
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+ 
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * (Set up by the startup code)
+ * Please note that CFG_SDRAM_BASE _must_ start at 0
+ */
+#define CFG_SDRAM_BASE		0x30000000
+#define CFG_SDRAM_SIZE		0x00020000
+#define CFG_FLASH_BASE		0x20000000
+#define CFG_FLASH_SIZE		0x00400000
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE)
+
+#define	CFG_MALLOC_BASE 0x30010000
+#define CFG_MALLOC_LEN		32*1024
+
+
+/*-----------------------------------------------------------------------
+ * Definitions for initial stack pointer and data area
+ */
+
+#define CFG_INIT_RAM_ADDR	0x30000000	/* inside of SDRAM */
+#define CFG_INIT_RAM_END	(CFG_INIT_RAM_ADDR + CFG_SDRAM_SIZE)		/* End of used area in RAM */
+#define CFG_INIT_DATA_SIZE	128		/* size in bytes reserved for initial data */
+#define CFG_GBL_DATA_OFFSET    (CFG_INIT_RAM_END - CFG_INIT_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+
+/*-----------------------------------------------------------------------
+ * serial port configuration.
+ */
+#define CFG_NS16550
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE    1
+#define CFG_NS16550_CLK         CFG_HZ
+#define CFG_NS16550_COM1        (0x50000000)
+#define CONFIG_CONS_INDEX	1
+
+#define CONFIG_BAUDRATE 57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+
+/*-----------------------------------------------------------------------
+ * qaz debug
+ */
+
+
+#endif	/* __CONFIG_H */
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/configs/de1_or1k.h u-boot-2009.03/include/configs/de1_or1k.h
--- u-boot-2009.03_orig/include/configs/de1_or1k.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/include/configs/de1_or1k.h	2009-03-25 17:39:02.660456000 -0700
@@ -0,0 +1,154 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * 
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+
+/*-----------------------------------------------------------------------
+ * misc configuration.
+ */
+
+#undef  CONFIG_BZIP2
+
+#undef  CONFIG_WATCHDOG
+
+#define CONFIG_CLOCKS_IN_MHZ 24
+#define CONFIG_HZ  (CONFIG_CLOCKS_IN_MHZ * 1000000)
+
+/*-----------------------------------------------------------------------
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_AUTOSCRIPT	/* Autoscript Support		*/
+#undef CONFIG_CMD_BDI		/* bdinfo			*/
+#undef CONFIG_CMD_BOOTD	/* bootd			*/
+// #undef CONFIG_CMD_CONSOLE	/* coninfo			*/
+#undef CONFIG_CMD_ECHO		/* echo arguments		*/
+#undef CONFIG_CMD_SAVEENV	/* saveenv			*/
+#undef CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#undef CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+#undef CONFIG_CMD_LOADB	/* loadb			*/
+#undef CONFIG_CMD_LOADS	/* loads			*/
+// #undef CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop mtest */
+#undef CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+#undef CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+#undef CONFIG_CMD_RUN		/* run command in env variable	*/
+#undef CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
+#undef CONFIG_CMD_XIMG		/* Load part of Multi Image	*/
+
+
+/*-----------------------------------------------------------------------
+ * environment data configuration.
+ */
+
+#define	CONFIG_ENV_IS_NOWHERE	
+#define CONFIG_ENV_SIZE 1024
+#define CONFIG_SYS_MAX_FLASH_SECT 1
+#define CONFIG_SYS_NO_FLASH
+
+ 
+/*-----------------------------------------------------------------------
+ * boot configuration.
+ */
+#undef	CONFIG_BOOTARGS
+
+#define CONFIG_BOOTDELAY	10	/* autoboot after 10 seconds	*/
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+#define CONFIG_SYS_LOAD_ADDR 0x81000000
+
+
+/*-----------------------------------------------------------------------
+ * Console configuration.
+ */
+#define CONFIG_SYS_PROMPT		"de1_or1k # "	/* Monitor Command Prompt    */
+
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS 16
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * (Set up by the startup code)
+ * Please note that CONFIG_SYS_SDRAM_BASE _must_ start at 0
+ */
+#define CONFIG_SYS_SDRAM_BASE		0x30000000
+#define CONFIG_SYS_SDRAM_SIZE		0x00020000
+#define CONFIG_SYS_FLASH_BASE		0x20000000
+#define CONFIG_SYS_FLASH_SIZE		0x00400000
+
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE)
+
+#define	CONFIG_SYS_MALLOC_BASE 0x30010000
+#define CONFIG_SYS_MALLOC_LEN		32*1024
+
+
+/*-----------------------------------------------------------------------
+ * Definitions for initial stack pointer and data area
+ */
+
+#define CONFIG_SYS_INIT_RAM_ADDR	0x30000000	/* inside of SDRAM */
+#define CONFIG_SYS_INIT_RAM_END	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_SDRAM_SIZE)		/* End of used area in RAM */
+#define CONFIG_SYS_INIT_DATA_SIZE	128		/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET    (CONFIG_SYS_INIT_RAM_END - CONFIG_SYS_INIT_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+
+/*-----------------------------------------------------------------------
+ * serial port configuration.
+ */
+
+#define CONFIG_BAUDRATE 57600
+#define CONFIG_SYS_BAUDRATE_TABLE { 9600 , 19200 , 38400 , 57600, 115200 }
+
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_REG_SIZE 1
+#define CONFIG_SYS_NS16550_COM1	(0x50000000)
+#define CONFIG_SYS_NS16550_CLK	CONFIG_HZ
+
+
+/*-----------------------------------------------------------------------
+ * qaz debug
+ */
+
+
+ 
+#endif	/* __CONFIG_H */
+
+
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/include/image.h u-boot-2009.03/include/image.h
--- u-boot-2009.03_orig/include/image.h	2009-03-21 14:04:41.000000000 -0700
+++ u-boot-2009.03/include/image.h	2009-03-25 16:04:34.525496200 -0700
@@ -478,6 +478,8 @@
 	if (!image_check_arch (hdr, IH_ARCH_SH))
 #elif defined(__sparc__)
 	if (!image_check_arch (hdr, IH_ARCH_SPARC))
+#elif defined(__or1200__)
+	if (!image_check_arch (hdr, IH_ARCH_INVALID))
 #else
 # error Unknown CPU type
 #endif
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/lib_or1200/Makefile u-boot-2009.03/lib_or1200/Makefile
--- u-boot-2009.03_orig/lib_or1200/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/lib_or1200/Makefile	2009-03-24 13:36:12.366942000 -0700
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2003-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(ARCH).a
+
+SOBJS	=
+
+COBJS	= board.o bootm.o cache.o
+
+SRCS 	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/lib_or1200/board.c u-boot-2009.03/lib_or1200/board.c
--- u-boot-2009.03_orig/lib_or1200/board.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/lib_or1200/board.c	2009-03-25 17:41:25.221131200 -0700
@@ -0,0 +1,172 @@
+/*
+ * (C) Copyright 2007 Michal Simek
+ * (C) Copyright 2004 Atmark Techno, Inc.
+ *
+ * Michal  SIMEK <monstr@monstr.eu>
+ * Yasushi SHOJI <yashi@atmark-techno.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <version.h>
+#include <watchdog.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+const char version_string[] = U_BOOT_VERSION " (" __DATE__ " - " __TIME__ ")";
+
+
+int board_early_init_f (void);
+void set_de1_post( unsigned int post_code );
+void init_de1_post( void );
+int de1_post_incr( void );
+
+
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ * aka CONFIG_SYS_MONITOR_BASE - Note there is no need for reloc_off
+ * as our monitory code is run from SDRAM
+ */
+static void mem_malloc_init (void)
+{
+	mem_malloc_end = (CONFIG_SYS_MALLOC_BASE + CONFIG_SYS_MALLOC_LEN);
+	mem_malloc_start = CONFIG_SYS_MALLOC_BASE;
+	mem_malloc_brk = mem_malloc_start;
+	
+// 	memset ((void *)mem_malloc_start, 0, mem_malloc_end - mem_malloc_start);
+	memset ((void *)mem_malloc_start, 0, 4  );
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+	ulong old = mem_malloc_brk;
+	ulong new = old + increment;
+
+	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+		return (NULL);
+	}
+	mem_malloc_brk = new;
+	return ((void *)old);
+}
+
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependend #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+init_fnc_t *init_sequence[] = {
+	env_init,
+  de1_post_incr,
+	serial_init,
+  de1_post_incr,
+	NULL,
+};
+
+void board_init (void)
+{
+	bd_t *bd;
+	init_fnc_t **init_fnc_ptr;
+	gd = (gd_t *) (CONFIG_SYS_GBL_DATA_OFFSET);
+	
+// #if defined(CONFIG_CMD_FLASH)
+// 	ulong flash_size = 0;
+// #endif
+
+	memset ((void *)gd, 0, CONFIG_SYS_INIT_DATA_SIZE);
+	gd->bd = (bd_t *) (gd + 1);	/* At end of global data */
+	gd->baudrate = CONFIG_BAUDRATE;
+	bd = gd->bd;
+	bd->bi_baudrate = CONFIG_BAUDRATE;
+	bd->bi_memstart = CONFIG_SYS_SDRAM_BASE;
+	bd->bi_memsize = CONFIG_SYS_SDRAM_SIZE;
+
+  init_de1_post();
+	
+	/* Initialise malloc() area */
+	mem_malloc_init ();
+	
+  set_de1_post(0x00000100);
+  
+  board_early_init_f();
+  
+  set_de1_post(0x00000200);
+
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+  	
+  	de1_post_incr();
+		WATCHDOG_RESET ();
+		de1_post_incr();
+		
+		if ((*init_fnc_ptr) () != 0) {
+			hang ();
+		}
+	}
+	
+  set_de1_post(0x00000300);
+
+// #if defined(CONFIG_CMD_FLASH)
+// 	bd->bi_flashstart = CONFIG_SYS_FLASH_BASE;
+// 	if (0 < (flash_size = flash_init ())) {
+// 		bd->bi_flashsize = flash_size;
+// 		bd->bi_flashoffset = CONFIG_SYS_FLASH_BASE + flash_size;
+// 	} else {
+// 		puts ("Flash init FAILED");
+// 		bd->bi_flashstart = 0;
+// 		bd->bi_flashsize = 0;
+// 		bd->bi_flashoffset = 0;
+// 	}
+// #endif
+
+	/* relocate environment function pointers etc. */
+	env_relocate ();
+
+  set_de1_post(0x00000400);
+  
+	/* main_loop */
+	for (;;) {
+		WATCHDOG_RESET ();
+		main_loop ();
+	}
+}
+
+void hang (void)
+{
+	puts ("### ERROR ### Please RESET the board ###\n");
+	for (;;) ;
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/lib_or1200/bootm.c u-boot-2009.03/lib_or1200/bootm.c
--- u-boot-2009.03_orig/lib_or1200/bootm.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/lib_or1200/bootm.c	2009-03-24 13:36:12.351353000 -0700
@@ -0,0 +1,34 @@
+/*
+ * (C) Copyright 2003, Psyent Corporation <www.psyent.com>
+ * Scott McNutt <smcnutt@psyent.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+/* FIXME: Once we find a stable version of uC-linux for nios
+ * we can get this working. ;-)
+ *
+ */
+void do_bootm_linux(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
+		bootm_headers_t *images)
+{
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/lib_or1200/cache.c u-boot-2009.03/lib_or1200/cache.c
--- u-boot-2009.03_orig/lib_or1200/cache.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/lib_or1200/cache.c	2009-03-24 13:36:12.351353000 -0700
@@ -0,0 +1,32 @@
+/*
+ * (C) Copyright 2003, Psyent Corporation <www.psyent.com>
+ * Scott McNutt <smcnutt@psyent.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+void flush_cache (ulong addr, ulong size)
+{
+	/* Nios cache is write-thru -- nothing to do here.
+	 */
+	return;
+}
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/or1200_config.mk u-boot-2009.03/or1200_config.mk
--- u-boot-2009.03_orig/or1200_config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2009.03/or1200_config.mk	2008-09-18 09:46:16.250000000 -0700
@@ -0,0 +1,28 @@
+#
+# (C) Copyright 2004 Atmark Techno, Inc.
+#
+# Yasushi SHOJI <yashi@atmark-techno.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+PLATFORM_CPPFLAGS += -D__or1200__
+
+SYM_PREFIX = _
+
diff -NaurbBw --exclude-from=diff_exclude.txt u-boot-2009.03_orig/tools/Makefile u-boot-2009.03/tools/Makefile
--- u-boot-2009.03_orig/tools/Makefile	2009-03-21 14:04:41.000000000 -0700
+++ u-boot-2009.03/tools/Makefile	2009-03-25 15:49:57.874856800 -0700
@@ -21,7 +21,8 @@
 # MA 02111-1307 USA
 #
 
-BIN_FILES	= img2srec$(SFX) mkimage$(SFX) envcrc$(SFX) ubsha1$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX)
+# BIN_FILES	= img2srec$(SFX) mkimage$(SFX) envcrc$(SFX) ubsha1$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX)
+BIN_FILES	= img2srec$(SFX) envcrc$(SFX) ubsha1$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX)
 
 OBJ_LINKS	= env_embedded.o crc32.o md5.o sha1.o image.o
 OBJ_FILES	= img2srec.o mkimage.o envcrc.o ubsha1.o gen_eth_addr.o bmp_logo.o
