FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 1
BOOTROM.x68

                                             ;------------------------------------------------------------------------------
                                             ; 0x00000 to 0x00007	boot vector
                                             ; 0x00008 to 0x003ff	interrupt vectors
                                             ; 0x00400 to 0x			system variables
                                             ; 0x10000 to 0x1ffff	thread control blocks
                                             ; 0x20000 to 0x3ffff	bitmap memory, page 1
                                             ; 0x40000 to 0x5ffff	bitmap memory, page 2
                                             ; 0x60000 to 0x7ffff	initial thread stacks
                                             ;------------------------------------------------------------------------------
                                             INACTIVE	EQU		0x0000
                                             ACTIVE		EQU		0x0001
                                             
                                             CR	EQU	0x0D		;ASCII equates
                                             LF	EQU	0x0A
                                             TAB	EQU	0x09
                                             CTRLC	EQU	0x03
                                             CTRLH	EQU	0x08
                                             CTRLS	EQU	0x13
                                             CTRLX	EQU	0x18
                                             
                                             Milliseconds	EQU		0x400
                                             Lastloc			EQU		0x404
                                             ScreenPtr	EQU		0x410
                                             ScreenColor	EQU		0x414
                                             CursorRow	EQU		0x418
                                             CursorCol	EQU		0x41A
                                             KeybdEcho	EQU		0x41C
                                             PenColor	EQU		0x420
                                             PenColor8	EQU		0x424
                                             FillColor	EQU		0x428
                                             FillColor8	EQU		0x42C
                                             DrawPos		EQU		0x430
                                             KeybdBuffer	EQU		0x440
                                             KeybdHead	EQU		0x450
                                             KeybdTail	EQU		0x452
                                             Keybuf		EQU		0x460
                                             memend		EQU		0x500
                                             scratch1	EQU		0x700
                                             S19StartAddress	EQU		0x800
                                             KEYBD		EQU		0xFFDC0000
                                             TEXTSCR		EQU		0xFFD00000
                                             COLORSCR	EQU		0xFFD10000
                                             PSG			EQU		0xFFD40000
                                             SPRITERAM	EQU		0xFFD80000
                                             PSG_FREQUENCY0	EQU		0xFFD40000
                                             PSG_PULSEWIDTH0	EQU		0xFFD40002
                                             PSG_CTRL0		EQU		0xFFD40004
                                             PSG_ATTACK0		EQU		0xFFD40008
                                             PSG_DECAY0		EQU		0xFFD4000A
                                             PSG_SUSTAIN0	EQU		0xFFD4000C
                                             PSG_RELEASE0	EQU		0xFFD4000E
                                             PSG_MASTVOL		EQU		0xFFD40040
                                             BITMAPSCR	EQU		0x00020000
                                             UART		EQU		0xFFDC0A00
                                             UART_LS		EQU		UART+1
                                             UART_CTRL	EQU		UART+7
                                             RANDOM		EQU		0xFFDC0C00
                                             TEXTCTRL	EQU		0xFFDA0000
                                             TEXT_COLS	EQU		0xFFDA0000
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 2
BOOTROM.x68
                                             TEXT_ROWS	EQU		0xFFDA0002
                                             TEXT_CURPOS	EQU		0xFFDA0016
                                             STACK		EQU		0xFFFE07FC
                                             TMPPMOD		EQU		0xFFDC0300
                                             GRAPHICS	EQU		0xFFDAE000
                                             G_DRAWLINE	EQU		0x0002
                                             
                                             ; AOS System Calls
                                             
                                             AOS_TASK_ON		EQU		0x01
                                             AOS_TASK_OFF	EQU		0x42
                                             AOS_TASK_STAT	EQU		0x03
                                             AOS_TASK_ID		EQU		0x44
                                             AOS_POSTBOX		EQU		0x48
                                             AOS_SEND		EQU		0x09
                                             AOS_SENDX		EQU		0x0B
                                             AOS_RECEIVE		EQU		0x4A
                                             AOS_TIME_SET	EQU		0x10
                                             AOS_TIME_READ	EQU		0x11
                                             AOS_TICK		EQU		0x12
                                             AOS_DELAY		EQU		0x53
                                             AOS_PUTCHAR		EQU		0x18
                                             AOS_GETCHAR		EQU		0x19
                                             AOS_KEYSTAT		EQU		0x1A
                                             AOS_TRANSTAT	EQU		0x1B
                                             AOS_GT_CPT		EQU		0x20
                                             AOS_G_STK		EQU		0xA1
                                             AOS_RES_TASK	EQU		0x22
                                             
                                             EMPTY   EQU     0
                                             LETTE   EQU     2     ;          TASK MAILBOXES HOLD ONLY 2 LETTERS;
                                             LETTERS EQU     8     ;          OUR MAILBOX HOLDS 8 LETTERS;
                                             
                                             ;*
                                             ;*============== BREAKPOINT EQUATES:
                                             ;*
                                             MSIZE   EQU     8      ;         SIZE, OR WIDTH OF LETTERS IN MAIL BOX;
                                             NUMBPS  EQU     8      ;         EIGHT BREAKPOINTS ARE ALLOWED;
                                             ;*
                                             
                                             
                                             ;*
                                             ;*  Now set up stack frames for dummy tasks.  Each task must have mail box.
                                             ;*
                                             		BSS					; suppress output
                                                     ORG     0
    106 00000000                             A5L     dc.l	0
                                             MFRAM	EQU     $
    108 00000004                                     dc.l	0
                                             STATZ	EQU     $-MFRAM
    110 00000008                                     dc.w    2			;   Reserve space for mailbox flag;
                                             MLFLAG	EQU     $-MFRAM
    112 0000000A                                     dc.w    2           ;   Reserve space for number of letters;
                                             MXLTRS	EQU     $-MFRAM
    114 0000000C                                     fill.l  4,0xffffffff	;  _LONG*4         LEAVE ROOM FOR 2 LETTERS;
                                             PSIZ	EQU     $-MFRAM
                                              
                                              		CODE
                                             ;
                                             ;                       --------------------- 
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 3
BOOTROM.x68
                                             ;               $XX00  |  V    L    I    D   |
                                             ;                      |---------------------|
                                             ;               $XX04  |      RAMPTR         |
                                             ;                      |---------------------|
                                             ;               $XX08  |      RAMSIZE        |
                                             ;                      |---------------------|
                                             ;               $XX0C  |      AUXRST         |
                                             ;                      |---------------------|
                                             ;               $XX10  |      AUXDSP         |
                                             ;                      |---------------------|
                                             ;               $XX14  |      SERVPTR        |
                                             ;                      |---------------------|
                                             ;               $XX18  |      DATAPTR        |
                                             ;                      |---------------------|
                                             ;               $XX1C  |      NTASKS         |
                                             ;                       --------------------- 
                                             ;
                                             
                                             	org	0xFFFF1000
                                             
    140 FFFF1000                             configTable:	
    141 FFFF1000 56 4C 49 44                 	dc.b	"VLID"
    142 FFFF1004 00100000                    	dc.l	0x0100000	; first megabyte
    143 FFFF1008 00200000                    	dc.l	0x0200000	; 2 megabytes available
    144 FFFF100C 00000000                    	dc.l	0x0000		; auxillary reset code pointer
    145 FFFF1010 00000000                    	dc.l	0x0000		; AUXDSP auxillary dispatch routine pointer
    146 FFFF1014 FFFF1074                    	dc.l	SERVEC		; SERVPTR
    147 FFFF1018 FFFF1084                    	dc.l	SSTACK		; DATAPTR
    148 FFFF101C 00000003                    	dc.l	0x00000003	; NTASKS
                                             
                                             ; Static task control block
                                             ;
                                             ;                       _______________ 
                                             ;                      |   |   |   |   |                
                                             ;              $XX20   | STARTING ADR  | --> PCTR       
                                             ;                      |___|___|___|___|_______________ 
                                             ;                      |   |   |   |   |   |   |   |   |
                                             ;              $XX24   | T | A | S | K | N | A | M | E |
                                             ;                      |___|___|___|___|___|___|___|___|
                                             ;                      |   |   |   |   |                
                                             ;              $XX2C   | S T K S I Z E |                
                                             ;                      |___|___|___|___|                
                                             ;                      |   |   |   |   |                
                                             ;              $XX30   | EDC TBLE PNTR |                
                                             ;                      |___|___|___|___|                
                                             ;                      |   |   |   |   |                
                                             ;              $XX34   |  U S R P A R  |                
                                             ;                      |___|___|___|___|                
                                             ;                      |   |   |                        
                                             ;              $XX38   | STATE |                        
                                             ;                      |___|___|                        
                                             ;                      |   |   |                        
                                             ;              $XX3A   | TSKNO |                        
                                             ;                      |___|___|            
                                             ;
                                             ;
                                             
    177 FFFF1020 FFFF1A5E                    	dc.l	StartMon
    178 FFFF1024 4D 4F 4E 49 54 4F 52 20     	dc.b	"MONITOR "
                                             
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 4
BOOTROM.x68
    180 FFFF102C 00000800                    	dc.l	0x00000800	; 2k stack
    181 FFFF1030 00000000                    	dc.l	0x00000000	; EDC table pointer
    182 FFFF1034 00000000                    	dc.l	0x00000000	; user parameter
    183 FFFF1038 0000                        	dc.w	INACTIVE
    184 FFFF103A 0001                        	dc.w	0x0001		; task #1
                                             
    186 FFFF103C FFFF2400                    	dc.l	START		; starting address
    187 FFFF1040 54 49 4E 59 20 42 41 53     	dc.b	"TINY BAS"	; Tiny basic
                                             
    189 FFFF1048 00000800                    	dc.l	0x00000800	; 2k stack required
    190 FFFF104C 00000000                    	dc.l	0x00000000	; EDC table pointer
    191 FFFF1050 00000000                    	dc.l	0x00000000	; user parameter
    192 FFFF1054 0001                        	dc.w	ACTIVE
    193 FFFF1056 0002                        	dc.w	0x0002		; task #2
                                             	
    195 FFFF1058 FFFF12EC                    	dc.l	IdleTask
    196 FFFF105C 49 44 4C 45 54 41 53 4B     	dc.b	"IDLETASK"
                                             
    198 FFFF1064 00000400                    	dc.l	0x00000400	; 1k stack
    199 FFFF1068 00000000                    	dc.l	0x00000000
    200 FFFF106C 00000000                    	dc.l	0x00000000
    201 FFFF1070 0001                        	dc.w	ACTIVE
    202 FFFF1072 0003                        	dc.w	0x0003
                                             
                                             
                                             ;*
                                             ;*============== SERVEC:
                                             ;*
                                             ;*  The service vector locations will be 16 vectors (eventually).  The
                                             ;*  first 8 are reserved for in_character, out_character, etc.  The last
                                             ;*  eight are user defined service routines.
                                             ;*
    212 FFFF1074 FFFF16B0                    SERVEC	dc.l	GET
    213 FFFF1078 FFFF16D4                    		dc.l	PUT
    214 FFFF107C FFFF1680                    		dc.l	KeyStatus
    215 FFFF1080 FFFF169A                    		dc.l	TranStatus
                                             
    217 FFFF1084 00000200                    SSTACK	dc.l	0x200	; 512 bytes system stack
                                             
                                             ;------------------------------------------------------------------------------
                                             ;------------------------------------------------------------------------------
                                             ; Clear all memory
                                             
                                             ; RAM test
                                             	even
                                             
                                             ; We clear the screen to give a visual indication that the system
                                             ; is working at all.
                                             ;
    229 FFFF1088 FF FF FF FF FF FF FF FF     	org	0xFFFF1100
    230 FFFF1090 FF FF FF FF FF FF FF FF     
    231 FFFF1098 FF FF FF FF FF FF FF FF     
    232 FFFF10A0 FF FF FF FF FF FF FF FF     
    233 FFFF10A8 FF FF FF FF FF FF FF FF     
    234 FFFF10B0 FF FF FF FF FF FF FF FF     
    235 FFFF10B8 FF FF FF FF FF FF FF FF     
    236 FFFF10C0 FF FF FF FF FF FF FF FF     
    237 FFFF10C8 FF FF FF FF FF FF FF FF     
    238 FFFF10D0 FF FF FF FF FF FF FF FF     
    239 FFFF10D8 FF FF FF FF FF FF FF FF     
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 5
BOOTROM.x68
    240 FFFF10E0 FF FF FF FF FF FF FF FF     
    241 FFFF10E8 FF FF FF FF FF FF FF FF     
    242 FFFF10F0 FF FF FF FF FF FF FF FF     
    243 FFFF10F8 FF FF FF FF FF FF FF FF     
                                             
    245 FFFF1100                             main:
    246 FFFF1100 31FC 00CE 0414              	move.w	#0xCE,ScreenColor	; blue on blue
    247 FFFF1106 11FC 0001 041C              	move.b	#1,KeybdEcho		; turn on keyboard echo
    248 FFFF110C 4EB9 FFFF 18E8              	jsr		ClearScreen
    249 FFFF1112 4278 0418                   	clr.w	CursorRow
    250 FFFF1116 4278 041A                   	clr.w	CursorCol
    251 FFFF111A 43F9 FFFF 1238              	lea		MSGRAM,a1
    252 FFFF1120 4EB9 FFFF 1858              	jsr		DisplayString
                                             
    254 FFFF1126 47F9 FFFF 1132                  lea 	main5,a3      ; get return address for ram test
    255 FFFF112C 4EF9 FFFF 1F52                  jmp 	ramtest       ; Call ram test routine. (Called this way in case there's no RAM).
    256 FFFF1132                             main5:
                                             	; setup user stack pointer
                                             	;
    259 FFFF1132 2079 FFFF 2420              	move.l	ENDMEM,a0
    260 FFFF1138 4E60                        	move.l	a0,usp
                                             
                                             	; reset the screen stuff
                                             	;	
    264 FFFF113A 31FC 00CE 0414              	move.w	#0xCE,ScreenColor	; blue on blue
    265 FFFF1140 11FC 0001 041C              	move.b	#1,KeybdEcho		; turn on keyboard echo
    266 FFFF1146 4278 0418                   	clr.w	CursorRow		; reset after RAMTEST
    267 FFFF114A 4278 041A                   	clr.w	CursorCol
                                             
                                             	; randomize sprite memory
    270 FFFF114E 223C 0000 8000              	move.l	#32768,d1
    271 FFFF1154 41F9 FFD8 0000              	lea		SPRITERAM,a0
    272 FFFF115A                             main6:
    273 FFFF115A 2039 FFDC 0C00              	move.l	RANDOM,d0
    274 FFFF1160 30C0                        	move.w	d0,(a0)+
    275 FFFF1162 5381                        	subi.l	#1,d1
    276 FFFF1164 66F4                        	bne		main6
                                             	
                                             	; setup vector table
                                             	;
    280 FFFF1166 41F9 FFFF 2022              	lea		BusError,a0
    281 FFFF116C 21C8 0008                   	move.l	a0,0x008		; set bus error vector
    282 FFFF1170 41F9 FFFF 200C              	lea		AddressError,a0
    283 FFFF1176 21C8 000C                   	move.l	a0,0x00C		; set address error vector
    284 FFFF117A 41F9 FFFF 2038              	lea		IllegalInstruction,a0
    285 FFFF1180 21C8 0010                   	move.l	a0,0x010
    286 FFFF1184 41F9 FFFF 1298              	lea		Pulse1000,a0
    287 FFFF118A 21C8 0078                   	move.l	a0,0x078		; set autovector 6
    288 FFFF118E 41F9 FFFF 1250              	lea		KeybdNMI,a0
    289 FFFF1194 21C8 007C                   	move.l	a0,0x07C		; set autovector 7
    290 FFFF1198 41F9 FFFF 0800              	lea		0xFFFF0800,a0	
    291 FFFF119E 21C8 0080                   	move.l	a0,0x080		; trap #0 AOS entry	- task switch
    292 FFFF11A2 41F9 FFFF 0400              	lea		0xFFFF0400,a0	
    293 FFFF11A8 21C8 0084                   	move.l	a0,0x084		; trap #1 AOS entry - AOS system call dispatcher
    294 FFFF11AC 41F9 FFFF 0C00              	lea		0xFFFF0C00,a0	
    295 FFFF11B2 21C8 0088                   	move.l	a0,0x088		; trap #2 AOS entry - dispatcher
    296 FFFF11B6 41F9 FFFF 1312              	lea		TRAP15,a0
    297 FFFF11BC 21C8 00BC                   	move.l	a0,0x0BC		; set trap 15 vector
                                             
    299 FFFF11C0 42B8 0400                   	clr.l	Milliseconds
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 6
BOOTROM.x68
    300 FFFF11C4 027C F000                   	andi	#0xF000,sr		; enable interrupts, stay in supervisor mode
                                             
    302 FFFF11C8 700E                        	moveq	#14,d0
    303 FFFF11CA 43F9 FFFF 1241              	lea		MSGBOOTING,a1	; Display the boot message
    304 FFFF11D0 4E4F                        	trap	#15
                                             
                                             ;	jsr		Beep
                                             
                                             	; test keyboard, wait for 'x' to be pressed
    309 FFFF11D2                             j7:
                                             ;	jmp		0xFFFF0000		; start AOS
    311 FFFF11D2 4EF9 FFFF 2400              	jmp		START
                                             
    313 FFFF11D8 7005                        	moveq	#5,d0
    314 FFFF11DA 4E4F                        	trap	#15
    315 FFFF11DC 0C01 0078                   	cmpi.b	#'x',d1
    316 FFFF11E0 66F0                        	bne		j7
                                             
                                             	; Clear bitmap memory
    319 FFFF11E2 203C 0004 0000              	move.l	#0x40000,d0
    320 FFFF11E8 41F9 0002 0000              	lea		BITMAPSCR,a0
    321 FFFF11EE 343C 1234                   	move.w	#0x1234,d2
    322 FFFF11F2                             j8:
    323 FFFF11F2 30C2                        	move.w	d2,(a0)+
    324 FFFF11F4 5380                        	subi.l	#1,d0			; can't use dbeq (>count ffff)
    325 FFFF11F6 66FA                        	bne		j8
                                             
    327 FFFF11F8 4EF9 FFFF 2400              	jmp		START			; goto tiny basic
                                             
                                             
    330 FFFF11FE 4239 FFDC 0A07              	clr.b	UART_CTRL		; turn off hardware flow control
    331 FFFF1204                             j10:
    332 FFFF1204 45F9 FFFF 0000              	lea		0xFFFF0000,a2	; start of bootstrap ROM
    333 FFFF120A                             j9:
    334 FFFF120A 121A                        	move.b	(a2)+,d1
    335 FFFF120C                             j6:	
    336 FFFF120C 1039 FFDC 0A01              	move.b	UART_LS,d0		; check line status
    337 FFFF1212 0800 0005                   	btst	#5,d0			; can we transmit more ?
    338 FFFF1216 67F4                        	beq		j6				; no, go back
    339 FFFF1218 13C1 FFDC 0A00              	move.b	d1,UART
    340 FFFF121E B5FC FFFF 0100              	cmpa.l	#0xFFFF0100,a2
    341 FFFF1224 65E4                        	blo		j9
    342 FFFF1226 60DC                        	bra		j10
    343 FFFF1228                             j2:
    344 FFFF1228 1039 FFDD 0000              	move.b	0xFFDD0000,d0
    345 FFFF122E 6AF8                        	bpl		j2
    346 FFFF1230 2079 FFDD 0004              	move.l	0xFFDD0004,a0
    347 FFFF1236 4ED0                        	jmp		(a0)
                                             
    349 FFFF1238                             MSGRAM:
    350 FFFF1238 52 41 4D 20 54 45 53 54     	dc.b	"RAM TEST",0
    351 FFFF1240 00                          
    352 FFFF1241                             MSGBOOTING:
    353 FFFF1241 42 4F 4F 54 49 4E 47 2E     	dc.b	"BOOTING....",0
    354 FFFF1249 2E 2E 2E 00                 
                                             	
    356 FFFF124D FF FF FF                    	align 	16
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Pressing Ctl-Alt-Del on the keyboard causes a keyboard NMI, the highest
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 7
BOOTROM.x68
                                             ; priority interrupt in the system. This should be almost the same as a reset.
                                             ;------------------------------------------------------------------------------
                                             ;
    363 FFFF1250                             KeybdNMI:
    364 FFFF1250 4EF9 FFFF 1100              	jmp		main
    365 FFFF1256 4E73                        	rte
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Unimplemented yet.
                                             ;
                                             ; Normal keyboard interrupt, the lowest priority interrupt in the system.
                                             ; Grab the character from the keyboard device and store it in a buffer.
                                             ;------------------------------------------------------------------------------
                                             ;
    374 FFFF1258                             KeybdIRQ:
    375 FFFF1258 48E7 C080                   	movem.l	a0/d0/d1,-(a7)
    376 FFFF125C 3238 0450                   	move.w	KeybdHead,d1
    377 FFFF1260 0241 000F                   	andi.w	#0xf,d1					; D1 = index into buffer
    378 FFFF1264 41F8 0440                   	lea		KeybdBuffer,a0
    379 FFFF1268                             KeybdIRQa:
    380 FFFF1268 3039 FFDC 0000              	move.w	KEYBD,d0				; get keyboard character
    381 FFFF126E 4279 FFDC 0002              	clr.w	KEYBD+2					; clear keyboard strobe
    382 FFFF1274 1180 1000                   	move.b	d0,(a0,d1.w)			; store character in buffer
    383 FFFF1278 5241                        	addi.w	#1,d1					; increment head index
    384 FFFF127A 0241 000F                   	andi.w	#0xF,d1
    385 FFFF127E 31C1 0450                   	move.w	d1,KeybdHead
    386 FFFF1282                             KeybdIRQb:
    387 FFFF1282 B278 0452                   	cmp.w	KeybdTail,d1			; check to see if we've collided
    388 FFFF1286 660A                        	bne		KeybdIRQc				; with the tail
    389 FFFF1288 5241                        	addi.w	#1,d1					; if so, increment the tail index
    390 FFFF128A 0241 000F                   	andi.w	#0xf,d1					; the oldest character will be lost
    391 FFFF128E 31C1 0452                   	move.w	d1,KeybdTail
    392 FFFF1292                             KeybdIRQc:
    393 FFFF1292 4CDF 0103                   	movem.l	(a7)+,a0/d0/d1
    394 FFFF1296 4E73                        	rte
                                             
                                             ;------------------------------------------------------------------------------
                                             ; 1000 Hz interrupt
                                             ; - takes care of "flashing" the cursor
                                             ;------------------------------------------------------------------------------
                                             ;
    401 FFFF1298                             Pulse1000:
    402 FFFF1298 2F00                        	move.l	d0,-(a7)
    403 FFFF129A 52B8 0400                   	add.l	#1,Milliseconds
    404 FFFF129E 5279 FFD0 0066              	add.w	#1,TEXTSCR+102
    405 FFFF12A4 4A39 FFFF 0000              	tst.b	0xFFFF0000		; clear interrupt
    406 FFFF12AA 2038 0400                   	move.l	Milliseconds,d0
    407 FFFF12AE 0200 007F                   	andi.b	#0x7f,d0
    408 FFFF12B2 0C00 0040                   	cmpi.b	#64,d0
    409 FFFF12B6 6604                        	bne		p10001
    410 FFFF12B8 6100 0006                   	bsr		FlashCursor
    411 FFFF12BC                             p10001:
                                             ;	moveq	#AOS_TICK,d0
                                             ;	trap	#1
    414 FFFF12BC 201F                        	move.l	(a7)+,d0
    415 FFFF12BE 4E73                        	rte
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Flash Cursor
                                             ;------------------------------------------------------------------------------
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 8
BOOTROM.x68
                                             ;
    421 FFFF12C0                             FlashCursor:
    422 FFFF12C0 48E7 A0C0                   	movem.l	a0/a1/d0/d2,-(a7)
    423 FFFF12C4 6100 0440                   	bsr		CalcScreenLoc
    424 FFFF12C8 D1FC 0001 0000              	adda.l	#0x10000,a0
                                             	; causes screen colors to flip around
    426 FFFF12CE 3010                        	move.w	(a0),d0		
    427 FFFF12D0 E818                        	ror.b	#4,d0
    428 FFFF12D2 3080                        	move.w	d0,(a0)
    429 FFFF12D4 B1F8 0404                   	cmpa.l	Lastloc,a0
    430 FFFF12D8 670C                        	beq		flshcrsr1
                                             	; restore the screen colors of the previous cursor location
    432 FFFF12DA 2278 0404                   	move.l	Lastloc,a1
    433 FFFF12DE 32B8 0414                   	move.w	ScreenColor,(a1)
    434 FFFF12E2 21C8 0404                   	move.l	a0,Lastloc
    435 FFFF12E6                             flshcrsr1:
    436 FFFF12E6 4CDF 0305                   	movem.l	(a7)+,a0/a1/d0/d2
    437 FFFF12EA 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ;------------------------------------------------------------------------------
    441 FFFF12EC                             IdleTask:
    442 FFFF12EC 4E55 FFE8                   	LINK    A5,#-PSIZ       ;RESERVE SPACE ON STACK FOR INPUT COMMAND LINE;
    443 FFFF12F0 41ED FFFA                       lea.l   -MLFLAG(A5),A0
    444 FFFF12F4 43ED FFFC                   	LEA.L   -STATZ(A5),A1
    445 FFFF12F8 3B7C 0000 FFFA              	MOVE.W  #EMPTY,-MLFLAG(A5)
    446 FFFF12FE 3B7C 0002 FFF8              	MOVE.W  #LETTE,-MXLTRS(A5)      ;SETUP FOR "LETTE" LETTERS (WAS 2);
    447 FFFF1304 7048                        	MOVE.L  #AOS_POSTBOX,D0
    448 FFFF1306 4E41                        	TRAP    #1                      ;POST MAILBOX;
    449 FFFF1308                             IdleTask1:
    450 FFFF1308 5279 FFD0 0064              	add.w	#1,TEXTSCR+100
    451 FFFF130E 4E40                        	trap	#0
    452 FFFF1310 60F6                        	bra		IdleTask1
                                             
                                             ;------------------------------------------------------------------------------
                                             ; TRAP #15 handler
                                             ;------------------------------------------------------------------------------
                                             ;
    458 FFFF1312                             TRAP15:
    459 FFFF1312 48E7 8080                   	movem.l	d0/a0,-(a7)
    460 FFFF1316 41F9 FFFF 1330              	lea		T15DispatchTable,a0
    461 FFFF131C 0280 0000 00FF              	andi.l	#0x0ff,d0
    462 FFFF1322 E580                        	asl.l	#2,d0
    463 FFFF1324 2070 0000                   	move.l	(a0,d0.w),a0
    464 FFFF1328 4E90                        	jsr		(a0)
    465 FFFF132A 4CDF 0101                   	movem.l	(a7)+,d0/a0
    466 FFFF132E 4E73                        	rte
                                             
    468 FFFF1330                             T15DispatchTable:
                                             ; Task 0
    470 FFFF1330 FFFF189A                    dc.l	DisplayString0
    471 FFFF1334 FFFF187A                    dc.l	DisplayString1
    472 FFFF1338 FFFF149C                    dc.l	StubRout
    473 FFFF133C FFFF19A0                    dc.l	DisplayNum3
    474 FFFF1340 FFFF149C                    dc.l	StubRout
    475 FFFF1344 FFFF1658                    dc.l	GetKey
    476 FFFF1348 FFFF1732                    dc.l	DisplayChar
    477 FFFF134C FFFF16DA                    dc.l	CheckForKey
    478 FFFF1350 FFFF149C                    dc.l	StubRout
    479 FFFF1354 FFFF149C                    dc.l	StubRout
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 9
BOOTROM.x68
                                             ; Task 10
    481 FFFF1358 FFFF149C                    dc.l	StubRout
    482 FFFF135C FFFF18A2                    dc.l	Cursor1
    483 FFFF1360 FFFF162C                    dc.l	SetKeyboardEcho
    484 FFFF1364 FFFF1872                    dc.l	DisplayStringCRLF
    485 FFFF1368 FFFF1858                    dc.l	DisplayString
    486 FFFF136C FFFF149C                    dc.l	StubRout
    487 FFFF1370 FFFF149C                    dc.l	StubRout
    488 FFFF1374 FFFF149C                    dc.l	StubRout
    489 FFFF1378 FFFF149C                    dc.l	StubRout
    490 FFFF137C FFFF149C                    dc.l	StubRout
                                             ; Task 20
    492 FFFF1380 FFFF198C                    dc.l	DisplayNum20
    493 FFFF1384 FFFF149C                    dc.l	StubRout
    494 FFFF1388 FFFF149C                    dc.l	StubRout
    495 FFFF138C FFFF149C                    dc.l	StubRout
    496 FFFF1390 FFFF149C                    dc.l	StubRout
    497 FFFF1394 FFFF149C                    dc.l	StubRout
    498 FFFF1398 FFFF149C                    dc.l	StubRout
    499 FFFF139C FFFF149C                    dc.l	StubRout
    500 FFFF13A0 FFFF149C                    dc.l	StubRout
    501 FFFF13A4 FFFF149C                    dc.l	StubRout
                                             ; Task 30
    503 FFFF13A8 FFFF149C                    dc.l	StubRout
    504 FFFF13AC FFFF149C                    dc.l	StubRout
    505 FFFF13B0 FFFF149C                    dc.l	StubRout
    506 FFFF13B4 FFFF149C                    dc.l	StubRout
    507 FFFF13B8 FFFF149C                    dc.l	StubRout
    508 FFFF13BC FFFF149C                    dc.l	StubRout
    509 FFFF13C0 FFFF149C                    dc.l	StubRout
    510 FFFF13C4 FFFF149C                    dc.l	StubRout
    511 FFFF13C8 FFFF149C                    dc.l	StubRout
    512 FFFF13CC FFFF149C                    dc.l	StubRout
                                             ; Task 40
    514 FFFF13D0 FFFF149C                    dc.l	StubRout
    515 FFFF13D4 FFFF149C                    dc.l	StubRout
    516 FFFF13D8 FFFF149C                    dc.l	StubRout
    517 FFFF13DC FFFF149C                    dc.l	StubRout
    518 FFFF13E0 FFFF149C                    dc.l	StubRout
    519 FFFF13E4 FFFF149C                    dc.l	StubRout
    520 FFFF13E8 FFFF149C                    dc.l	StubRout
    521 FFFF13EC FFFF149C                    dc.l	StubRout
    522 FFFF13F0 FFFF149C                    dc.l	StubRout
    523 FFFF13F4 FFFF149C                    dc.l	StubRout
                                             ; Task 50
    525 FFFF13F8 FFFF149C                    dc.l	StubRout
    526 FFFF13FC FFFF149C                    dc.l	StubRout
    527 FFFF1400 FFFF149C                    dc.l	StubRout
    528 FFFF1404 FFFF149C                    dc.l	StubRout
    529 FFFF1408 FFFF149C                    dc.l	StubRout
    530 FFFF140C FFFF149C                    dc.l	StubRout
    531 FFFF1410 FFFF149C                    dc.l	StubRout
    532 FFFF1414 FFFF149C                    dc.l	StubRout
    533 FFFF1418 FFFF149C                    dc.l	StubRout
    534 FFFF141C FFFF149C                    dc.l	StubRout
                                             ; Task 60
    536 FFFF1420 FFFF149C                    dc.l	StubRout
    537 FFFF1424 FFFF149C                    dc.l	StubRout
    538 FFFF1428 FFFF149C                    dc.l	StubRout
    539 FFFF142C FFFF149C                    dc.l	StubRout
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 10
BOOTROM.x68
    540 FFFF1430 FFFF149C                    dc.l	StubRout
    541 FFFF1434 FFFF149C                    dc.l	StubRout
    542 FFFF1438 FFFF149C                    dc.l	StubRout
    543 FFFF143C FFFF149C                    dc.l	StubRout
    544 FFFF1440 FFFF149C                    dc.l	StubRout
    545 FFFF1444 FFFF149C                    dc.l	StubRout
                                             ; Task 70
    547 FFFF1448 FFFF149C                    dc.l	StubRout
    548 FFFF144C FFFF149C                    dc.l	StubRout
    549 FFFF1450 FFFF149C                    dc.l	StubRout
    550 FFFF1454 FFFF149C                    dc.l	StubRout
    551 FFFF1458 FFFF149C                    dc.l	StubRout
    552 FFFF145C FFFF149C                    dc.l	StubRout
    553 FFFF1460 FFFF149C                    dc.l	StubRout
    554 FFFF1464 FFFF149C                    dc.l	StubRout
    555 FFFF1468 FFFF149C                    dc.l	StubRout
    556 FFFF146C FFFF149C                    dc.l	StubRout
                                             ; Task 80
    558 FFFF1470 FFFF149E                    dc.l	SetPenColor
    559 FFFF1474 FFFF14B4                    dc.l	SetFillColor
    560 FFFF1478 FFFF14FE                    dc.l	DrawPixel
    561 FFFF147C FFFF149C                    dc.l	StubRout
    562 FFFF1480 FFFF1528                    dc.l	DrawLine
    563 FFFF1484 FFFF159A                    dc.l	DrawLineTo
    564 FFFF1488 FFFF15B4                    dc.l	MoveTo
    565 FFFF148C FFFF15FA                    dc.l	FillRectangle
    566 FFFF1490 FFFF149C                    dc.l	StubRout
    567 FFFF1494 FFFF149C                    dc.l	StubRout
                                             ; Task 90
    569 FFFF1498 FFFF15BE                    dc.l	DrawRectangle
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Stub routine for unimplemented functionality.
                                             ;------------------------------------------------------------------------------
                                             ;
    575 FFFF149C                             StubRout:
    576 FFFF149C 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Set the graphics mode pen color
                                             ;------------------------------------------------------------------------------
    581 FFFF149E                             SetPenColor:
    582 FFFF149E 48E7 C000                   	movem.l	d0/d1,-(a7)
    583 FFFF14A2 21C1 0420                   	move.l	d1,PenColor
    584 FFFF14A6 6100 0022                   	bsr		Cvt24To8
    585 FFFF14AA 11C1 0424                   	move.b	d1,PenColor8
    586 FFFF14AE 4CDF 0003                   	movem.l	(a7)+,d0/d1
    587 FFFF14B2 4E75                        	rts
                                             
    589 FFFF14B4                             SetFillColor:
    590 FFFF14B4 48E7 C000                   	movem.l	d0/d1,-(a7)
    591 FFFF14B8 21C1 0428                   	move.l	d1,FillColor
    592 FFFF14BC 6100 000C                   	bsr		Cvt24To8
    593 FFFF14C0 11C1 042C                   	move.b	d1,FillColor8
    594 FFFF14C4 4CDF 0003                   	movem.l	(a7)+,d0/d1
    595 FFFF14C8 4E75                        	rts
                                             
    597 FFFF14CA                             Cvt24To8:
    598 FFFF14CA 48E7 A000                   	movem.l	d0/d2,-(a7)
    599 FFFF14CE 4282                        	clr.l	d2
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 11
BOOTROM.x68
    600 FFFF14D0 EC99                        	ror.l	#6,d1
    601 FFFF14D2 2001                        	move.l	d1,d0
    602 FFFF14D4 0200 0003                   	and.b	#3,d0
    603 FFFF14D8 1400                        	move.b	d0,d2
    604 FFFF14DA E499                        	ror.l	#2,d1			;
    605 FFFF14DC EA99                        	ror.l	#5,d1
    606 FFFF14DE 1001                        	move.b	d1,d0
    607 FFFF14E0 0200 0007                   	and.b	#7,d0
    608 FFFF14E4 E540                        	asl.w	#2,d0
    609 FFFF14E6 8400                        	or.b	d0,d2
    610 FFFF14E8 E699                        	ror.l	#3,d1
    611 FFFF14EA EA99                        	ror.l	#5,d1
    612 FFFF14EC 1001                        	move.b	d1,d0
    613 FFFF14EE 0200 0007                   	and.b	#7,d0
    614 FFFF14F2 EB40                        	asl.w	#5,d0
    615 FFFF14F4 8400                        	or.b	d0,d2
    616 FFFF14F6 2202                        	move.l	d2,d1
    617 FFFF14F8 4CDF 0005                   	movem.l	(a7)+,d0/d2
    618 FFFF14FC 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; d1.w = X
                                             ; d2.w = Y
                                             ;------------------------------------------------------------------------------
    624 FFFF14FE                             DrawPixel:
    625 FFFF14FE 48E7 6080                   	movem.l	a0/d1/d2,-(a7)
    626 FFFF1502 C4FC 00D0                   	mulu.w	#208,d2		; Y * 208
    627 FFFF1506 0282 0000 FFFF              	andi.l	#0xffff,d2
    628 FFFF150C E382                        	asl.l	#1,d2		; Y * 416
    629 FFFF150E 0281 0000 01FF              	and.l	#0x1ff,d1
    630 FFFF1514 D481                        	add.l	d1,d2		; Y * 416 + X
    631 FFFF1516 0682 0002 0000              	add.l	#BITMAPSCR,d2
    632 FFFF151C 2042                        	move.l	d2,a0
    633 FFFF151E 10B8 0424                   	move.b	PenColor8,(a0)
    634 FFFF1522 4CDF 0106                   	movem.l	(a7)+,a0/d1/d2
    635 FFFF1526 4E75                        	rts
                                             	
                                             ;------------------------------------------------------------------------------
                                             ; d1.w = X1
                                             ; d2.w = Y1
                                             ; d3.w = X2
                                             ; d4.w = Y2
                                             ;
                                             ; From Wikipedia:
                                             ;
                                             ;function line(x0, y0, x1, y1)
                                             ;   dx := abs(x1-x0)
                                             ;   dy := abs(y1-y0) 
                                             ;   if x0 < x1 then sx := 1 else sx := -1
                                             ;   if y0 < y1 then sy := 1 else sy := -1
                                             ;   err := dx-dy
                                             ; 
                                             ;   loop
                                             ;     setPixel(x0,y0)
                                             ;     if x0 = x1 and y0 = y1 exit loop
                                             ;     e2 := 2*err
                                             ;     if e2 > -dy then 
                                             ;       err := err - dy
                                             ;       x0 := x0 + sx
                                             ;     end if
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 12
BOOTROM.x68
                                             ;     if e2 <  dx then 
                                             ;       err := err + dx
                                             ;       y0 := y0 + sy 
                                             ;     end if
                                             ;   end loop
                                             ;
                                             ; Registers
                                             ; d1,d2,d3,d4 = X1,Y1,X2,Y2 respectively
                                             ; d0 = sx, d7 = sy
                                             ; d5 = dx, d6 = dy
                                             ; a2 = err
                                             ; a3 = 2*err
                                             ;------------------------------------------------------------------------------
    673 FFFF1528                             DrawLine:
    674 FFFF1528 48E7 FF30                   	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a2/a3,-(a7)
    675 FFFF152C 0281 0000 01FF              	andi.l	#0x1ff,d1
    676 FFFF1532 0282 0000 01FF              	andi.l	#0x1ff,d2
    677 FFFF1538 0283 0000 01FF              	andi.l	#0x1ff,d3
    678 FFFF153E 0284 0000 01FF              	andi.l	#0x1ff,d4
    679 FFFF1544 31C3 0430                   	move.w	d3,DrawPos		; X
    680 FFFF1548 31C4 0432                   	move.w	d4,DrawPos+2	; Y
    681 FFFF154C 2A01                        	move.l	d1,d5
    682 FFFF154E 9A83                        	sub.l	d3,d5
    683 FFFF1550 6A02                        	bpl		dl1
    684 FFFF1552 4485                        	neg.l	d5		; d5 = dx
    685 FFFF1554                             dl1:
    686 FFFF1554 2C02                        	move.l	d2,d6
    687 FFFF1556 9C84                        	sub.l	d4,d6
    688 FFFF1558 6A02                        	bpl		dl2
    689 FFFF155A 4486                        	neg.l	d6		; d6 = dy
    690 FFFF155C                             dl2:
    691 FFFF155C 7001                        	moveq	#1,d0	; sx = 1
    692 FFFF155E 7E01                        	moveq	#1,d7	; sy = 1
    693 FFFF1560 B283                        	cmp.l	d3,d1
    694 FFFF1562 6502                        	blo		dl3
    695 FFFF1564 4480                        	neg.l	d0		; sx = -1
    696 FFFF1566                             dl3:
    697 FFFF1566 B484                        	cmp.l	d4,d2
    698 FFFF1568 6502                        	blo		dl5
    699 FFFF156A 4487                        	neg.l	d7		; sy = -1
    700 FFFF156C                             dl5:
    701 FFFF156C 2445                        	move.l	d5,a2
    702 FFFF156E 95C6                        	suba.l	d6,a2	; err = dx-dy
    703 FFFF1570 4486                        	neg.l	d6			; -dy
                                             
    705 FFFF1572                             DrawLineLoop:
    706 FFFF1572 6100 FF8A                   	bsr		DrawPixel
    707 FFFF1576 B681                        	cmp.l	d1,d3		; x0 = x1 ?
    708 FFFF1578 6604                        	bne		dl7			; no, keep going
    709 FFFF157A B882                        	cmp.l	d2,d4		; y0 = y1 ?
    710 FFFF157C 6716                        	beq		dldone		; yes -> line draw is done
    711 FFFF157E                             dl7:
    712 FFFF157E 264A                        	move.l	a2,a3		; e2 = err
    713 FFFF1580 D7CB                        	adda.l	a3,a3		; e2 = 2*err	
    714 FFFF1582 B7C6                        	cmpa.l	d6,a3		; if (e2 > -dy)
    715 FFFF1584 6F04                        	ble		dl8
    716 FFFF1586 D5C6                        	adda.l	d6,a2		;     err = err + -dy
    717 FFFF1588 D280                        	add.l	d0,d1		;     x0 = x0 + sx
    718 FFFF158A                             dl8:
    719 FFFF158A B7C5                        	cmpa.l	d5,a3		; if (e2 < dx)
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 13
BOOTROM.x68
    720 FFFF158C 6C04                        	bge		dl9
    721 FFFF158E D5C5                        	adda.l	d5,a2		;     err = err + dx
    722 FFFF1590 D487                        	add.l	d7,d2		;     y0 = y0 + sy
    723 FFFF1592                             dl9:
    724 FFFF1592 60DE                        	bra DrawLineLoop
    725 FFFF1594                             dldone:
    726 FFFF1594 4CDF 0CFF                   	movem.l	(a7)+,d0/d1/d2/d3/d4/d5/d6/d7/a2/a3
    727 FFFF1598 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Draw line to X,Y
                                             ; D1.W = X
                                             ; D2.W = Y
                                             ;------------------------------------------------------------------------------
                                             ;
    735 FFFF159A                             DrawLineTo:
    736 FFFF159A 48E7 7800                   	movem.l	d1/d2/d3/d4,-(a7)
    737 FFFF159E 3601                        	move.w	d1,d3
    738 FFFF15A0 3802                        	move.w	d2,d4
    739 FFFF15A2 3238 0430                   	move.w	DrawPos,d1
    740 FFFF15A6 3438 0432                   	move.w	DrawPos+2,d2
    741 FFFF15AA 6100 FF7C                   	bsr		DrawLine
    742 FFFF15AE 4CDF 001E                   	movem.l	(a7)+,d1/d2/d3/d4
    743 FFFF15B2 4E75                        	rts
                                             
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Move drawing position to X,Y
                                             ; d1.w = X
                                             ; d2.w = y
                                             ;------------------------------------------------------------------------------
                                             ;
    752 FFFF15B4                             MoveTo:
    753 FFFF15B4 31C1 0430                   	move.w	d1,DrawPos
    754 FFFF15B8 31C2 0432                   	move.w	d2,DrawPos+2
    755 FFFF15BC 4E75                        	rts
                                             
    757 FFFF15BE                             DrawRectangle:
    758 FFFF15BE 48E7 FF00                   	movem.l	d0/d1/d2/d3/d4/d5/d6/d7,-(a7)
    759 FFFF15C2 3001                        	move.w	d1,d0
    760 FFFF15C4 3E02                        	move.w	d2,d7
    761 FFFF15C6 3A03                        	move.w	d3,d5
    762 FFFF15C8 3C04                        	move.w	d4,d6
    763 FFFF15CA 3802                        	move.w	d2,d4
    764 FFFF15CC 6100 FF5A                   	bsr		DrawLine
    765 FFFF15D0 3203                        	move.w	d3,d1
    766 FFFF15D2 3404                        	move.w	d4,d2
    767 FFFF15D4 3605                        	move.w	d5,d3
    768 FFFF15D6 3806                        	move.w	d6,d4
    769 FFFF15D8 6100 FF4E                   	bsr		DrawLine
    770 FFFF15DC 3203                        	move.w	d3,d1
    771 FFFF15DE 3404                        	move.w	d4,d2
    772 FFFF15E0 3600                        	move.w	d0,d3
    773 FFFF15E2 3806                        	move.w	d6,d4
    774 FFFF15E4 6100 FF42                   	bsr		DrawLine
    775 FFFF15E8 3203                        	move.w	d3,d1
    776 FFFF15EA 3404                        	move.w	d4,d2
    777 FFFF15EC 3600                        	move.w	d0,d3
    778 FFFF15EE 3807                        	move.w	d7,d4
    779 FFFF15F0 6100 FF36                   	bsr		DrawLine
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 14
BOOTROM.x68
    780 FFFF15F4 4CDF 00FF                   	movem.l	(a7)+,d0/d1/d2/d3/d4/d5/d6/d7
    781 FFFF15F8 4E75                        	rts
                                             	
                                             ;------------------------------------------------------------------------------
                                             ; Draw a filled rectangle
                                             ;------------------------------------------------------------------------------
    786 FFFF15FA                             FillRectangle:
    787 FFFF15FA 48E7 7800                   	movem.l	d1/d2/d3/d4,-(a7)
    788 FFFF15FE 3F38 0424                   	move.w	PenColor8,-(a7)
    789 FFFF1602 6100 FFBA                   	bsr 	DrawRectangle
    790 FFFF1606 31F8 042C 0424              	move.w	FillColor8,PenColor8
    791 FFFF160C                             FillRect3:
    792 FFFF160C B641                        	cmp.w	d1,d3
    793 FFFF160E 6504                        	blo		FillRect1
    794 FFFF1610 B842                        	cmp.w	d2,d4
    795 FFFF1612 640E                        	bhs		FillRect2
    796 FFFF1614                             FillRect1:
    797 FFFF1614 5241                        	addi.w	#1,d1
    798 FFFF1616 5242                        	addi.w	#1,d2
    799 FFFF1618 5343                        	subi.w	#1,d3
    800 FFFF161A 5344                        	subi.w	#1,d4
    801 FFFF161C 6100 FFA0                   	bsr		DrawRectangle
    802 FFFF1620 60EA                        	bra		FillRect3
    803 FFFF1622                             FillRect2:
    804 FFFF1622 31DF 0424                   	move.w	(a7)+,PenColor8
    805 FFFF1626 4CDF 001E                   	movem.l	(a7)+,d1/d2/d3/d4
    806 FFFF162A 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; d1.b 0=echo off, non-zero = echo on
                                             ;------------------------------------------------------------------------------
    811 FFFF162C                             SetKeyboardEcho:
    812 FFFF162C 11C1 041C                   	move.b	d1,KeybdEcho
    813 FFFF1630 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; read ascii character into d1.b
                                             ;------------------------------------------------------------------------------
                                             ;
    819 FFFF1632 4E71                        	nop
    820 FFFF1634 4E71                        	nop
    821 FFFF1636 4E71                        	nop
    822 FFFF1638 4E71                        	nop
    823 FFFF163A 4E71                        	nop
    824 FFFF163C 4E71                        	nop
    825 FFFF163E 4E71                        	nop
    826 FFFF1640 4E71                        	nop
    827 FFFF1642 4E71                        	nop
    828 FFFF1644 4E71                        	nop
    829 FFFF1646 4E71                        	nop
    830 FFFF1648 4E71                        	nop
    831 FFFF164A 4E71                        	nop
    832 FFFF164C 4E71                        	nop
    833 FFFF164E 4E71                        	nop
    834 FFFF1650 4E71                        	nop
    835 FFFF1652 4E71                        	nop
    836 FFFF1654 4E71                        	nop
    837 FFFF1656 4E71                        	nop
                                             	
    839 FFFF1658                             GetKey:
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 15
BOOTROM.x68
    840 FFFF1658 3239 FFDC 0000              	move.w	KEYBD,d1
    841 FFFF165E 6AF8                        	bpl 	GetKey
    842 FFFF1660 4279 FFDC 0002              	clr.w	KEYBD+2			; clear the keyboard strobe
    843 FFFF1666 0241 00FF                   	and.w	#0xFF,d1		; remove strobe bit
    844 FFFF166A 0C38 0000 041C              	cmpi.b	#0,KeybdEcho	; is keyboard echo on ?
    845 FFFF1670 670C                        	beq		gk1
    846 FFFF1672 0C01 000D                   	cmpi.b	#'\r',d1		; convert CR keystroke into CRLF
    847 FFFF1676 6774                        	beq		CRLF
    848 FFFF1678 4EB9 FFFF 1732              	jsr		DisplayChar
    849 FFFF167E                             gk1:
    850 FFFF167E 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; AOS support routines
                                             ;------------------------------------------------------------------------------
                                             ; AOS - CF = 0 if no key is available, otherwise CF = 1
                                             ;
    857 FFFF1680                             KeyStatus:
    858 FFFF1680 3F01                        	move.w	d1,-(a7)
    859 FFFF1682 3239 FFDC 0000              	move.w	KEYBD,d1
    860 FFFF1688 6A08                        	bpl		KST1
    861 FFFF168A 321F                        	move.w	(a7)+,d1
    862 FFFF168C 003C 0001                   	ori		#1,ccr
    863 FFFF1690 4E75                        	rts
    864 FFFF1692                             KST1:
    865 FFFF1692 321F                        	move.w	(a7)+,d1
    866 FFFF1694 023C 00FE                   	andi	#0xFE,ccr
    867 FFFF1698 4E75                        	rts
                                             	
    869 FFFF169A                             TranStatus
    870 FFFF169A 0839 0000 FFDC 0A01         	btst	#0,UART_LS
    871 FFFF16A2 6706                        	beq		trnstat1
    872 FFFF16A4 003C 0001                   	ori		#1,ccr
    873 FFFF16A8 4E75                        	rts
    874 FFFF16AA                             trnstat1:
    875 FFFF16AA 023C 00FE                   	andi	#0xfe,ccr
    876 FFFF16AE 4E75                        	rts
                                             
                                             ;*
                                             ;*============== GET:
                                             ;*
                                             ;*  Get's charter in life is to input characters from the user default
                                             ;*  i/o device.  Get is also a hook into ADVANCE, telling ADVANCE where
                                             ;*  and how to get characters from the user-supplied input device.
                                             ;*
                                             ;*  Entry conditions:
                                             ;*
                                             ;*       A0 = place where we put the input character
                                             ;*
    889 FFFF16B0                             GET:
    890 FFFF16B0 4280                        	clr.l	d0				; clear upper bits of d0
    891 FFFF16B2 3039 FFDC 0000              	move.w	KEYBD,d0
    892 FFFF16B8 6A12                        	bpl		GET1
    893 FFFF16BA 0240 00FF                   	andi.w	#0xff,d0		; mask off strobe bit
    894 FFFF16BE 4279 FFDC 0002              	clr.w	KEYBD+2			; clear the keyboard strobe
    895 FFFF16C4 41F8 0460                   	lea		Keybuf,a0
    896 FFFF16C8 2080                        	move.l	d0,(a0)
    897 FFFF16CA 4E75                        	rts
    898 FFFF16CC                             GET1:
    899 FFFF16CC 41F8 0460                   	lea		Keybuf,a0
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 16
BOOTROM.x68
    900 FFFF16D0 4290                        	clr.l	(a0)
    901 FFFF16D2 4E75                        	rts
                                             
                                             ;*
                                             ;*============== PUT:
                                             ;*
                                             ;*  Put's charter in life is to output characters from the user default
                                             ;*  i/o device.  Put is also a hook into ADVANCE, telling ADVANCE where
                                             ;*  and how to get characters from the user-supplied output device.
                                             ;*
                                             ;*  Entry conditions:
                                             ;*
                                             ;*       D1 = character you want to output to the user-supplied device.
                                             ;*
    914 FFFF16D4                             PUT:
    915 FFFF16D4 6100 005C                   	bsr		DisplayChar
    916 FFFF16D8 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; get key pending status into d1.b
                                             ;------------------------------------------------------------------------------
                                             ;
    922 FFFF16DA                             CheckForKey:
    923 FFFF16DA 3239 FFDC 0000              	move.w	KEYBD,d1
    924 FFFF16E0 6A06                        	bpl		cfk1
    925 FFFF16E2 123C 0001                   	move.b	#1,d1
    926 FFFF16E6 4E75                        	rts
    927 FFFF16E8                             cfk1:
    928 FFFF16E8 4201                        	clr.b	d1
    929 FFFF16EA 4E75                        	rts
                                             
                                             ;
    932 FFFF16EC                             CRLF:
    933 FFFF16EC 2F01                        	move.l	d1,-(a7)
    934 FFFF16EE 123C 000D                   	move.b	#'\r',d1
    935 FFFF16F2 4EB9 FFFF 1732              	jsr		DisplayChar
    936 FFFF16F8 123C 000A                   	move.b	#'\n',d1
    937 FFFF16FC 4EB9 FFFF 1732              	jsr		DisplayChar
    938 FFFF1702 221F                        	move.l	(a7)+,d1
    939 FFFF1704 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Calculate screen memory location from CursorRow,CursorCol.
                                             ; Destroys d0,d2,a0
                                             ;------------------------------------------------------------------------------
                                             ;
    946 FFFF1706                             CalcScreenLoc:
    947 FFFF1706 3038 0418                   	move.w	CursorRow,d0		; compute screen location
    948 FFFF170A 0240 007F                   	andi.w	#0x7f,d0
    949 FFFF170E C0F9 FFDA 0000              	mulu.w	TEXT_COLS,d0
    950 FFFF1714 3438 041A                   	move.w	CursorCol,d2
    951 FFFF1718 0242 00FF                   	andi.w	#0xff,d2
    952 FFFF171C D042                        	add.w	d2,d0
    953 FFFF171E E340                        	asl.w	#1,d0
    954 FFFF1720 0680 FFD0 0000              	add.l	#TEXTSCR,d0
    955 FFFF1726 2040                        	move.l	d0,a0				; a0 = screen location
    956 FFFF1728 E288                        	lsr.l	#1,d0
    957 FFFF172A 33C0 FFDA 0016              	move.w	d0,TEXT_CURPOS
    958 FFFF1730 4E75                        	rts
                                             
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 17
BOOTROM.x68
                                             ;------------------------------------------------------------------------------
                                             ; Display a character on the screen
                                             ; d1.b = char to display
                                             ;------------------------------------------------------------------------------
                                             ;
    965 FFFF1732                             DisplayChar:
    966 FFFF1732 0C01 000D                   	cmpi.b	#'\r',d1			; carriage return ?
    967 FFFF1736 6606                        	bne		dccr
    968 FFFF1738 4278 041A                   	clr.w	CursorCol			; just set cursor column to zero on a CR
    969 FFFF173C 4E75                        	rts
    970 FFFF173E                             dccr:
    971 FFFF173E 0C01 0091                   	cmpi.b	#0x91,d1			; cursor right ?
    972 FFFF1742 660E                        	bne     dcx6
    973 FFFF1744 0C78 0033 041A              	cmpi.w	#51,CursorCol
    974 FFFF174A 6704                        	beq		dcx7
    975 FFFF174C 5278 041A                   	addi.w	#1,CursorCol
    976 FFFF1750                             dcx7:
    977 FFFF1750 4E75                        	rts
    978 FFFF1752                             dcx6:
    979 FFFF1752 0C01 0090                   	cmpi.b	#0x90,d1			; cursor up ?
    980 FFFF1756 660E                        	bne		dcx8
    981 FFFF1758 0C78 0000 0418              	cmpi.w	#0,CursorRow
    982 FFFF175E 67F0                        	beq		dcx7
    983 FFFF1760 5378 0418                   	subi.w	#1,CursorRow
    984 FFFF1764 4E75                        	rts
    985 FFFF1766                             dcx8:
    986 FFFF1766 0C01 0093                   	cmpi.b	#0x93,d1			; cursor left?
    987 FFFF176A 660E                        	bne		dcx9
    988 FFFF176C 0C78 0000 041A              	cmpi.w	#0,CursorCol
    989 FFFF1772 67DC                        	beq		dcx7
    990 FFFF1774 5378 041A                   	subi.w	#1,CursorCol
    991 FFFF1778 4E75                        	rts
    992 FFFF177A                             dcx9:
    993 FFFF177A 0C01 0092                   	cmpi.b	#0x92,d1			; cursor down ?
    994 FFFF177E 660E                        	bne		dcx10
    995 FFFF1780 0C78 001E 0418              	cmpi.w	#30,CursorRow
    996 FFFF1786 67C8                        	beq		dcx7
    997 FFFF1788 5278 0418                   	addi.w	#1,CursorRow
    998 FFFF178C 4E75                        	rts
    999 FFFF178E                             dcx10:
   1000 FFFF178E 0C01 0094                   	cmpi.b	#0x94,d1			; cursor home ?
   1001 FFFF1792 6614                        	bne		dcx11
   1002 FFFF1794 0C78 0000 041A              	cmpi.w	#0,CursorCol
   1003 FFFF179A 6706                        	beq		dcx12
   1004 FFFF179C 4278 041A                   	clr.w	CursorCol
   1005 FFFF17A0 4E75                        	rts
   1006 FFFF17A2                             dcx12
   1007 FFFF17A2 4278 0418                   	clr.w	CursorRow
   1008 FFFF17A6 4E75                        	rts
   1009 FFFF17A8                             dcx11:
   1010 FFFF17A8 48E7 E080                   	movem.l	d0/d1/d2/a0,-(a7)
   1011 FFFF17AC 0C01 0099                   	cmpi.b	#0x99,d1			; delete ?
   1012 FFFF17B0 660A                        	bne		dcx13
   1013 FFFF17B2 6100 FF52                   	bsr		CalcScreenLoc
   1014 FFFF17B6 3038 041A                   	move.w	CursorCol,d0
   1015 FFFF17BA 601A                        	bra		dcx5
   1016 FFFF17BC                             dcx13:
   1017 FFFF17BC 0C01 0008                   	cmpi.b	#CTRLH,d1			; backspace ?
   1018 FFFF17C0 662C                        	bne     dcx3
   1019 FFFF17C2 0C78 0000 041A              	cmpi.w	#0,CursorCol
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 18
BOOTROM.x68
   1020 FFFF17C8 6742                        	beq     dcx4
   1021 FFFF17CA 5378 041A                   	subi.w	#1,CursorCol
   1022 FFFF17CE 6100 FF36                   	bsr		CalcScreenLoc		; a0 = screen location
   1023 FFFF17D2 3038 041A                   	move.w	CursorCol,d0
   1024 FFFF17D6                             dcx5:
   1025 FFFF17D6 30E8 0002                   	move.w	2(a0),(a0)+
   1026 FFFF17DA 5240                        	addi.w	#1,d0
   1027 FFFF17DC B079 FFDA 0000              	cmp.w	TEXT_COLS,d0
   1028 FFFF17E2 65F2                        	blo		dcx5
   1029 FFFF17E4 303C 0020                   	move.w	#32,d0
   1030 FFFF17E8 3140 FFFE                   	move.w	d0,-2(a0)
   1031 FFFF17EC 601E                        	bra		dcx4
   1032 FFFF17EE                             dcx3:
   1033 FFFF17EE 0C01 000A                   	cmpi.b	#'\n',d1		; linefeed ?
   1034 FFFF17F2 6714                        	beq		dclf
                                             
   1036 FFFF17F4 6100 FF10                   	bsr		CalcScreenLoc	; a0 = screen location
   1037 FFFF17F8 6100 01B8                   	bsr		AsciiToScreen	; convert ascii char to screen char
   1038 FFFF17FC 30C1                        	move.w	d1,(a0)+
   1039 FFFF17FE 6100 0012                   	bsr		IncCursorPos
   1040 FFFF1802 4CDF 0107                   	movem.l	(a7)+,d0/d1/d2/a0
   1041 FFFF1806 4E75                        	rts
   1042 FFFF1808                             dclf:
   1043 FFFF1808 6100 0022                   	bsr		IncCursorRow
   1044 FFFF180C                             dcx4:
   1045 FFFF180C 4CDF 0107                   	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
   1046 FFFF1810 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Increment the cursor position, scroll the screen if needed.
                                             ;------------------------------------------------------------------------------
                                             ;
   1052 FFFF1812                             IncCursorPos:
   1053 FFFF1812 5279 FFDA 0016              	addi.w	#1,TEXT_CURPOS
   1054 FFFF1818 5278 041A                   	addi.w	#1,CursorCol
   1055 FFFF181C 3039 FFDA 0000              	move.w	TEXT_COLS,d0
   1056 FFFF1822 B078 041A                   	cmp.w	CursorCol,d0
   1057 FFFF1826 642E                        	bhs		icc1
   1058 FFFF1828 4278 041A                   	clr.w	CursorCol
   1059 FFFF182C                             IncCursorRow:
   1060 FFFF182C 5278 0418                   	addi.w	#1,CursorRow
   1061 FFFF1830 3039 FFDA 0002              	move.w	TEXT_ROWS,d0
   1062 FFFF1836 B078 0418                   	cmp.w	CursorRow,d0
   1063 FFFF183A 621A                        	bhi		icc1
   1064 FFFF183C 3039 FFDA 0002              	move.w	TEXT_ROWS,d0
   1065 FFFF1842 31C0 0418                   	move.w	d0,CursorRow		; in case CursorRow is way over
   1066 FFFF1846 5378 0418                   	subi.w	#1,CursorRow
   1067 FFFF184A E340                        	asl.w	#1,d0
   1068 FFFF184C 9179 FFDA 0016              	sub.w	d0,TEXT_CURPOS
   1069 FFFF1852 6100 00CE                   	bsr		ScrollUp
   1070 FFFF1856                             icc1:
   1071 FFFF1856 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Display a string on the screen.
                                             ;------------------------------------------------------------------------------
                                             ;
   1077 FFFF1858                             DisplayString:
   1078 FFFF1858 48E7 C040                   	movem.l	d0/d1/a1,-(a7)
   1079 FFFF185C                             dspj1:
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 19
BOOTROM.x68
   1080 FFFF185C 4281                        	clr.l	d1				; clear upper bits of d1
   1081 FFFF185E 1219                        	move.b	(a1)+,d1		; move string char into d1
   1082 FFFF1860 0C01 0000                   	cmpi.b	#0,d1			; is it end of string ?
   1083 FFFF1864 6706                        	beq		dsret			
   1084 FFFF1866 6100 FECA                   	bsr		DisplayChar		; display character
   1085 FFFF186A 60F0                        	bra		dspj1			; go back for next character
   1086 FFFF186C                             dsret:
   1087 FFFF186C 4CDF 0203                   	movem.l	(a7)+,d0/d1/a1
   1088 FFFF1870 4E75                        	rts
                                             
   1090 FFFF1872                             DisplayStringCRLF:
   1091 FFFF1872 6100 FFE4                   	bsr		DisplayString
   1092 FFFF1876 6000 FE74                   	bra		CRLF
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Display a string on the screen. Stop at 255 chars, or NULL or D1.W
                                             ;------------------------------------------------------------------------------
                                             ;
   1098 FFFF187A                             DisplayString1:
   1099 FFFF187A 48E7 C040                   	movem.l	d0/d1/a1,-(a7)
   1100 FFFF187E 0241 00FF                   	andi.w	#255,d1			; max 255 chars
   1101 FFFF1882 2001                        	move.l	d1,d0
   1102 FFFF1884                             dspj11:
   1103 FFFF1884 1219                        	move.b	(a1)+,d1		; move string char into d1
   1104 FFFF1886 0C01 0000                   	cmpi.b	#0,d1			; is it end of string ?
   1105 FFFF188A 6708                        	beq		dsret1			
   1106 FFFF188C 6100 FEA4                   	bsr		DisplayChar		; display character
   1107 FFFF1890 57C8 FFF2                   	dbeq	d0,dspj11		; go back for next character
   1108 FFFF1894                             dsret1:
   1109 FFFF1894 4CDF 0203                   	movem.l	(a7)+,d0/d1/a1
   1110 FFFF1898 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Display a string on the screen. Stop at 255 chars, or NULL or D1.W
                                             ; end string with CR,LF
                                             ;------------------------------------------------------------------------------
                                             ;
   1117 FFFF189A                             DisplayString0:
   1118 FFFF189A 6100 FFDE                   	bsr		DisplayString1
   1119 FFFF189E 6000 FE4C                   	bra		CRLF
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Dispatch cursor functions
                                             ;------------------------------------------------------------------------------
                                             ;
   1125 FFFF18A2                             Cursor1:
   1126 FFFF18A2 0C41 00FF                   	cmpi.w	#0x00ff,d1
   1127 FFFF18A6 670E                        	beq		GetCursorPos
   1128 FFFF18A8 0C41 FF00                   	cmpi.w	#0xFF00,d1
   1129 FFFF18AC 6714                        	beq		SetCursorPos
   1130 FFFF18AE 4EB9 FFFF 18E8              	jsr		ClearScreen
   1131 FFFF18B4 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Get the cursor position.
                                             ; d1.b0 = row
                                             ; d1.b1 = col
                                             ;------------------------------------------------------------------------------
                                             ;
   1139 FFFF18B6                             GetCursorPos:
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 20
BOOTROM.x68
   1140 FFFF18B6 3238 041A                   	move.w	CursorCol,d1
   1141 FFFF18BA E141                        	asl.w	#8,D1
   1142 FFFF18BC 1238 0418                   	move.b	CursorRow,d1
   1143 FFFF18C0 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Set the position of the cursor, update the linear screen pointer.
                                             ; d1.b0 = row
                                             ; d1.b1 = col
                                             ;------------------------------------------------------------------------------
                                             ;
   1151 FFFF18C2                             SetCursorPos:
   1152 FFFF18C2 2F01                        	move.l	d1,-(a7)
   1153 FFFF18C4 11C1 0418                   	move.b	d1,CursorRow
   1154 FFFF18C8 E049                        	lsr.w	#8,d1
   1155 FFFF18CA 31C1 041A                   	move.w	d1,CursorCol
   1156 FFFF18CE 3238 0418                   	move.w	CursorRow,d1
   1157 FFFF18D2 C2F9 FFDA 0000              	mulu.w	TEXT_COLS,d1
   1158 FFFF18D8 D278 041A                   	add.w	CursorCol,d1
   1159 FFFF18DC E341                        	asl.w	#1,d1
   1160 FFFF18DE 33C1 FFDA 0016              	move.w	d1,TEXT_CURPOS
   1161 FFFF18E4                             scp1:
   1162 FFFF18E4 221F                        	move.l	(a7)+,d1
   1163 FFFF18E6 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Clear the screen and the screen color memory
                                             ; We clear the screen to give a visual indication that the system
                                             ; is working at all.
                                             ;------------------------------------------------------------------------------
                                             ;
   1171 FFFF18E8                             ClearScreen:
   1172 FFFF18E8 3239 FFDA 0000              	move.w	TEXT_COLS,d1	; calc number to clear
   1173 FFFF18EE C2F9 FFDA 0002              	mulu.w	TEXT_ROWS,d1
   1174 FFFF18F4 303C 0020                   	move.w	#32,d0			; space character
   1175 FFFF18F8 207C FFD0 0000              	move.l	#TEXTSCR,a0		; text screen address
   1176 FFFF18FE                             csj4:
   1177 FFFF18FE 30C0                        	move.w	d0,(a0)+
   1178 FFFF1900 57C9 FFFC                   	dbeq	d1,csj4
                                             
   1180 FFFF1904 3239 FFDA 0000              	move.w	TEXT_COLS,d1	; calc number to clear
   1181 FFFF190A C2F9 FFDA 0002              	mulu.w	TEXT_ROWS,d1
   1182 FFFF1910 3038 0414                   	move.w	ScreenColor,d0		; a nice color blue, light blue
   1183 FFFF1914 207C FFD1 0000              	move.l	#COLORSCR,a0		; text color address
   1184 FFFF191A                             csj3:
   1185 FFFF191A 30C0                        	move.w	d0,(a0)+
   1186 FFFF191C 57C9 FFFC                   	dbeq	d1,csj3
   1187 FFFF1920 4E75                        	rts
                                             	
                                             ;------------------------------------------------------------------------------
                                             ; Scroll text on the screen upwards
                                             ;------------------------------------------------------------------------------
                                             ;
   1193 FFFF1922                             ScrollUp:
   1194 FFFF1922 48E7 E080                   	movem.l	d0/d1/d2/a0,-(a7)
   1195 FFFF1926 3039 FFDA 0000              	move.w	TEXT_COLS,d0		; calc number of chars to scroll
   1196 FFFF192C C0F9 FFDA 0002              	mulu.w	TEXT_ROWS,d0
   1197 FFFF1932 9079 FFDA 0000              	sub.w	TEXT_COLS,d0		; one less row
   1198 FFFF1938 41F9 FFD0 0000              	lea		TEXTSCR,a0
   1199 FFFF193E 3439 FFDA 0000              	move.w	TEXT_COLS,d2
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 21
BOOTROM.x68
   1200 FFFF1944 E342                        	asl.w	#1,d2
   1201 FFFF1946                             scrup1:
   1202 FFFF1946 30F0 2000                   	move.w	(a0,d2.w),(a0)+
   1203 FFFF194A 57C8 FFFA                   	dbeq	d0,scrup1
                                             
   1205 FFFF194E 3239 FFDA 0002              	move.w	TEXT_ROWS,d1
   1206 FFFF1954 5341                        	subi.w	#1,d1
   1207 FFFF1956 4EB9 FFFF 1962              	jsr		BlankLine
   1208 FFFF195C 4CDF 0107                   	movem.l	(a7)+,d0/d1/d2/a0
   1209 FFFF1960 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Blank out a line on the display
                                             ; line number to blank is in D1.W
                                             ;------------------------------------------------------------------------------
                                             ;
   1216 FFFF1962                             BlankLine:
   1217 FFFF1962 48E7 8080                   	movem.l	d0/a0,-(a7)
   1218 FFFF1966 3039 FFDA 0000              	move.w	TEXT_COLS,d0
   1219 FFFF196C C0C1                        	mulu.w	d1,d0				; d0 = row * cols
   1220 FFFF196E E340                        	asl.w	#1,d0				; *2 for moving words, not bytes
   1221 FFFF1970 0680 FFD0 0000              	add.l	#TEXTSCR,d0			; add in screen base
   1222 FFFF1976 2040                        	move.l	d0,a0
   1223 FFFF1978 3039 FFDA 0000              	move.w	TEXT_COLS,d0		; d0 = number of chars to blank out
   1224 FFFF197E                             blnkln1:
   1225 FFFF197E 30FC 0020                   	move.w	#' ',(a0)+
   1226 FFFF1982 57C8 FFFA                   	dbeq	d0,blnkln1
   1227 FFFF1986 4CDF 0101                   	movem.l	(a7)+,d0/a0
   1228 FFFF198A 4E75                        	rts	
                                             
                                             ;------------------------------------------------------------------------------
                                             ; d1 = number
                                             ; d2.b = column width
                                             ;------------------------------------------------------------------------------
   1234 FFFF198C                             DisplayNum20:
   1235 FFFF198C 48E7 F800                   	movem.l	d0/d1/d2/d3/d4,-(a7)
   1236 FFFF1990 4284                        	clr.l	d4
   1237 FFFF1992 1802                        	move.b	d2,d4
   1238 FFFF1994 4EB9 FFFF 2F7A              	jsr		PRTNUM
   1239 FFFF199A 4CDF 001F                   	movem.l	(a7)+,d0/d1/d2/d3/d4
   1240 FFFF199E 4E75                        	rts
                                             	
                                             ;------------------------------------------------------------------------------
                                             ; d1 = number
                                             ;------------------------------------------------------------------------------
   1245 FFFF19A0                             DisplayNum3:
   1246 FFFF19A0 48E7 F800                   	movem.l	d0/d1/d2/d3/d4,-(a7)
   1247 FFFF19A4 4284                        	clr.l	d4
   1248 FFFF19A6 4EB9 FFFF 2F7A              	jsr		PRTNUM
   1249 FFFF19AC 4CDF 001F                   	movem.l	(a7)+,d0/d1/d2/d3/d4
   1250 FFFF19B0 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Convert ASCII character to screen display character.
                                             ;------------------------------------------------------------------------------
                                             ;
   1256 FFFF19B2                             AsciiToScreen:
   1257 FFFF19B2 0241 00FF                   	andi.w	#0x00ff,d1
   1258 FFFF19B6 0C01 0041                   	cmpi.b	#'A',d1
   1259 FFFF19BA 6516                        	blo		atoscr1
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 22
BOOTROM.x68
   1260 FFFF19BC 0C01 005A                   	cmpi.b	#'Z',d1
   1261 FFFF19C0 6310                        	bls		atoscr1
   1262 FFFF19C2 0C01 007A                   	cmpi.b	#'z',d1
   1263 FFFF19C6 620A                        	bhi     atoscr1
   1264 FFFF19C8 0C01 0061                   	cmpi.b	#'a',d1
   1265 FFFF19CC 6504                        	blo     atoscr1
   1266 FFFF19CE 0401 0060                   	subi.b	#0x60,d1
   1267 FFFF19D2                             atoscr1:
   1268 FFFF19D2 0041 0100                   	ori.w	#0x100,d1
   1269 FFFF19D6 4E75                        	rts
                                             	
                                             ;------------------------------------------------------------------------------
                                             ; Convert screen character to ascii character
                                             ;------------------------------------------------------------------------------
                                             ;
   1275 FFFF19D8                             ScreenToAscii:
   1276 FFFF19D8 0201 00FF                   	andi.b	#0xff,d1
   1277 FFFF19DC 0C01 001A                   	cmpi.b	#26,d1
   1278 FFFF19E0 6204                        	bhi		stasc1
   1279 FFFF19E2 0601 0060                   	addi.b	#0x60,d1
   1280 FFFF19E6                             stasc1:
   1281 FFFF19E6 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Display nybble in D1.B
                                             ;------------------------------------------------------------------------------
                                             ;
   1287 FFFF19E8                             DisplayNybble:
   1288 FFFF19E8 3F01                        	move.w	d1,-(a7)
   1289 FFFF19EA 0201 000F                   	andi.b	#0xF,d1
   1290 FFFF19EE 0601 0030                   	addi.b	#'0',d1
   1291 FFFF19F2 0C01 0039                   	cmpi.b	#'9',d1
   1292 FFFF19F6 6302                        	bls		dispnyb1
   1293 FFFF19F8 5E01                        	addi.b	#7,d1
   1294 FFFF19FA                             dispnyb1:
   1295 FFFF19FA 6100 FD36                   	bsr		DisplayChar
   1296 FFFF19FE 321F                        	move.w	(a7)+,d1
   1297 FFFF1A00 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Display the byte in D1.B
                                             ;------------------------------------------------------------------------------
                                             ;
   1303 FFFF1A02                             DisplayByte:
   1304 FFFF1A02 3F01                        	move.w	d1,-(a7)
   1305 FFFF1A04 E819                        	ror.b	#4,d1
   1306 FFFF1A06 6100 FFE0                   	bsr		DisplayNybble
   1307 FFFF1A0A E919                        	rol.b	#4,d1
   1308 FFFF1A0C 6100 FFDA                   	bsr		DisplayNybble
   1309 FFFF1A10 321F                        	move.w	(a7)+,d1
   1310 FFFF1A12 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Display the 32 bit word in D1.L
                                             ;------------------------------------------------------------------------------
                                             ;
   1316 FFFF1A14                             DisplayWord:
   1317 FFFF1A14 E199                        	rol.l	#8,d1
   1318 FFFF1A16 6100 FFEA                   	bsr		DisplayByte
   1319 FFFF1A1A E199                        	rol.l	#8,d1
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 23
BOOTROM.x68
   1320 FFFF1A1C 6100 FFE4                   	bsr		DisplayByte
   1321 FFFF1A20 E199                        	rol.l	#8,d1
   1322 FFFF1A22 6100 FFDE                   	bsr		DisplayByte
   1323 FFFF1A26 E199                        	rol.l	#8,d1
   1324 FFFF1A28 6100 FFD8                   	bsr		DisplayByte
   1325 FFFF1A2C 4E75                        	rts
                                             
   1327 FFFF1A2E                             DisplayMem:
   1328 FFFF1A2E 123C 003A                   	move.b	#':',d1
   1329 FFFF1A32 4EB9 FFFF 1732              	jsr		DisplayChar
   1330 FFFF1A38 2208                        	move.l	a0,d1
   1331 FFFF1A3A 4EB9 FFFF 1A14              	jsr		DisplayWord
   1332 FFFF1A40 7407                        	moveq	#7,d2
   1333 FFFF1A42                             dspmem1:
   1334 FFFF1A42 123C 0020                   	move.b	#' ',d1
   1335 FFFF1A46 4EB9 FFFF 1732              	jsr		DisplayChar
   1336 FFFF1A4C 1218                        	move.b	(a0)+,d1
   1337 FFFF1A4E 4EB9 FFFF 1A02              	jsr		DisplayByte
   1338 FFFF1A54 51CA FFEC                   	dbra	d2,dspmem1
   1339 FFFF1A58 4EF9 FFFF 16EC              	jmp		CRLF
                                             
                                             ;==============================================================================
                                             ; Monitor
                                             ;==============================================================================
                                             ;
   1345 FFFF1A5E                             StartMon:
   1346 FFFF1A5E 4E55 FFE8                   	LINK    A5,#-PSIZ       ;RESERVE SPACE ON STACK FOR INPUT COMMAND LINE;
   1347 FFFF1A62 41ED FFFA                       lea.l   -MLFLAG(A5),A0
   1348 FFFF1A66 43ED FFFC                   	LEA.L   -STATZ(A5),A1
   1349 FFFF1A6A 3B7C 0000 FFFA              	MOVE.W  #EMPTY,-MLFLAG(A5)
   1350 FFFF1A70 3B7C 0002 FFF8              	MOVE.W  #LETTE,-MXLTRS(A5)      ;SETUP FOR "LETTE" LETTERS (WAS 2);
   1351 FFFF1A76 7048                        	MOVE.L  #AOS_POSTBOX,D0
   1352 FFFF1A78 4E41                        	TRAP    #1                      ;POST MAILBOX;
   1353 FFFF1A7A                             Monitor:
                                             ;	lea		STACK,a7		; reset the stack pointer
   1355 FFFF1A7A 4278 041C                   	clr.w	KeybdEcho		; turn off keyboard echo
   1356 FFFF1A7E                             PromptLn:
   1357 FFFF1A7E 6100 FC6C                   	bsr		CRLF
   1358 FFFF1A82 123C 0024                   	move.b	#'$',d1
   1359 FFFF1A86 6100 FCAA                   	bsr		DisplayChar
                                             
                                             ; Get characters until a CR is keyed
                                             ;
   1363 FFFF1A8A                             Prompt3:
   1364 FFFF1A8A 6100 FBCC                   	bsr		GetKey
   1365 FFFF1A8E 0C01 000D                   	cmpi.b	#CR,d1
   1366 FFFF1A92 6706                        	beq		Prompt1
   1367 FFFF1A94 6100 FC9C                   	bsr		DisplayChar
   1368 FFFF1A98 60F0                        	bra		Prompt3
                                             
                                             ; Process the screen line that the CR was keyed on
                                             ;
   1372 FFFF1A9A                             Prompt1:
   1373 FFFF1A9A 4278 041A                   	clr.w	CursorCol		; go back to the start of the line
   1374 FFFF1A9E 6100 FC66                   	bsr		CalcScreenLoc	; a0 = screen memory location
   1375 FFFF1AA2 3218                        	move.w	(a0)+,d1
   1376 FFFF1AA4 6100 FF32                   	bsr		ScreenToAscii
   1377 FFFF1AA8 0C01 0024                   	cmpi.b	#'$',d1			; skip over '$' prompt character
   1378 FFFF1AAC 6606                        	bne		Prompt2
   1379 FFFF1AAE 3218                        	move.w	(a0)+,d1
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 24
BOOTROM.x68
   1380 FFFF1AB0 6100 FF26                   	bsr		ScreenToAscii
                                             	
                                             ; Dispatch based on command character
                                             ;
   1384 FFFF1AB4                             Prompt2:
   1385 FFFF1AB4 0C01 003A                   	cmpi.b	#':',d1			; $: - edit memory
   1386 FFFF1AB8 6700 00FC                   	beq		EditMem
   1387 FFFF1ABC 0C01 0044                   	cmpi.b	#'D',d1			; $D - dump memory
   1388 FFFF1AC0 6700 0162                   	beq		DumpMem
   1389 FFFF1AC4 0C01 0042                   	cmpi.b	#'B',d1			; $B - start tiny basic
   1390 FFFF1AC8 6700 0936                   	beq		START
   1391 FFFF1ACC 0C01 004A                   	cmpi.b	#'J',d1			; $J - execute code
   1392 FFFF1AD0 6700 0142                   	beq		ExecuteCode
   1393 FFFF1AD4 0C01 004C                   	cmpi.b	#'L',d1			; $L - load S19 file
   1394 FFFF1AD8 6700 01EE                   	beq		LoadS19
   1395 FFFF1ADC 0C01 003F                   	cmpi.b	#'?',d1			; $? - display help
   1396 FFFF1AE0 672A                        	beq		DisplayHelp
   1397 FFFF1AE2 0C01 0043                   	cmpi.b	#'C',d1			; $C - clear screen
   1398 FFFF1AE6 6702                        	beq		TestCLS
   1399 FFFF1AE8 6090                        	bra		Monitor
                                             
   1401 FFFF1AEA                             TestCLS:
   1402 FFFF1AEA 3218                        	move.w	(a0)+,d1
   1403 FFFF1AEC 6100 FEEA                   	bsr		ScreenToAscii
   1404 FFFF1AF0 0C01 004C                   	cmpi.b	#'L',d1
   1405 FFFF1AF4 6684                        	bne		Monitor
   1406 FFFF1AF6 3218                        	move.w	(a0)+,d1
   1407 FFFF1AF8 6100 FEDE                   	bsr		ScreenToAscii
   1408 FFFF1AFC 0C01 0053                   	cmpi.b	#'S',d1
   1409 FFFF1B00 6600 FF78                   	bne		Monitor
   1410 FFFF1B04 6100 FDE2                   	bsr		ClearScreen
   1411 FFFF1B08 6000 FF70                   	bra		Monitor
                                             	
   1413 FFFF1B0C                             DisplayHelp:
   1414 FFFF1B0C 43F9 FFFF 1B1C              	lea		HelpMsg,a1
   1415 FFFF1B12 4EB9 FFFF 1858              	jsr		DisplayString
   1416 FFFF1B18 6000 FF60                   	bra		Monitor
                                             
   1418 FFFF1B1C                             HelpMsg:
   1419 FFFF1B1C 3F 20 3D 20 44 69 73 70     	dc.b	"? = Display help",CR,LF
   1420 FFFF1B24 6C 61 79 20 68 65 6C 70     
   1421 FFFF1B2C 0D 0A                       
   1422 FFFF1B2E 43 4C 53 20 3D 20 63 6C     	dc.b	"CLS = clear screen",CR,LF
   1423 FFFF1B36 65 61 72 20 73 63 72 65     
   1424 FFFF1B3E 65 6E 0D 0A                 
   1425 FFFF1B42 3A 20 3D 20 45 64 69 74     	dc.b	": = Edit memory bytes",CR,LF
   1426 FFFF1B4A 20 6D 65 6D 6F 72 79 20     
   1427 FFFF1B52 62 79 74 65 73 0D 0A        
   1428 FFFF1B59 4C 20 3D 20 4C 6F 61 64     	dc.b	"L = Load S19 file",CR,LF
   1429 FFFF1B61 20 53 31 39 20 66 69 6C     
   1430 FFFF1B69 65 0D 0A                    
   1431 FFFF1B6C 44 20 3D 20 44 75 6D 70     	dc.b	"D = Dump memory",CR,LF
   1432 FFFF1B74 20 6D 65 6D 6F 72 79 0D     
   1433 FFFF1B7C 0A                          
   1434 FFFF1B7D 42 20 3D 20 73 74 61 72     	dc.b	"B = start tiny basic",CR,LF
   1435 FFFF1B85 74 20 74 69 6E 79 20 62     
   1436 FFFF1B8D 61 73 69 63 0D 0A           
   1437 FFFF1B93 4A 20 3D 20 4A 75 6D 70     	dc.b	"J = Jump to code",CR,LF,0
   1438 FFFF1B9B 20 74 6F 20 63 6F 64 65     
   1439 FFFF1BA3 0D 0A 00                    
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 25
BOOTROM.x68
                                             	even
                                             
                                             ;------------------------------------------------------------------------------
                                             ;------------------------------------------------------------------------------
                                             ;
   1445 FFFF1BA6                             ignBlanks:
   1446 FFFF1BA6 3218                        	move.w	(a0)+,d1
   1447 FFFF1BA8 6100 FE2E                   	bsr		ScreenToAscii
   1448 FFFF1BAC 0C01 0020                   	cmpi.b	#' ',d1
   1449 FFFF1BB0 67F4                        	beq		ignBlanks
   1450 FFFF1BB2 5588                        	subq	#2,a0
   1451 FFFF1BB4 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Edit memory byte.
                                             ;------------------------------------------------------------------------------
                                             ;
   1457 FFFF1BB6                             EditMem:
   1458 FFFF1BB6 6100 FFEE                   	bsr		ignBlanks
   1459 FFFF1BBA 6100 009C                   	bsr		GetHexNumber
   1460 FFFF1BBE 2241                        	move.l	d1,a1
   1461 FFFF1BC0                             edtmem1:
   1462 FFFF1BC0 6100 FFE4                   	bsr		ignBlanks
   1463 FFFF1BC4 6100 0092                   	bsr		GetHexNumber
   1464 FFFF1BC8 12C1                        	move.b	d1,(a1)+
   1465 FFFF1BCA 6100 FFDA                   	bsr		ignBlanks
   1466 FFFF1BCE 6100 0088                   	bsr		GetHexNumber
   1467 FFFF1BD2 12C1                        	move.b	d1,(a1)+
   1468 FFFF1BD4 6100 FFD0                   	bsr		ignBlanks
   1469 FFFF1BD8 6100 007E                   	bsr		GetHexNumber
   1470 FFFF1BDC 12C1                        	move.b	d1,(a1)+
   1471 FFFF1BDE 6100 FFC6                   	bsr		ignBlanks
   1472 FFFF1BE2 6100 0074                   	bsr		GetHexNumber
   1473 FFFF1BE6 12C1                        	move.b	d1,(a1)+
   1474 FFFF1BE8 6100 FFBC                   	bsr		ignBlanks
   1475 FFFF1BEC 6100 006A                   	bsr		GetHexNumber
   1476 FFFF1BF0 12C1                        	move.b	d1,(a1)+
   1477 FFFF1BF2 6100 FFB2                   	bsr		ignBlanks
   1478 FFFF1BF6 6100 0060                   	bsr		GetHexNumber
   1479 FFFF1BFA 12C1                        	move.b	d1,(a1)+
   1480 FFFF1BFC 6100 FFA8                   	bsr		ignBlanks
   1481 FFFF1C00 6100 0056                   	bsr		GetHexNumber
   1482 FFFF1C04 12C1                        	move.b	d1,(a1)+
   1483 FFFF1C06 6100 FF9E                   	bsr		ignBlanks
   1484 FFFF1C0A 6100 004C                   	bsr		GetHexNumber
   1485 FFFF1C0E 12C1                        	move.b	d1,(a1)+
   1486 FFFF1C10 6000 FE68                   	bra		Monitor
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Execute code at the specified address.
                                             ;------------------------------------------------------------------------------
                                             ;
   1492 FFFF1C14                             ExecuteCode:
   1493 FFFF1C14 6100 FF90                   	bsr		ignBlanks
   1494 FFFF1C18 6100 003E                   	bsr		GetHexNumber
   1495 FFFF1C1C 2041                        	move.l	d1,a0
   1496 FFFF1C1E 4E90                        	jsr		(a0)
   1497 FFFF1C20 6000 FE58                   	bra     Monitor
                                             
                                             ;------------------------------------------------------------------------------
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 26
BOOTROM.x68
                                             ; Do a memory dump of the requested location.
                                             ;------------------------------------------------------------------------------
                                             ;
   1503 FFFF1C24                             DumpMem:
   1504 FFFF1C24 6100 FF80                   	bsr		ignBlanks
   1505 FFFF1C28 6100 002E                   	bsr		GetHexNumber
   1506 FFFF1C2C 2041                        	move.l	d1,a0
   1507 FFFF1C2E 4EB9 FFFF 16EC              	jsr		CRLF
   1508 FFFF1C34 6100 FDF8                   	bsr		DisplayMem
   1509 FFFF1C38 6100 FDF4                   	bsr		DisplayMem
   1510 FFFF1C3C 6100 FDF0                   	bsr		DisplayMem
   1511 FFFF1C40 6100 FDEC                   	bsr		DisplayMem
   1512 FFFF1C44 6100 FDE8                   	bsr		DisplayMem
   1513 FFFF1C48 6100 FDE4                   	bsr		DisplayMem
   1514 FFFF1C4C 6100 FDE0                   	bsr		DisplayMem
   1515 FFFF1C50 6100 FDDC                   	bsr		DisplayMem
   1516 FFFF1C54 6000 FE24                   	bra		Monitor
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Get a hexidecimal number. Maximum of eight digits.
                                             ;------------------------------------------------------------------------------
                                             ;
   1522 FFFF1C58                             GetHexNumber:
   1523 FFFF1C58 48E7 A000                   	movem.l	d0/d2,-(a7)
   1524 FFFF1C5C 4282                        	clr.l	d2
   1525 FFFF1C5E 7007                        	moveq	#7,d0
   1526 FFFF1C60                             gthxn2:
   1527 FFFF1C60 3218                        	move.w	(a0)+,d1
   1528 FFFF1C62 6100 FD74                   	bsr		ScreenToAscii
   1529 FFFF1C66 6100 001E                   	bsr		AsciiToHexNybble
   1530 FFFF1C6A B23C 00FF                   	cmp.b	#0xff,d1
   1531 FFFF1C6E 670E                        	beq		gthxn1
   1532 FFFF1C70 E98A                        	lsl.l	#4,d2
   1533 FFFF1C72 0281 0000 000F              	andi.l	#0x0f,d1
   1534 FFFF1C78 8481                        	or.l	d1,d2
   1535 FFFF1C7A 51C8 FFE4                   	dbra	d0,gthxn2
   1536 FFFF1C7E                             gthxn1:
   1537 FFFF1C7E 2202                        	move.l	d2,d1
   1538 FFFF1C80 4CDF 0005                   	movem.l	(a7)+,d0/d2
   1539 FFFF1C84 4E75                        	rts	
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                                             ; to a hex nybble.
                                             ;------------------------------------------------------------------------------
                                             ;
   1546 FFFF1C86                             AsciiToHexNybble:
   1547 FFFF1C86 0C01 0030                   	cmpi.b	#'0',d1
   1548 FFFF1C8A 6538                        	blo		gthx3
   1549 FFFF1C8C 0C01 0039                   	cmpi.b	#'9',d1
   1550 FFFF1C90 6206                        	bhi		gthx5
   1551 FFFF1C92 0401 0030                   	subi.b	#'0',d1
   1552 FFFF1C96 4E75                        	rts
   1553 FFFF1C98                             gthx5:
   1554 FFFF1C98 0C01 0041                   	cmpi.b	#'A',d1
   1555 FFFF1C9C 6526                        	blo		gthx3
   1556 FFFF1C9E 0C01 0046                   	cmpi.b	#'F',d1
   1557 FFFF1CA2 620A                        	bhi		gthx6
   1558 FFFF1CA4 0401 0041                   	subi.b	#'A',d1
   1559 FFFF1CA8 0601 000A                   	addi.b	#10,d1
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 27
BOOTROM.x68
   1560 FFFF1CAC 4E75                        	rts
   1561 FFFF1CAE                             gthx6:
   1562 FFFF1CAE 0C01 0061                   	cmpi.b	#'a',d1
   1563 FFFF1CB2 6510                        	blo		gthx3
   1564 FFFF1CB4 0C01 0066                   	cmpi.b	#'f',d1
   1565 FFFF1CB8 620A                        	bhi		gthx3
   1566 FFFF1CBA 0401 0061                   	subi.b	#'a',d1
   1567 FFFF1CBE 0601 000A                   	addi.b	#10,d1
   1568 FFFF1CC2 4E75                        	rts
   1569 FFFF1CC4                             gthx3:
   1570 FFFF1CC4 72FF                        	moveq	#-1,d1		; not a hex number
   1571 FFFF1CC6 4E75                        	rts
                                             
                                             ;==============================================================================
                                             ; Load an S19 format file
                                             ;==============================================================================
                                             ;
   1577 FFFF1CC8                             LoadS19:
   1578 FFFF1CC8 600A                        	bra		ProcessRec
   1579 FFFF1CCA                             NextRec:
   1580 FFFF1CCA 6100 0174                   	bsr		sGetChar
   1581 FFFF1CCE 0C00 000A                   	cmpi.b	#LF,d0
   1582 FFFF1CD2 66F6                        	bne		NextRec
   1583 FFFF1CD4                             ProcessRec
   1584 FFFF1CD4 6100 016A                   	bsr		sGetChar
   1585 FFFF1CD8 1800                        	move.b	d0,d4
   1586 FFFF1CDA 0C04 001A                   	cmpi.b	#26,d4		; CTRL-Z ?
   1587 FFFF1CDE 6700 FD9A                   	beq		Monitor
   1588 FFFF1CE2 0C04 0053                   	cmpi.b	#'S',d4
   1589 FFFF1CE6 66E2                        	bne		NextRec
   1590 FFFF1CE8 6100 0156                   	bsr		sGetChar
   1591 FFFF1CEC 1800                        	move.b	d0,d4
   1592 FFFF1CEE 0C04 0030                   	cmpi.b	#'0',d4
   1593 FFFF1CF2 65D6                        	blo		NextRec
   1594 FFFF1CF4 0C04 0039                   	cmpi.b	#'9',d4		; d4 = record type
   1595 FFFF1CF8 62D0                        	bhi		NextRec
   1596 FFFF1CFA 6100 0144                   	bsr		sGetChar
   1597 FFFF1CFE 6100 FF86                   	bsr		AsciiToHexNybble
   1598 FFFF1D02 1401                        	move.b	d1,d2
   1599 FFFF1D04 6100 013A                   	bsr		sGetChar
   1600 FFFF1D08 6100 FF7C                   	bsr		AsciiToHexNybble
   1601 FFFF1D0C E90A                        	lsl.b	#4,d2
   1602 FFFF1D0E 8202                        	or.b	d2,d1		; d1 = byte count
   1603 FFFF1D10 1601                        	move.b	d1,d3		; d3 = byte count
   1604 FFFF1D12 0C04 0030                   	cmpi.b	#'0',d4		; manufacturer ID record, ignore
   1605 FFFF1D16 67B2                        	beq		NextRec
   1606 FFFF1D18 0C04 0031                   	cmpi.b	#'1',d4
   1607 FFFF1D1C 676A                        	beq		ProcessS1
   1608 FFFF1D1E 0C04 0032                   	cmpi.b	#'2',d4
   1609 FFFF1D22 676A                        	beq		ProcessS2
   1610 FFFF1D24 0C04 0033                   	cmpi.b	#'3',d4
   1611 FFFF1D28 676A                        	beq		ProcessS3
   1612 FFFF1D2A 0C04 0035                   	cmpi.b	#'5',d4		; record count record, ignore
   1613 FFFF1D2E 679A                        	beq		NextRec
   1614 FFFF1D30 0C04 0037                   	cmpi.b	#'7',d4
   1615 FFFF1D34 6764                        	beq		ProcessS7
   1616 FFFF1D36 0C04 0038                   	cmpi.b	#'8',d4
   1617 FFFF1D3A 676A                        	beq		ProcessS8
   1618 FFFF1D3C 0C04 0039                   	cmpi.b	#'9',d4
   1619 FFFF1D40 6770                        	beq		ProcessS9
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 28
BOOTROM.x68
   1620 FFFF1D42 6086                        	bra		NextRec
                                             
   1622 FFFF1D44                             pcssxa
   1623 FFFF1D44 0243 00FF                   	andi.w	#0xff,d3
   1624 FFFF1D48 5343                        	subi.w	#1,d3			; one less for dbra
   1625 FFFF1D4A                             pcss1a
   1626 FFFF1D4A 4282                        	clr.l	d2
   1627 FFFF1D4C 6100 00F2                   	bsr		sGetChar
   1628 FFFF1D50 6100 FF34                   	bsr		AsciiToHexNybble
   1629 FFFF1D54 E98A                        	lsl.l	#4,d2
   1630 FFFF1D56 8401                        	or.b	d1,d2
   1631 FFFF1D58 6100 00E6                   	bsr		sGetChar
   1632 FFFF1D5C 6100 FF28                   	bsr		AsciiToHexNybble
   1633 FFFF1D60 E98A                        	lsl.l	#4,d2
   1634 FFFF1D62 8401                        	or.b	d1,d2
   1635 FFFF1D64 12C2                        	move.b	d2,(a1)+
   1636 FFFF1D66 51CB FFE2                   	dbra	d3,pcss1a
                                             ; Get the checksum byte
   1638 FFFF1D6A 4282                        	clr.l	d2
   1639 FFFF1D6C 6100 00D2                   	bsr		sGetChar
   1640 FFFF1D70 6100 FF14                   	bsr		AsciiToHexNybble
   1641 FFFF1D74 E98A                        	lsl.l	#4,d2
   1642 FFFF1D76 8401                        	or.b	d1,d2
   1643 FFFF1D78 6100 00C6                   	bsr		sGetChar
   1644 FFFF1D7C 6100 FF08                   	bsr		AsciiToHexNybble
   1645 FFFF1D80 E98A                        	lsl.l	#4,d2
   1646 FFFF1D82 8401                        	or.b	d1,d2
   1647 FFFF1D84 6000 FF44                   	bra		NextRec
                                             
   1649 FFFF1D88                             ProcessS1:
   1650 FFFF1D88 6100 0034                   	bsr		S19Get16BitAddress
   1651 FFFF1D8C 60B6                        	bra		pcssxa
   1652 FFFF1D8E                             ProcessS2:
   1653 FFFF1D8E 6100 003C                   	bsr		S19Get24BitAddress
   1654 FFFF1D92 60B0                        	bra		pcssxa
   1655 FFFF1D94                             ProcessS3:
   1656 FFFF1D94 6100 0044                   	bsr		S19Get32BitAddress
   1657 FFFF1D98 60AA                        	bra		pcssxa
   1658 FFFF1D9A                             ProcessS7:
   1659 FFFF1D9A 6100 003E                   	bsr		S19Get32BitAddress
   1660 FFFF1D9E 21C9 0800                   	move.l	a1,S19StartAddress
   1661 FFFF1DA2 6000 FCD6                   	bra		Monitor
   1662 FFFF1DA6                             ProcessS8:
   1663 FFFF1DA6 6100 0024                   	bsr		S19Get24BitAddress
   1664 FFFF1DAA 21C9 0800                   	move.l	a1,S19StartAddress
   1665 FFFF1DAE 6000 FCCA                   	bra		Monitor
   1666 FFFF1DB2                             ProcessS9:
   1667 FFFF1DB2 6100 000A                   	bsr		S19Get16BitAddress
   1668 FFFF1DB6 21C9 0800                   	move.l	a1,S19StartAddress
   1669 FFFF1DBA 6000 FCBE                   	bra		Monitor
                                             
   1671 FFFF1DBE                             S19Get16BitAddress:
   1672 FFFF1DBE 4282                        	clr.l	d2
   1673 FFFF1DC0 6100 007E                   	bsr		sGetChar
   1674 FFFF1DC4 6100 FEC0                   	bsr		AsciiToHexNybble
   1675 FFFF1DC8 1401                        	move.b	d1,d2
   1676 FFFF1DCA 604A                        	bra		S1932b
                                             
   1678 FFFF1DCC                             S19Get24BitAddress:
   1679 FFFF1DCC 4282                        	clr.l	d2
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 29
BOOTROM.x68
   1680 FFFF1DCE 6100 0070                   	bsr		sGetChar
   1681 FFFF1DD2 6100 FEB2                   	bsr		AsciiToHexNybble
   1682 FFFF1DD6 1401                        	move.b	d1,d2
   1683 FFFF1DD8 6024                        	bra		S1932a
                                             
   1685 FFFF1DDA                             S19Get32BitAddress:
   1686 FFFF1DDA 4282                        	clr.l	d2
   1687 FFFF1DDC 6100 0062                   	bsr		sGetChar
   1688 FFFF1DE0 6100 FEA4                   	bsr		AsciiToHexNybble
   1689 FFFF1DE4 1401                        	move.b	d1,d2
   1690 FFFF1DE6 6100 0058                   	bsr		sGetChar
   1691 FFFF1DEA 6100 FE9A                   	bsr		AsciiToHexNybble
   1692 FFFF1DEE E98A                        	lsl.l	#4,d2
   1693 FFFF1DF0 8401                        	or.b	d1,d2
   1694 FFFF1DF2 6100 004C                   	bsr		sGetChar
   1695 FFFF1DF6 6100 FE8E                   	bsr		AsciiToHexNybble
   1696 FFFF1DFA E98A                        	lsl.l	#4,d2
   1697 FFFF1DFC 8401                        	or.b	d1,d2
   1698 FFFF1DFE                             S1932a:
   1699 FFFF1DFE 6100 0040                   	bsr		sGetChar
   1700 FFFF1E02 6100 FE82                   	bsr		AsciiToHexNybble
   1701 FFFF1E06 E98A                        	lsl.l	#4,d2
   1702 FFFF1E08 8401                        	or.b	d1,d2
   1703 FFFF1E0A 6100 0034                   	bsr		sGetChar
   1704 FFFF1E0E 6100 FE76                   	bsr		AsciiToHexNybble
   1705 FFFF1E12 E98A                        	lsl.l	#4,d2
   1706 FFFF1E14 8401                        	or.b	d1,d2
   1707 FFFF1E16                             S1932b:
   1708 FFFF1E16 6100 0028                   	bsr		sGetChar
   1709 FFFF1E1A 6100 FE6A                   	bsr		AsciiToHexNybble
   1710 FFFF1E1E E98A                        	lsl.l	#4,d2
   1711 FFFF1E20 8401                        	or.b	d1,d2
   1712 FFFF1E22 6100 001C                   	bsr		sGetChar
   1713 FFFF1E26 6100 FE5E                   	bsr		AsciiToHexNybble
   1714 FFFF1E2A E98A                        	lsl.l	#4,d2
   1715 FFFF1E2C 8401                        	or.b	d1,d2
   1716 FFFF1E2E 6100 0010                   	bsr		sGetChar
   1717 FFFF1E32 6100 FE52                   	bsr		AsciiToHexNybble
   1718 FFFF1E36 E98A                        	lsl.l	#4,d2
   1719 FFFF1E38 8401                        	or.b	d1,d2
   1720 FFFF1E3A 4284                        	clr.l	d4
   1721 FFFF1E3C 2242                        	move.l	d2,a1
   1722 FFFF1E3E 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Get a character from auxillary input, checking the keyboard status for a
                                             ; CTRL-C
                                             ;------------------------------------------------------------------------------
                                             ;
   1729 FFFF1E40                             sGetChar:
   1730 FFFF1E40 6100 F898                   	bsr		CheckForKey
   1731 FFFF1E44 670C                        	beq		sgc1
   1732 FFFF1E46 6100 F810                   	bsr		GetKey
   1733 FFFF1E4A 0C01 0003                   	cmpi.b	#CTRLC,d1
   1734 FFFF1E4E 6700 FC2A                   	beq		Monitor
   1735 FFFF1E52                             sgc1:
   1736 FFFF1E52 6100 1288                   	bsr		AUXIN
   1737 FFFF1E56 67E8                        	beq		sGetChar
   1738 FFFF1E58 1200                        	move.b	d0,d1
   1739 FFFF1E5A 4E75                        	rts
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 30
BOOTROM.x68
                                             
                                             ;==============================================================================
                                             ;==============================================================================
                                             
                                             ;------------------------------------------------------------------------------
                                             ; Sound a tone for a second.
                                             ;------------------------------------------------------------------------------
                                             ;
   1748 FFFF1E5C                             Beep:
   1749 FFFF1E5C 33FC 000F FFD4 0040         	move.w	#15,PSG_MASTVOL			; set master volume
   1750 FFFF1E64 33FC 411B FFD4 0000         	move.w	#16667,PSG_FREQUENCY0	; 1000 Hz
   1751 FFFF1E6C 4279 FFD4 0002              	clr.w	PSG_PULSEWIDTH0			; not used
   1752 FFFF1E72 4279 FFD4 0008              	clr.w	PSG_ATTACK0				; zero attack time
   1753 FFFF1E78 4279 FFD4 000A              	clr.w	PSG_DECAY0				; zero decay time
   1754 FFFF1E7E 33FC 00FF FFD4 000C         	move.w	#255,PSG_SUSTAIN0		; max sustain level
   1755 FFFF1E86 4279 FFD4 000E              	clr.w	PSG_RELEASE0			; zero release time
   1756 FFFF1E8C 33FC 1104 FFD4 0004         	move.w	#0x1104,PSG_CTRL0		; gate on, output enabled, triangle waveform
                                             
   1758 FFFF1E94 203C 007A 1200              	move.l	#8000000,d0			; delay a couple of seconds
   1759 FFFF1E9A                             Beep1:
   1760 FFFF1E9A 5380                        	sub.l	#1,d0
   1761 FFFF1E9C 66FC                        	bne		Beep1
   1762 FFFF1E9E 4279 FFD4 0004              	clr.w	PSG_CTRL0				; shut off the tone
   1763 FFFF1EA4 33FC 0000 FFD4 0040         	move.w	#0,PSG_MASTVOL
   1764 FFFF1EAC 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ;------------------------------------------------------------------------------
                                             ;
   1769 FFFF1EAE                             ReadTemp:
   1770 FFFF1EAE 303C 5151                   	move.w	#0x5151,d0		; start conversion command
   1771 FFFF1EB2 33C0 FFDC 0300              	move.w	d0,TMPPMOD		; 
   1772 FFFF1EB8                             rdtmp1:
   1773 FFFF1EB8 0839 0007 FFDC 0303         	btst	#7,TMPPMOD+3	; is transfer done ?
   1774 FFFF1EC0 66F6                        	bne		rdtmp1
                                             	
                                             ;	clr.l	d0
                                             ;	move.l	d0,-(a7)		; create a space for error code
                                             ;	lea		(a7),a1
                                             ;	move.l	#1000,d1		; delay 1000 ms (1 s)
                                             ;	move.l	#AOS_DELAY,d0
                                             ;	trap	#1
                                             ;	move.l	(a7)+,d0		; pop error code
                                             
                                             	; delay 1 second
   1785 FFFF1EC2 203C 007A 1200              	move.l	#8000000,d0
   1786 FFFF1EC8                             rdtmp2:
   1787 FFFF1EC8 5380                        	subi.l	#1,d0
   1788 FFFF1ECA 66FC                        	bne		rdtmp2
                                             
   1790 FFFF1ECC 303C ACAC                   	move.w	#0xACAC,d0		; read config reg
   1791 FFFF1ED0 33C0 FFDC 0300              	move.w	d0,TMPPMOD
   1792 FFFF1ED6                             rdtmp4:
   1793 FFFF1ED6 0839 0007 FFDC 0303         	btst	#7,TMPPMOD+3
   1794 FFFF1EDE 66F6                        	bne		rdtmp4
   1795 FFFF1EE0 3039 FFDC 0302              	move.w	TMPPMOD+2,d0
   1796 FFFF1EE6 4840                        	swap	d0
                                             
   1798 FFFF1EE8 303C AAAA                   	move.w	#0xAAAA,d0		; issue read temp command
   1799 FFFF1EEC 33C0 FFDC 0300              	move.w	d0,TMPPMOD
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 31
BOOTROM.x68
   1800 FFFF1EF2                             rdtmp3:
   1801 FFFF1EF2 0839 0007 FFDC 0303         	btst	#7,TMPPMOD+3	; is transfer done ?
   1802 FFFF1EFA 66F6                        	bne		rdtmp3
   1803 FFFF1EFC 3039 FFDC 0302              	move.w	TMPPMOD+2,d0	; read the temp
   1804 FFFF1F02 4E75                        	rts
                                             
                                             
   1807 FFFF1F04                             DisplayDecNumber:
   1808 FFFF1F04 48E7 C044                   	movem.l	d0/d1/a1/a5,-(a7)
   1809 FFFF1F08 2A7C 0000 0700              	move.l	#scratch1,a5
   1810 FFFF1F0E 2001                        	move.l	d1,d0
   1811 FFFF1F10 6100 122C                   	bsr		HEX2DEC
   1812 FFFF1F14 227C 0000 0700              	move.l	#scratch1,a1
   1813 FFFF1F1A 6100 F93C                   	bsr 	DisplayString
   1814 FFFF1F1E 4CDF 2203                   	movem.l	(a7)+,d0/d1/a1/a5
   1815 FFFF1F22 4E75                        	rts
                                             
                                             ;------------------------------------------------------------------------------
                                             ;------------------------------------------------------------------------------
                                             ;
   1820 FFFF1F24                             DisplayHexNumber:
   1821 FFFF1F24 48E7 B000                   	movem.l	d0/d2/d3,-(a7)
   1822 FFFF1F28 343C 0007                   	move.w	#7,d2		; number-1 of digits to display
   1823 FFFF1F2C                             disphnum1:
   1824 FFFF1F2C 1001                        	move.b	d1,d0		; get digit into d0.b
   1825 FFFF1F2E 0240 000F                   	andi.w	#0x0f,d0
   1826 FFFF1F32 0C40 0009                   	cmpi.w	#0x09,d0
   1827 FFFF1F36 6302                        	bls		disphnum2
   1828 FFFF1F38 5E40                        	addi.w	#0x7,d0
   1829 FFFF1F3A                             disphnum2:
   1830 FFFF1F3A 0640 0130                   	addi.w	#0x130,d0	; convert to display char
   1831 FFFF1F3E 3602                        	move.w	d2,d3		; char count into d3
   1832 FFFF1F40 E343                        	asl.w	#1,d3		; scale * 2
   1833 FFFF1F42 3380 3000                   	move.w	d0,(a1,d3.w)
   1834 FFFF1F46 E899                        	ror.l	#4,d1		; rot to next digit
   1835 FFFF1F48 57CA FFE2                   	dbeq	d2,disphnum1
   1836 FFFF1F4C 4CDF 000D                   	movem.l	(a7)+,d0/d2/d3
   1837 FFFF1F50 4E75                        	rts
                                             
                                             ;===============================================================================
                                             ;    Perform ram test. (Uses checkerboard testing).
                                             ; 
                                             ;    Return address must be stored in a3 since the stack cannot be used (it
                                             ; would get overwritten in test). Note this routine uses no ram at all.
                                             ;===============================================================================
   1845 FFFF1F52                             ramtest:
   1846 FFFF1F52 207C 0000 0008                      movea.l #8,a0
   1847 FFFF1F58 203C AAAA 5555                      move.l #0xaaaa5555,d0
                                             ;-----------------------------------------------------------
                                             ;   Write checkerboard pattern to ram then read it back to
                                             ; find the highest usable ram address (maybe). This address
                                             ; must be lower than the start of the rom (0xe00000).
                                             ;-----------------------------------------------------------
   1853 FFFF1F5E 43F9 FFD0 0014                      lea		TEXTSCR+20,a1
   1854 FFFF1F64                             ramtest1:
   1855 FFFF1F64 2080                                move.l 	d0,(a0)
   1856 FFFF1F66 B098                                cmp.l 	(a0)+,d0
   1857 FFFF1F68 6614                                bne.s 	ramtest6
   1858 FFFF1F6A 2208                                move.l	a0,d1
   1859 FFFF1F6C 4A41                                tst.w	d1
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 32
BOOTROM.x68
   1860 FFFF1F6E 6606                                bne		rmtst1
   1861 FFFF1F70 4EB9 FFFF 1F24                      jsr		DisplayHexNumber
   1862 FFFF1F76                             rmtst1:
   1863 FFFF1F76 B1FC 00FF FFFC                      cmpa.l 	#0xFFFFFC,a0
   1864 FFFF1F7C 65E6                                blo.s 	ramtest1
                                             ;------------------------------------------------------
                                             ;   Save maximum useable address for later comparison.
                                             ;------------------------------------------------------
   1868 FFFF1F7E                             ramtest6:
   1869 FFFF1F7E 2448                                movea.l a0,a2
   1870 FFFF1F80 207C 0000 0008                      movea.l #8,a0
                                             ;--------------------------------------------
                                             ;   Read back checkerboard pattern from ram.
                                             ;--------------------------------------------
   1874 FFFF1F86                             ramtest2:
   1875 FFFF1F86 2018                                move.l (a0)+,d0
   1876 FFFF1F88 2208                                move.l	a0,d1
   1877 FFFF1F8A 4A41                                tst.w	d1
   1878 FFFF1F8C 6606                                bne		rmtst2
   1879 FFFF1F8E 4EB9 FFFF 1F24                      jsr		DisplayHexNumber
   1880 FFFF1F94                             rmtst2:
   1881 FFFF1F94 0C80 AAAA 5555                      cmpi.l 	#0xaaaa5555,d0
   1882 FFFF1F9A 67EA                                beq.s 	ramtest2
                                             ;---------------------------------------
                                             ;   Check for matching maximum address.
                                             ;---------------------------------------
   1886 FFFF1F9C B5C8                                cmpa.l a0,a2
   1887 FFFF1F9E 6668                                bne.s ramtest7
                                             ;---------------------------------------------------
                                             ;   The following section does the same test except
                                             ; with the checkerboard order switched around.
                                             ;---------------------------------------------------
   1892 FFFF1FA0                             ramtest3:                
   1893 FFFF1FA0 207C 0000 0008                      movea.l #8,a0
   1894 FFFF1FA6 203C 5555 AAAA                      move.l 	#0x5555aaaa,d0
   1895 FFFF1FAC                             ramtest4:
   1896 FFFF1FAC 2080                                move.l 	d0,(a0)
   1897 FFFF1FAE B098                                cmp.l 	(a0)+,d0
   1898 FFFF1FB0 6614                                bne.s 	ramtest8
   1899 FFFF1FB2 2208                                move.l 	a0,d1
   1900 FFFF1FB4 4A41                                tst.w	d1
   1901 FFFF1FB6 6606                                bne     rmtst3
   1902 FFFF1FB8 4EB9 FFFF 1F24                      jsr		DisplayHexNumber
   1903 FFFF1FBE                             rmtst3:
   1904 FFFF1FBE B1FC 00FF FFFC                      cmpa.l 	#0xFFFFFC,a0
   1905 FFFF1FC4 65E6                                blo.s 	ramtest4
   1906 FFFF1FC6                             ramtest8:
   1907 FFFF1FC6 2448                                movea.l a0,a2
   1908 FFFF1FC8 207C 0000 0008                      movea.l #8,a0
   1909 FFFF1FCE                             ramtest5:
   1910 FFFF1FCE 2018                                move.l 	(a0)+,d0
   1911 FFFF1FD0 2208                                move.l 	a0,d1
   1912 FFFF1FD2 4A41                                tst.w	d1
   1913 FFFF1FD4 6606                                bne		rmtst4
   1914 FFFF1FD6 4EB9 FFFF 1F24                      jsr		DisplayHexNumber
   1915 FFFF1FDC                             rmtst4:
   1916 FFFF1FDC 0C80 5555 AAAA                      cmpi.l 	#0x5555aaaa,d0
   1917 FFFF1FE2 67EA                                beq.s 	ramtest5
   1918 FFFF1FE4 B5C8                                cmpa.l 	a0,a2
   1919 FFFF1FE6 6620                                bne.s 	ramtest7
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 33
BOOTROM.x68
                                             ;---------------------------------------------------
                                             ;   Save last ram address in end of memory pointer.
                                             ;---------------------------------------------------
   1923 FFFF1FE8 21C8 0500                           move.l a0,memend
                                             ;-----------------------------------
                                             ;   Create very first memory block.
                                             ;-----------------------------------
   1927 FFFF1FEC 91FC 0000 000C                      suba.l 	#12,a0
   1928 FFFF1FF2 21C8 0404                           move.l 	a0,0x0404
   1929 FFFF1FF6 21FC 4652 4545 0400                 move.l 	#0x46524545,0x0400
   1930 FFFF1FFE 21FC 0000 0408 0408                 move.l 	#0x408,0x408			; point back-link to self
   1931 FFFF2006 4ED3                                jmp 	(a3)
                                             ;----------------------------------
                                             ; Error in ram - go no farther.
                                             ;----------------------------------
   1935 FFFF2008                             ramtest7:
   1936 FFFF2008 4ED3                        		jmp 	(a3)
   1937 FFFF200A 60FC                                bra.s 	ramtest7
                                             
   1939 FFFF200C                             AddressError:
   1940 FFFF200C 48E7 F0C0                   	movem.l	a0/a1/d0/d1/d2/d3,-(a7)
   1941 FFFF2010 43F9 FFFF 204E              	lea		MSG_ADDRESS_ERROR,a1
   1942 FFFF2016 4EB9 FFFF 1858              	jsr		DisplayString
   1943 FFFF201C 4CDF 030F                   	movem.l	(a7)+,a0/a1/d0/d1/d2/d3
   1944 FFFF2020 4E73                        	rte
   1945 FFFF2022                             BusError:
   1946 FFFF2022 48E7 F0C0                   	movem.l	a0/a1/d0/d1/d2/d3,-(a7)
   1947 FFFF2026 43F9 FFFF 205C              	lea		MSG_BUS_ERROR,a1
   1948 FFFF202C 4EB9 FFFF 1858              	jsr		DisplayString
   1949 FFFF2032 4CDF 030F                   	movem.l	(a7)+,a0/a1/d0/d1/d2/d3
   1950 FFFF2036 4E73                        	rte
   1951 FFFF2038                             IllegalInstruction:
   1952 FFFF2038 48E7 F0C0                   	movem.l	a0/a1/d0/d1/d2/d3,-(a7)
   1953 FFFF203C 43F9 FFFF 2066              	lea		MSG_ILLEGAL_INSN,a1
   1954 FFFF2042 4EB9 FFFF 1858              	jsr		DisplayString
   1955 FFFF2048 4CDF 030F                   	movem.l	(a7)+,a0/a1/d0/d1/d2/d3
   1956 FFFF204C 4E73                        	rte
                                             
   1958 FFFF204E                             MSG_ADDRESS_ERROR:
   1959 FFFF204E 41 64 64 72 65 73 73 20     	dc.b	"Address error",0
   1960 FFFF2056 65 72 72 6F 72 00           
   1961 FFFF205C                             MSG_BUS_ERROR:
   1962 FFFF205C 42 75 73 20 65 72 72 6F     	dc.b	"Bus error",0
   1963 FFFF2064 72 00                       
   1964 FFFF2066                             MSG_ILLEGAL_INSN:
   1965 FFFF2066 49 6C 6C 65 67 61 6C 20     	dc.b	"Illegal instruction",0
   1966 FFFF206E 69 6E 73 74 72 75 63 74     
   1967 FFFF2076 69 6F 6E 00                 
   1968 FFFF207A                             MSG_DIVIDE_BY_ZERO:
   1969 FFFF207A 44 69 76 69 64 65 20 62     	dc.b	"Divide by zero",0
   1970 FFFF2082 79 20 7A 65 72 6F 00        
                                             ;
                                             
                                             ;*****************************************************************
                                             ;								 *
                                             ;		Tiny BASIC for the Motorola MC68000		 *
                                             ;								 *
                                             ; Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                                             ; issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                                             ;	Gordon Brandly						 *
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 34
BOOTROM.x68
                                             ;	12147 - 51 Street					 *
                                             ;	Edmonton AB  T5W 3G8					 *
                                             ;	Canada							 *
                                             ;	(updated mailing address for 1996)			 *
                                             ;								 *
                                             ; This version is for MEX68KECB Educational Computer Board I/O.  *
                                             ;								 *
                                             ;*****************************************************************
                                             ;    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                                             ;    freely distributed for personal use only. All commercial	 *
                                             ;		       rights are reserved.			 *
                                             ;*****************************************************************
                                             
                                             ; Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                                             ;	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                                             ;	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                             
                                             ;	OPT	FRS,BRS 	forward ref.'s & branches default to short
                                             
                                             BUFLEN	EQU	80	;	length of keyboard input buffer
                                             
                                             ;*
                                             ;* Internal variables follow:
                                             ;*
                                             	BSS
                                             	ORG		0x600
   2006 00000600                             RANPNT:
   2007 00000600                             	DC.L	START	;	random number pointer
   2008 00000604                             CURRNT:
   2009 00000604                             	DC.L	1		;Current line pointer
   2010 00000608                             STKGOS:
   2011 00000608                             	DC.L	1		;Saves stack pointer in 'GOSUB'
   2012 0000060C                             STKINP:
   2013 0000060C                             	DC.L	1		;Saves stack pointer during 'INPUT'
   2014 00000610                             LOPVAR:
   2015 00000610                             	DC.L	1		;'FOR' loop save area
   2016 00000614                             LOPINC:
   2017 00000614                             	DC.L	1		;increment
   2018 00000618                             LOPLMT:
   2019 00000618                             	DC.L	1		;limit
   2020 0000061C                             LOPLN:
   2021 0000061C                             	DC.L	1		;line number
   2022 00000620                             LOPPT:
   2023 00000620                             	DC.L	1		;text pointer
   2024 00000624                             TXTUNF:
   2025 00000624                             	DC.L	1		;points to unfilled text area
   2026 00000628                             VARBGN:
   2027 00000628                             	DC.L	1		;points to variable area
   2028 0000062C                             STKLMT:
   2029 0000062C                             	DC.L	1		;holds lower limit for stack growth
   2030 00000630                             BUFFER:
   2031 00000630                             	FILL.B	BUFLEN,0x00	;	Keyboard input buffer
                                             
                                             TXT	EQU	$		;Beginning of program area
                                             
                                             	CODE
   2036 FFFF2089 FF                         	even
   2037 FFFF208A FF FF FF FF FF FF FF FF     	ORG	0xFFFF2400
   2038 FFFF2092 FF FF FF FF FF FF FF FF     
   2039 FFFF209A FF FF FF FF FF FF FF FF     
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 35
BOOTROM.x68
   2040 FFFF20A2 FF FF FF FF FF FF FF FF     
   2041 FFFF20AA FF FF FF FF FF FF FF FF     
   2042 FFFF20B2 FF FF FF FF FF FF FF FF     
   2043 FFFF20BA FF FF FF FF FF FF FF FF     
   2044 FFFF20C2 FF FF FF FF FF FF FF FF     
   2045 FFFF20CA FF FF FF FF FF FF FF FF     
   2046 FFFF20D2 FF FF FF FF FF FF FF FF     
   2047 FFFF20DA FF FF FF FF FF FF FF FF     
   2048 FFFF20E2 FF FF FF FF FF FF FF FF     
   2049 FFFF20EA FF FF FF FF FF FF FF FF     
   2050 FFFF20F2 FF FF FF FF FF FF FF FF     
   2051 FFFF20FA FF FF FF FF FF FF FF FF     
   2052 FFFF2102 FF FF FF FF FF FF FF FF     
   2053 FFFF210A FF FF FF FF FF FF FF FF     
   2054 FFFF2112 FF FF FF FF FF FF FF FF     
   2055 FFFF211A FF FF FF FF FF FF FF FF     
   2056 FFFF2122 FF FF FF FF FF FF FF FF     
   2057 FFFF212A FF FF FF FF FF FF FF FF     
   2058 FFFF2132 FF FF FF FF FF FF FF FF     
   2059 FFFF213A FF FF FF FF FF FF FF FF     
   2060 FFFF2142 FF FF FF FF FF FF FF FF     
   2061 FFFF214A FF FF FF FF FF FF FF FF     
   2062 FFFF2152 FF FF FF FF FF FF FF FF     
   2063 FFFF215A FF FF FF FF FF FF FF FF     
   2064 FFFF2162 FF FF FF FF FF FF FF FF     
   2065 FFFF216A FF FF FF FF FF FF FF FF     
   2066 FFFF2172 FF FF FF FF FF FF FF FF     
   2067 FFFF217A FF FF FF FF FF FF FF FF     
   2068 FFFF2182 FF FF FF FF FF FF FF FF     
   2069 FFFF218A FF FF FF FF FF FF FF FF     
   2070 FFFF2192 FF FF FF FF FF FF FF FF     
   2071 FFFF219A FF FF FF FF FF FF FF FF     
   2072 FFFF21A2 FF FF FF FF FF FF FF FF     
   2073 FFFF21AA FF FF FF FF FF FF FF FF     
   2074 FFFF21B2 FF FF FF FF FF FF FF FF     
   2075 FFFF21BA FF FF FF FF FF FF FF FF     
   2076 FFFF21C2 FF FF FF FF FF FF FF FF     
   2077 FFFF21CA FF FF FF FF FF FF FF FF     
   2078 FFFF21D2 FF FF FF FF FF FF FF FF     
   2079 FFFF21DA FF FF FF FF FF FF FF FF     
   2080 FFFF21E2 FF FF FF FF FF FF FF FF     
   2081 FFFF21EA FF FF FF FF FF FF FF FF     
   2082 FFFF21F2 FF FF FF FF FF FF FF FF     
   2083 FFFF21FA FF FF FF FF FF FF FF FF     
   2084 FFFF2202 FF FF FF FF FF FF FF FF     
   2085 FFFF220A FF FF FF FF FF FF FF FF     
   2086 FFFF2212 FF FF FF FF FF FF FF FF     
   2087 FFFF221A FF FF FF FF FF FF FF FF     
   2088 FFFF2222 FF FF FF FF FF FF FF FF     
   2089 FFFF222A FF FF FF FF FF FF FF FF     
   2090 FFFF2232 FF FF FF FF FF FF FF FF     
   2091 FFFF223A FF FF FF FF FF FF FF FF     
   2092 FFFF2242 FF FF FF FF FF FF FF FF     
   2093 FFFF224A FF FF FF FF FF FF FF FF     
   2094 FFFF2252 FF FF FF FF FF FF FF FF     
   2095 FFFF225A FF FF FF FF FF FF FF FF     
   2096 FFFF2262 FF FF FF FF FF FF FF FF     
   2097 FFFF226A FF FF FF FF FF FF FF FF     
   2098 FFFF2272 FF FF FF FF FF FF FF FF     
   2099 FFFF227A FF FF FF FF FF FF FF FF     
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 36
BOOTROM.x68
   2100 FFFF2282 FF FF FF FF FF FF FF FF     
   2101 FFFF228A FF FF FF FF FF FF FF FF     
   2102 FFFF2292 FF FF FF FF FF FF FF FF     
   2103 FFFF229A FF FF FF FF FF FF FF FF     
   2104 FFFF22A2 FF FF FF FF FF FF FF FF     
   2105 FFFF22AA FF FF FF FF FF FF FF FF     
   2106 FFFF22B2 FF FF FF FF FF FF FF FF     
   2107 FFFF22BA FF FF FF FF FF FF FF FF     
   2108 FFFF22C2 FF FF FF FF FF FF FF FF     
   2109 FFFF22CA FF FF FF FF FF FF FF FF     
   2110 FFFF22D2 FF FF FF FF FF FF FF FF     
   2111 FFFF22DA FF FF FF FF FF FF FF FF     
   2112 FFFF22E2 FF FF FF FF FF FF FF FF     
   2113 FFFF22EA FF FF FF FF FF FF FF FF     
   2114 FFFF22F2 FF FF FF FF FF FF FF FF     
   2115 FFFF22FA FF FF FF FF FF FF FF FF     
   2116 FFFF2302 FF FF FF FF FF FF FF FF     
   2117 FFFF230A FF FF FF FF FF FF FF FF     
   2118 FFFF2312 FF FF FF FF FF FF FF FF     
   2119 FFFF231A FF FF FF FF FF FF FF FF     
   2120 FFFF2322 FF FF FF FF FF FF FF FF     
   2121 FFFF232A FF FF FF FF FF FF FF FF     
   2122 FFFF2332 FF FF FF FF FF FF FF FF     
   2123 FFFF233A FF FF FF FF FF FF FF FF     
   2124 FFFF2342 FF FF FF FF FF FF FF FF     
   2125 FFFF234A FF FF FF FF FF FF FF FF     
   2126 FFFF2352 FF FF FF FF FF FF FF FF     
   2127 FFFF235A FF FF FF FF FF FF FF FF     
   2128 FFFF2362 FF FF FF FF FF FF FF FF     
   2129 FFFF236A FF FF FF FF FF FF FF FF     
   2130 FFFF2372 FF FF FF FF FF FF FF FF     
   2131 FFFF237A FF FF FF FF FF FF FF FF     
   2132 FFFF2382 FF FF FF FF FF FF FF FF     
   2133 FFFF238A FF FF FF FF FF FF FF FF     
   2134 FFFF2392 FF FF FF FF FF FF FF FF     
   2135 FFFF239A FF FF FF FF FF FF FF FF     
   2136 FFFF23A2 FF FF FF FF FF FF FF FF     
   2137 FFFF23AA FF FF FF FF FF FF FF FF     
   2138 FFFF23B2 FF FF FF FF FF FF FF FF     
   2139 FFFF23BA FF FF FF FF FF FF FF FF     
   2140 FFFF23C2 FF FF FF FF FF FF FF FF     
   2141 FFFF23CA FF FF FF FF FF FF FF FF     
   2142 FFFF23D2 FF FF FF FF FF FF FF FF     
   2143 FFFF23DA FF FF FF FF FF FF FF FF     
   2144 FFFF23E2 FF FF FF FF FF FF FF FF     
   2145 FFFF23EA FF FF FF FF FF FF FF FF     
   2146 FFFF23F2 FF FF FF FF FF FF FF FF     
   2147 FFFF23FA FF FF FF FF FF FF           
                                             ;*
                                             ;* Standard jump table. You can change these addresses if you are
                                             ;* customizing this interpreter for a different environment.
                                             ;*
   2152 FFFF2400                             START:
   2153 FFFF2400 6000 0022                   		BRA.L	CSTART		;Cold Start entry point
   2154 FFFF2404 6000 005A                   GOWARM:	BRA.L	WSTART		;Warm Start entry point
   2155 FFFF2408 6000 0C96                   GOOUT:	BRA.L	OUTC		;Jump to character-out routine
   2156 FFFF240C 6000 0CA4                   GOIN:	BRA.L	INC		;Jump to character-in routine
   2157 FFFF2410 6000 0CB8                   GOAUXO:	BRA.L	AUXOUT		;Jump to auxiliary-out routine
   2158 FFFF2414 6000 0CC6                   GOAUXI:	BRA.L	AUXIN		;Jump to auxiliary-in routine
   2159 FFFF2418 6000 0CD8                   GOBYE:	BRA.L	BYEBYE		;Jump to monitor, DOS, etc.
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 37
BOOTROM.x68
                                             ;*
                                             ;* Modifiable system constants:
                                             ;*
                                             ; Give Tiny Basic 3MB
   2164 FFFF241C 00C00000                    TXTBGN	DC.L	0xC00000	;beginning of program memory
   2165 FFFF2420 00F00000                    ENDMEM	DC.L	0xF00000	;	end of available memory
                                             ;*
                                             ;* The main interpreter starts here:
                                             ;*
   2169 FFFF2424                             CSTART:
                                             ;	LINK    A5,#-PSIZ       ;RESERVE SPACE ON STACK FOR INPUT COMMAND LINE;
                                             ;    lea.l   -MLFLAG(A5),A0
                                             ;	LEA.L   -STATZ(A5),A1
                                             ;	MOVE.W  #EMPTY,-MLFLAG(A5)
                                             ;	MOVE.W  #LETTE,-MXLTRS(A5)      ;SETUP FOR "LETTE" LETTERS (WAS 2);
                                             ;	MOVE.L  #AOS_POSTBOX,D0
                                             ;	TRAP    #1                      ;POST MAILBOX;
                                             
   2178 FFFF2424 41F9 FFFF 2400              	LEA		START,A0
   2179 FFFF242A 21C8 0600                   	MOVE.L	A0,RANPNT
   2180 FFFF242E 2E79 FFFF 2420              	MOVE.L	ENDMEM,SP	;initialize stack pointer
   2181 FFFF2434 4DF9 FFFF 30F8              	LEA		INITMSG,A6	;tell who we are
   2182 FFFF243A 6100 0C58                   	BSR.L	PRMESG
   2183 FFFF243E 21F9 FFFF 241C 0624         	MOVE.L	TXTBGN,TXTUNF	;init. end-of-program pointer
   2184 FFFF2446 2039 FFFF 2420              	MOVE.L	ENDMEM,D0	;get address of end of memory
   2185 FFFF244C 0480 0000 0800              	SUB.L	#2048,D0	;reserve 2K for the stack
   2186 FFFF2452 21C0 062C                   	MOVE.L	D0,STKLMT
   2187 FFFF2456 0480 0000 1008              	SUB.L	#4104,D0 	;reserve variable area (27 long words)
   2188 FFFF245C 21C0 0628                   	MOVE.L	D0,VARBGN
   2189 FFFF2460                             WSTART:
   2190 FFFF2460 4280                        	CLR.L	D0		;initialize internal variables
   2191 FFFF2462 21C0 0610                   	MOVE.L	D0,LOPVAR
   2192 FFFF2466 21C0 0608                   	MOVE.L	D0,STKGOS
   2193 FFFF246A 21C0 0604                   	MOVE.L	D0,CURRNT	;current line number pointer = 0
   2194 FFFF246E 2E79 FFFF 2420              	MOVE.L	ENDMEM,SP	;init S.P. again, just in case
   2195 FFFF2474 4DF9 FFFF 311E              	LEA	OKMSG,A6	;display "OK"
   2196 FFFF247A 6100 0C18                   	BSR.L	PRMESG
   2197 FFFF247E                             ST3:
   2198 FFFF247E 103C 003E                   	MOVE.B	#'>',D0  ;       Monitor with a '>' and
   2199 FFFF2482 6100 0976                   	BSR.L	GETLN	;	read a line.
   2200 FFFF2486 6100 0BA8                   	BSR.L	TOUPBUF ;	convert to upper case
   2201 FFFF248A 2848                        	MOVE.L	A0,A4	;	save pointer to end of line
   2202 FFFF248C 41F8 0630                   	LEA	BUFFER,A0	;point to the beginning of line
   2203 FFFF2490 6100 0B5A                   	BSR.L	TSTNUM	;	is there a number there?
   2204 FFFF2494 6100 0B8E                   	BSR.L	IGNBLK	;	skip trailing blanks
   2205 FFFF2498 4A81                        	TST	D1		;does line no. exist? (or nonzero?)
   2206 FFFF249A 6700 0152                   	BEQ.L	DIRECT	;	if not, it's a direct statement
   2207 FFFF249E B2BC 0000 FFFF              	CMP.L	#0xFFFF,D1	;see if line no. is <= 16 bits
   2208 FFFF24A4 6400 094A                   	BCC.L	QHOW		;if not, we've overflowed
   2209 FFFF24A8 1101                        	MOVE.B	D1,-(A0)	;store the binary line no.
   2210 FFFF24AA E099                        	ROR	#8,D1		;(Kludge to store a word on a
   2211 FFFF24AC 1101                        	MOVE.B	D1,-(A0)	;possible byte boundary)
   2212 FFFF24AE E199                        	ROL	#8,D1
   2213 FFFF24B0 6100 09E8                   	BSR.L	FNDLN	;	find this line in save area
   2214 FFFF24B4 2A49                        	MOVE.L	A1,A5	;	save possible line pointer
   2215 FFFF24B6 6612                        	BNE	ST4				;	if not found, insert
   2216 FFFF24B8 6100 0A08                   	BSR.L	FNDNXT		;find the next line (into A1)
   2217 FFFF24BC 244D                        	MOVE.L	A5,A2		;pointer to line to be deleted
   2218 FFFF24BE 2678 0624                   	MOVE.L	TXTUNF,A3	;points to top of save area
   2219 FFFF24C2 6100 0A08                   	BSR.L	MVUP		;move up to delete
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 38
BOOTROM.x68
   2220 FFFF24C6 21CA 0624                   	MOVE.L	A2,TXTUNF	;update the end pointer
   2221 FFFF24CA                             ST4:
   2222 FFFF24CA 200C                        	MOVE.L	A4,D0		;calculate the length of new line
   2223 FFFF24CC 9088                        	SUB.L	A0,D0
   2224 FFFF24CE B0BC 0000 0003              	CMP.L	#3,D0		;is it just a line no. & CR?
   2225 FFFF24D4 67A8                        	BEQ	ST3				;if so, it was just a delete
   2226 FFFF24D6 2678 0624                   	MOVE.L	TXTUNF,A3	;compute new end
   2227 FFFF24DA 2C4B                        	MOVE.L	A3,A6
   2228 FFFF24DC D7C0                        	ADD.L	D0,A3
   2229 FFFF24DE 2038 0628                   	MOVE.L	VARBGN,D0	;see if there's enough room
   2230 FFFF24E2 B08B                        	CMP.L	A3,D0
   2231 FFFF24E4 6300 0900                   	BLS.L	QSORRY		;if not, say so
   2232 FFFF24E8 21CB 0624                   	MOVE.L	A3,TXTUNF	;if so, store new end position
   2233 FFFF24EC 224E                        	MOVE.L	A6,A1		;points to old unfilled area
   2234 FFFF24EE 244D                        	MOVE.L	A5,A2		;points to beginning of move area
   2235 FFFF24F0 6100 09E4                   	BSR.L	MVDOWN		;move things out of the way
   2236 FFFF24F4 2248                        	MOVE.L	A0,A1		;set up to do the insertion
   2237 FFFF24F6 244D                        	MOVE.L	A5,A2
   2238 FFFF24F8 264C                        	MOVE.L	A4,A3
   2239 FFFF24FA 6100 09D0                   	BSR.L	MVUP		;do it
   2240 FFFF24FE 6000 FF7E                   	BRA	ST3		;go back and get another line
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** Tables *** DIRECT *** EXEC ***
                                             ;*
                                             ;* This section of the code tests a string against a table. When
                                             ;* a match is found, control is transferred to the section of
                                             ;* code according to the table.
                                             ;*
                                             ;* At 'EXEC', A0 should point to the string, A1 should point to
                                             ;* the character table, and A2 should point to the execution
                                             ;* table. At 'DIRECT', A0 should point to the string, A1 and
                                             ;* A2 will be set up to point to TAB1 and TAB1.1, which are
                                             ;* the tables of all direct and statement commands.
                                             ;*
                                             ;* A '.' in the string will terminate the test and the partial
                                             ;* match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                             ;* 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                             ;*
                                             ;* There are two tables: the character table and the execution
                                             ;* table. The character table consists of any number of text items.
                                             ;* Each item is a string of characters with the last character's
                                             ;* high bit set to one. The execution table holds a 16-bit
                                             ;* execution addresses that correspond to each entry in the
                                             ;* character table.
                                             ;*
                                             ;* The end of the character table is a 0 byte which corresponds
                                             ;* to the default routine in the execution table, which is
                                             ;* executed if none of the other table items are matched.
                                             ;*
                                             ;* Character-matching tables:
   2273 FFFF2502                             TAB1:
   2274 FFFF2502 4C 49 53 D4                 	DC.B	'LIS',('T'+0x80) ;        Direct commands
   2275 FFFF2506 4C 4F 41 C4                 	DC.B	'LOA',('D'+0x80)
   2276 FFFF250A 4E 45 D7                    	DC.B	'NE',('W'+0x80)
   2277 FFFF250D 52 55 CE                    	DC.B	'RU',('N'+0x80)
   2278 FFFF2510 53 41 56 C5                 	DC.B	'SAV',('E'+0x80)
   2279 FFFF2514 43 4C D3                    	DC.B    'CL',('S'+0x80)
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 39
BOOTROM.x68
   2280 FFFF2517                             TAB2:
   2281 FFFF2517 4E 45 58 D4                 	DC.B	'NEX',('T'+0x80)  ;       Direct / statement
   2282 FFFF251B 4C 45 D4                    	DC.B	'LE',('T'+0x80)
   2283 FFFF251E 49 C6                       	DC.B	'I',('F'+0x80)
   2284 FFFF2520 47 4F 54 CF                 	DC.B	'GOT',('O'+0x80)
   2285 FFFF2524 47 4F 53 55 C2              	DC.B	'GOSU',('B'+0x80)
   2286 FFFF2529 52 45 54 55 52 CE           	DC.B	'RETUR',('N'+0x80)
   2287 FFFF252F 52 45 CD                    	DC.B	'RE',('M'+0x80)
   2288 FFFF2532 46 4F D2                    	DC.B	'FO',('R'+0x80)
   2289 FFFF2535 49 4E 50 55 D4              	DC.B	'INPU',('T'+0x80)
   2290 FFFF253A 50 52 49 4E D4              	DC.B	'PRIN',('T'+0x80)
   2291 FFFF253F 50 4F 4B C5                 	DC.B	'POK',('E'+0x80)
   2292 FFFF2543 53 54 4F D0                 	DC.B	'STO',('P'+0x80)
   2293 FFFF2547 42 59 C5                    	DC.B	'BY',('E'+0x80)
   2294 FFFF254A 43 41 4C CC                 	DC.B	'CAL',('L'+0x80)
   2295 FFFF254E 4C 49 4E C5                 	DC.B	'LIN',('E'+0x80)
   2296 FFFF2552 50 4F 49 4E D4              	DC.B    'POIN',('T'+0x80)
   2297 FFFF2557 50 45 4E 43 4F 4C 4F D2     	DC.B	'PENCOLO',('R'+0x80)
                                             
   2299 FFFF255F 46 49 4C 4C 43 4F 4C 4F     	DC.B	'FILLCOLO',('R'+0x80)
   2300 FFFF2567 D2                          
   2301 FFFF2568 00                          	DC.B	0
   2302 FFFF2569                             TAB4:
   2303 FFFF2569 50 45 45 CB                 	DC.B	'PEE',('K'+0x80)   ;      Functions
   2304 FFFF256D 52 4E C4                    	DC.B	'RN',('D'+0x80)
   2305 FFFF2570 41 42 D3                    	DC.B	'AB',('S'+0x80)
   2306 FFFF2573 53 49 5A C5                 	DC.B	'SIZ',('E'+0x80)
   2307 FFFF2577 54 49 43 CB                 	DC.B    'TIC',('K'+0x80)
   2308 FFFF257B 54 45 4D D0                 	DC.B    'TEM',('P'+0x80)
   2309 FFFF257F 53 47 CE                    	DC.B	'SG',('N'+0x80)
   2310 FFFF2582 00                          	DC.B	0
   2311 FFFF2583                             TAB5:
   2312 FFFF2583 54 CF                       	DC.B	'T',('O'+0x80)      ;     "TO" in "FOR"
   2313 FFFF2585 00                          	DC.B	0
   2314 FFFF2586                             TAB6:
   2315 FFFF2586 53 54 45 D0                 	DC.B	'STE',('P'+0x80)     ;    "STEP" in "FOR"
   2316 FFFF258A 00                          	DC.B	0
   2317 FFFF258B                             TAB8:
   2318 FFFF258B 3E BD                       	DC.B	'>',('='+0x80)        ;   Relational operators
   2319 FFFF258D 3C BE                       	DC.B	'<',('>'+0x80)
   2320 FFFF258F BE                          	DC.B	('>'+0x80)
   2321 FFFF2590 BD                          	DC.B	('='+0x80)
   2322 FFFF2591 3C BD                       	DC.B	'<',('='+0x80)
   2323 FFFF2593 BC                          	DC.B	('<'+0x80)
   2324 FFFF2594 00                          	DC.B	0
                                             ;	DC.B	0	;<- for aligning on a word boundary
                                             	
   2327 FFFF2595 FF                         	even
                                             	
                                             ;* Execution address tables:
   2330 FFFF2596                             TAB1_1:
   2331 FFFF2596 26B4                        	DC.W	LIST_			;Direct commands
   2332 FFFF2598 28F6                        	DC.W	LOAD
   2333 FFFF259A 264E                        	DC.W	NEW
   2334 FFFF259C 2662                        	DC.W	RUN
   2335 FFFF259E 295A                        	DC.W	SAVE
   2336 FFFF25A0 263C                        	DC.W	CLS
   2337 FFFF25A2                             TAB2_1:
   2338 FFFF25A2 2802                        	DC.W	NEXT			;Direct / statement
   2339 FFFF25A4 28E6                        	DC.W	LET
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 40
BOOTROM.x68
   2340 FFFF25A6 2852                        	DC.W	IF
   2341 FFFF25A8 26A0                        	DC.W	GOTO
   2342 FFFF25AA 274A                        	DC.W	GOSUB
   2343 FFFF25AC 2772                        	DC.W	RETURN
   2344 FFFF25AE 2850                        	DC.W	REM
   2345 FFFF25B0 2790                        	DC.W	FOR
   2346 FFFF25B2 2878                        	DC.W	INPUT
   2347 FFFF25B4 26E0                        	DC.W	PRINT
   2348 FFFF25B6 29DE                        	DC.W	POKE
   2349 FFFF25B8 265A                        	DC.W	STOP_
   2350 FFFF25BA 2418                        	DC.W	GOBYE
   2351 FFFF25BC 2A94                        	DC.W	CALL
   2352 FFFF25BE 2A32                        	DC.W	LINE
   2353 FFFF25C0 29FA                        	DC.W	POINT
   2354 FFFF25C2 2A16                        	DC.W    PENCOLOR
   2355 FFFF25C4 2A24                        	DC.W	FILLCOLOR
   2356 FFFF25C6 28E0                        	DC.W	DEFLT
   2357 FFFF25C8                             TAB4_1:
   2358 FFFF25C8 2CEE                        	DC.W	PEEK			;Functions
   2359 FFFF25CA 2CFA                        	DC.W	RND
   2360 FFFF25CC 2D26                        	DC.W	ABS
   2361 FFFF25CE 2D48                        	DC.W	SIZE_
   2362 FFFF25D0 2D52                        	DC.W	TICK
   2363 FFFF25D2 2D58                        	DC.W    TEMP
   2364 FFFF25D4 2D36                        	DC.W	SGN
   2365 FFFF25D6 2BC8                        	DC.W	XP40
   2366 FFFF25D8                             TAB5_1:
   2367 FFFF25D8 27AC                        	DC.W	FR1		;	"TO" in "FOR"
   2368 FFFF25DA 2DA4                        	DC.W	QWHAT
   2369 FFFF25DC                             TAB6_1:
   2370 FFFF25DC 27C4                        	DC.W	FR2		;	"STEP" in "FOR"
   2371 FFFF25DE 27CA                        	DC.W	FR3
   2372 FFFF25E0                             TAB8_1:
   2373 FFFF25E0 2AC0                        	DC.W	XP11;	>=		Relational operators
   2374 FFFF25E2 2AC8                        	DC.W	XP12	;<>
   2375 FFFF25E4 2AD0                        	DC.W	XP13	;>
   2376 FFFF25E6 2AE0                        	DC.W	XP15	;=
   2377 FFFF25E8 2AD8                        	DC.W	XP14	;<=
   2378 FFFF25EA 2AEA                        	DC.W	XP16	;<
   2379 FFFF25EC 2AFC                        	DC.W	XP17
                                             ;*
   2381 FFFF25EE                             DIRECT:
   2382 FFFF25EE 43F9 FFFF 2502              	LEA	TAB1,A1
   2383 FFFF25F4 45F9 FFFF 2596              	LEA	TAB1_1,A2
   2384 FFFF25FA                             EXEC:
   2385 FFFF25FA 6100 0A28                   	BSR.L	IGNBLK;		ignore leading blanks
   2386 FFFF25FE 2648                        	MOVE.L	A0,A3		;save the pointer
   2387 FFFF2600 4202                        	CLR.B	D2		;clear match flag
   2388 FFFF2602                             EXLP:
   2389 FFFF2602 1018                        	MOVE.B	(A0)+,D0;	get the program character
   2390 FFFF2604 1211                        	MOVE.B	(A1),D1 	;get the table character
   2391 FFFF2606 6604                        	BNE	EXNGO		;If end of table,
   2392 FFFF2608 204B                        	MOVE.L	A3,A0	;;	restore the text pointer and...
   2393 FFFF260A 6024                        	BRA	EXGO		;execute the default.
   2394 FFFF260C                             EXNGO:
   2395 FFFF260C 1600                        	MOVE.B	D0,D3	;	Else check for period...
   2396 FFFF260E C602                        	AND.B	D2,D3		;and a match.
   2397 FFFF2610 B63C 002E                   	CMP.B	#'.',D3
   2398 FFFF2614 671A                        	BEQ	EXGO		;if so, execute
   2399 FFFF2616 0201 007F                   	AND.B	#0x7F,D1 ;	ignore the table's high bit
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 41
BOOTROM.x68
   2400 FFFF261A B200                        	CMP.B	D0,D1	;	is there a match?
   2401 FFFF261C 670C                        	BEQ	EXMAT
   2402 FFFF261E 548A                        	ADDQ.L	#2,A2	;	if not, try the next entry
   2403 FFFF2620 204B                        	MOVE.L	A3,A0	;	reset the program pointer
   2404 FFFF2622 4202                        	CLR.B	D2		;sorry, no match
   2405 FFFF2624                             EX1:
   2406 FFFF2624 4A19                        	TST.B	(A1)+	;	get to the end of the entry
   2407 FFFF2626 6AFC                        	BPL	EX1
   2408 FFFF2628 60D8                        	BRA	EXLP		;back for more matching
   2409 FFFF262A                             EXMAT:
   2410 FFFF262A 74FF                        	MOVEQ	#-1,D2;		we've got a match so far
   2411 FFFF262C 4A19                        	TST.B	(A1)+	;	end of table entry?
   2412 FFFF262E 6AD2                        	BPL	EXLP		;if not, go back for more
   2413 FFFF2630                             EXGO:
   2414 FFFF2630 47F9 FFFF 0000              	LEA		0xFFFF0000,A3	;	execute the appropriate routine
   2415 FFFF2636 3452                        	move.w	(a2),a2
   2416 FFFF2638 4EF3 A000                   	JMP	(A3,A2.W)
                                             
   2418 FFFF263C                             CLS:
   2419 FFFF263C 4EB9 FFFF 18E8              	jsr		ClearScreen
   2420 FFFF2642 4278 0418                   	clr.w	CursorRow
   2421 FFFF2646 4278 041A                   	clr.w	CursorCol
   2422 FFFF264A 6000 FE14                   	bra		WSTART
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* What follows is the code to execute direct and statement
                                             ;* commands. Control is transferred to these points via the command
                                             ;* table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                             ;* After the command is executed, control is transferred to other
                                             ;* sections as follows:
                                             ;*
                                             ;* For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                                             ;* For 'RUN': go execute the first stored line if any; else go
                                             ;* back to the warm start point.
                                             ;* For 'GOTO' and 'GOSUB': go execute the target line.
                                             ;* For 'RETURN' and 'NEXT'; go back to saved return line.
                                             ;* For all others: if 'CURRNT' is 0, go to warm start; else go;
                                             ;* execute next command. (This is done in 'FINISH'.)
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                             ;*
                                             ;* 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                             ;*
                                             ;* 'STOP<CR>' goes back to WSTART
                                             ;*
                                             ;* 'RUN<CR>' finds the first stored line, stores its address
                                             ;* in CURRNT, and starts executing it. Note that only those
                                             ;* commands in TAB2 are legal for a stored program.
                                             ;*
                                             ;* There are 3 more entries in 'RUN':
                                             ;* 'RUNNXL' finds next line, stores it's address and executes it.
                                             ;* 'RUNTSL' stores the address of this line and executes it.
                                             ;* 'RUNSML' continues the execution on same line.
                                             ;*
                                             ;* 'GOTO expr<CR>' evaluates the expression, finds the target
                                             ;* line, and jumps to 'RUNTSL' to do it.
                                             ;*
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 42
BOOTROM.x68
   2460 FFFF264E                             NEW:
   2461 FFFF264E 6100 0748                   	BSR.L	ENDCHK
   2462 FFFF2652 21F9 FFFF 241C 0624         	MOVE.L	TXTBGN,TXTUNF	;set the end pointer
                                             
   2464 FFFF265A                             STOP_:
   2465 FFFF265A 6100 073C                   	BSR.L	ENDCHK
   2466 FFFF265E 6000 FE00                   	BRA	WSTART
                                             
   2468 FFFF2662                             RUN:
   2469 FFFF2662 6100 0734                   	BSR.L	ENDCHK
   2470 FFFF2666 2079 FFFF 241C              	MOVE.L	TXTBGN,A0	;set pointer to beginning
   2471 FFFF266C 21C8 0604                   	MOVE.L	A0,CURRNT
                                             
   2473 FFFF2670                             RUNNXL:
   2474 FFFF2670 4AB8 0604                   	TST.L	CURRNT	;	executing a program?
   2475 FFFF2674 6700 FDEA                   	BEQ.L	WSTART		;if not, we've finished a direct stat.
   2476 FFFF2678 4281                        	CLR.L	D1		;else find the next line number
   2477 FFFF267A 2248                        	MOVE.L	A0,A1
   2478 FFFF267C 6100 082C                   	BSR.L	FNDLNP
   2479 FFFF2680 6500 FDDE                   	BCS	WSTART		;if we've fallen off the end, stop
                                             
   2481 FFFF2684                             RUNTSL:
   2482 FFFF2684 21C9 0604                   	MOVE.L	A1,CURRNT	;set CURRNT to point to the line no.
   2483 FFFF2688 2049                        	MOVE.L	A1,A0		;set the text pointer to
   2484 FFFF268A 5488                        	ADDQ.L	#2,A0		;the start of the line text
                                             
   2486 FFFF268C                             RUNSML:
   2487 FFFF268C 6100 09EE                   	BSR.L	CHKIO	;	see if a control-C was pressed
   2488 FFFF2690 43F9 FFFF 2517              	LEA	TAB2,A1 	;find command in TAB2
   2489 FFFF2696 45F9 FFFF 25A2              	LEA	TAB2_1,A2
   2490 FFFF269C 6000 FF5C                   	BRA	EXEC		;and execute it
                                             
   2492 FFFF26A0                             GOTO:
   2493 FFFF26A0 6100 0408                   	BSR.L	EXPR	;	evaluate the following expression
   2494 FFFF26A4 6100 06F2                   	BSR.L	ENDCHK		;must find end of line
   2495 FFFF26A8 2200                        	MOVE.L	D0,D1
   2496 FFFF26AA 6100 07EE                   	BSR.L	FNDLN		;find the target line
   2497 FFFF26AE 6600 0740                   	BNE.L	QHOW		;no such line no.
   2498 FFFF26B2 60D0                        	BRA	RUNTSL		;go do it
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** LIST *** PRINT ***
                                             ;*
                                             ;* LIST has two forms:
                                             ;* 'LIST<CR>' lists all saved lines
                                             ;* 'LIST #<CR>' starts listing at the line #
                                             ;* Control-S pauses the listing, control-C stops it.
                                             ;*
                                             ;* PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                             ;* where '....' is a list of expressions, formats, back-arrows,
                                             ;* and strings.	These items a separated by commas.
                                             ;*
                                             ;* A format is a pound sign followed by a number.  It controls
                                             ;* the number of spaces the value of an expression is going to
                                             ;* be printed in.  It stays effective for the rest of the print
                                             ;* command unless changed by another format.  If no format is
                                             ;* specified, 11 positions will be used.
                                             ;*
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 43
BOOTROM.x68
                                             ;* A string is quoted in a pair of single- or double-quotes.
                                             ;*
                                             ;* An underline (back-arrow) means generate a <CR> without a <LF>
                                             ;*
                                             ;* A <CR LF> is generated after the entire list has been printed
                                             ;* or if the list is empty.  If the list ends with a semicolon,
                                             ;* however, no <CR LF> is generated.
                                             ;*
                                             
   2529 FFFF26B4                             LIST_:
   2530 FFFF26B4 6100 0936                   	BSR.L	TSTNUM	;	see if there's a line no.
   2531 FFFF26B8 6100 06DE                   	BSR.L	ENDCHK		;if not, we get a zero
   2532 FFFF26BC 6100 07DC                   	BSR.L	FNDLN		;find this or next line
   2533 FFFF26C0                             LS1:
   2534 FFFF26C0 6500 FD9E                   	BCS	WSTART		;warm start if we passed the end
   2535 FFFF26C4 6100 08F0                   	BSR.L	PRTLN	;	print the line
   2536 FFFF26C8 6100 09B2                   	BSR.L	CHKIO	;	check for listing halt request
   2537 FFFF26CC 670C                        	BEQ	LS3
   2538 FFFF26CE B03C 0013                   	CMP.B	#CTRLS,D0	;pause the listing?
   2539 FFFF26D2 6606                        	BNE	LS3
   2540 FFFF26D4                             LS2:
   2541 FFFF26D4 6100 09A6                   	BSR.L	CHKIO		;if so, wait for another keypress
   2542 FFFF26D8 67FA                        	BEQ	LS2
   2543 FFFF26DA                             LS3:
   2544 FFFF26DA 6100 07CE                   	BSR.L	FNDLNP		;find the next line
   2545 FFFF26DE 60E0                        	BRA	LS1
                                             
   2547 FFFF26E0                             PRINT:
   2548 FFFF26E0 780B                        	MOVE	#11,D4	;	D4 = number of print spaces
   2549 FFFF26E2 6100 08EE                   	BSR.L	TSTC		;if null list and ":"
   2550 FFFF26E6 3A 07                       	DC.B	':',PR2-$
   2551 FFFF26E8 6100 09A4                   	BSR.L	CRLF1		;give CR-LF and continue
   2552 FFFF26EC 609E                        	BRA	RUNSML		;execution on the same line
   2553 FFFF26EE                             PR2:
   2554 FFFF26EE 6100 08E2                   	BSR.L	TSTC		;if null list and <CR>
   2555 FFFF26F2 0D 09                       	DC.B	CR,PR0-$
   2556 FFFF26F4 6100 0998                   	BSR.L	CRLF1		;also give CR-LF and
   2557 FFFF26F8 6000 FF76                   	BRA	RUNNXL		;execute the next line
   2558 FFFF26FC                             PR0:
   2559 FFFF26FC 6100 08D4                   	BSR.L	TSTC		;else is it a format?
   2560 FFFF2700 23 09                       	DC.B	'#',PR1-$
   2561 FFFF2702 6100 03A6                   	BSR.L	EXPR		;yes, evaluate expression
   2562 FFFF2706 2800                        	MOVE	D0,D4		;and save it as print width
   2563 FFFF2708 6016                        	BRA	PR3		;look for more to print
   2564 FFFF270A                             PR1:
   2565 FFFF270A 6100 08C6                   	BSR.L	TSTC		;is character expression? (MRL)
   2566 FFFF270E 24 0B                       	DC.B	'$',PR4-$
   2567 FFFF2710 6100 0398                   	BSR.L	EXPR		;yep. Evaluate expression (MRL)
   2568 FFFF2714 6100 FCF2                   	BSR	GOOUT		;print low byte (MRL)
   2569 FFFF2718 6006                        	BRA	PR3		;look for more. (MRL)
   2570 FFFF271A                             PR4:
   2571 FFFF271A 6100 081E                   	BSR.L	QTSTG	;	is it a string?
   2572 FFFF271E 6012                        	BRA.S	PR8		;if not, must be an expression
   2573 FFFF2720                             PR3:
   2574 FFFF2720 6100 08B0                   	BSR.L	TSTC	;	if ",", go find next
   2575 FFFF2724 2C 07                       	DC.B	',',PR6-$
   2576 FFFF2726 6100 0656                   	BSR.L	FIN		;in the list.
   2577 FFFF272A 60D0                        	BRA	PR0
   2578 FFFF272C                             PR6:
   2579 FFFF272C 6100 0960                   	BSR.L	CRLF1	;	list ends here
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 44
BOOTROM.x68
   2580 FFFF2730 6010                        	BRA	FINISH
   2581 FFFF2732                             PR8:
   2582 FFFF2732 2F04                        	MOVE	D4,-(SP)	;save the width value
   2583 FFFF2734 6100 0374                   	BSR.L	EXPR		;evaluate the expression
   2584 FFFF2738 281F                        	MOVE	(SP)+,D4	;restore the width
   2585 FFFF273A 2200                        	MOVE.L	D0,D1
   2586 FFFF273C 6100 083C                   	BSR.L	PRTNUM		;print its value
   2587 FFFF2740 60DE                        	BRA	PR3		;more to print?
                                             
   2589 FFFF2742                             FINISH:
   2590 FFFF2742 6100 063A                   	BSR.L	FIN	;	Check end of command
   2591 FFFF2746 6000 065C                   	BRA.L	QWHAT	;	print "What?" if wrong
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** GOSUB *** & RETURN ***
                                             ;*
                                             ;* 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                             ;* except that the current text pointer, stack pointer, etc. are
                                             ;* saved so that execution can be continued after the subroutine
                                             ;* 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                             ;* recursive), the save area must be stacked.  The stack pointer
                                             ;* is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                             ;* If we are in the main routine, 'STKGOS' is zero (this was done
                                             ;* in the initialization section of the interpreter), but we still
                                             ;* save it as a flag for no further 'RETURN's.
                                             ;*
                                             ;* 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                             ;* returns the execution to the command after the most recent
                                             ;* 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                             ;* a 'GOSUB' and is thus an error.
                                             ;*
   2613 FFFF274A                             GOSUB:
   2614 FFFF274A 6100 07AC                   	BSR.L	PUSHA	;	save the current 'FOR' parameters
   2615 FFFF274E 6100 035A                   	BSR.L	EXPR		;get line number
   2616 FFFF2752 2F08                        	MOVE.L	A0,-(SP)	;save text pointer
   2617 FFFF2754 2200                        	MOVE.L	D0,D1
   2618 FFFF2756 6100 0742                   	BSR.L	FNDLN		;find the target line
   2619 FFFF275A 6600 0696                   	BNE.L	AHOW		;if not there, say "How?"
   2620 FFFF275E 2F38 0604                   	MOVE.L	CURRNT,-(SP)	;found it, save old 'CURRNT'...
   2621 FFFF2762 2F38 0608                   	MOVE.L	STKGOS,-(SP)	;and 'STKGOS'
   2622 FFFF2766 42B8 0610                   	CLR.L	LOPVAR		;load new values
   2623 FFFF276A 21CF 0608                   	MOVE.L	SP,STKGOS
   2624 FFFF276E 6000 FF14                   	BRA	RUNTSL
                                             
   2626 FFFF2772                             RETURN:
   2627 FFFF2772 6100 0624                   	BSR.L	ENDCHK	;	there should be just a <CR>
   2628 FFFF2776 2238 0608                   	MOVE.L	STKGOS,D1	;get old stack pointer
   2629 FFFF277A 6700 0628                   	BEQ.L	QWHAT		;if zero, it doesn't exist
   2630 FFFF277E 2E41                        	MOVE.L	D1,SP		;else restore it
   2631 FFFF2780 21DF 0608                   	MOVE.L	(SP)+,STKGOS	;and the old 'STKGOS'
   2632 FFFF2784 21DF 0604                   	MOVE.L	(SP)+,CURRNT	;and the old 'CURRNT'
   2633 FFFF2788 205F                        	MOVE.L	(SP)+,A0	;and the old text pointer
   2634 FFFF278A 6100 0752                   	BSR.L	POPA		;and the old 'FOR' parameters
   2635 FFFF278E 60B2                        	BRA	FINISH		;and we are back home
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 45
BOOTROM.x68
                                             ;* *** FOR *** & NEXT ***
                                             ;*
                                             ;* 'FOR' has two forms:
                                             ;* 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                             ;* The second form means the same thing as the first form with a
                                             ;* STEP of positive 1.  The interpreter will find the variable 'var'
                                             ;* and set its value to the current value of 'exp1'.  It also
                                             ;* evaluates 'exp2' and 'exp1' and saves all these together with
                                             ;* the text pointer, etc. in the 'FOR' save area, which consisits of
                                             ;* 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                             ;* already something in the save area (indicated by a non-zero
                                             ;* 'LOPVAR'), then the old save area is saved on the stack before
                                             ;* the new values are stored.  The interpreter will then dig in the
                                             ;* stack and find out if this same variable was used in another
                                             ;* currently active 'FOR' loop.  If that is the case, then the old
                                             ;* 'FOR' loop is deactivated. (i.e. purged from the stack)
                                             ;*
                                             ;* 'NEXT var' serves as the logical (not necessarily physical) end
                                             ;* of the 'FOR' loop.  The control variable 'var' is checked with
                                             ;* the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                             ;* the stack to find the right one and purges all those that didn't
                                             ;* match.  Either way, it then adds the 'STEP' to that variable and
                                             ;* checks the result with against the limit value.  If it is within
                                             ;* the limit, control loops back to the command following the
                                             ;* 'FOR'.  If it's outside the limit, the save area is purged and
                                             ;* execution continues.
                                             ;*
   2667 FFFF2790                             FOR:
   2668 FFFF2790 6100 0766                   	BSR.L	PUSHA		;save the old 'FOR' save area
   2669 FFFF2794 6100 05CE                   	BSR.L	SETVAL		;set the control variable
   2670 FFFF2798 21CE 0610                   	MOVE.L	A6,LOPVAR	;save its address
   2671 FFFF279C 43F9 FFFF 2583              	LEA	TAB5,A1 	;use 'EXEC' to test for 'TO'
   2672 FFFF27A2 45F9 FFFF 25D8              	LEA	TAB5_1,A2
   2673 FFFF27A8 6000 FE50                   	BRA	EXEC
   2674 FFFF27AC                             FR1:
   2675 FFFF27AC 6100 02FC                   	BSR.L	EXPR		;evaluate the limit
   2676 FFFF27B0 21C0 0618                   	MOVE.L	D0,LOPLMT	;save that
   2677 FFFF27B4 43F9 FFFF 2586              	LEA	TAB6,A1 	;use 'EXEC' to look for the
   2678 FFFF27BA 45F9 FFFF 25DC              	LEA	TAB6_1,A2	;word 'STEP'
   2679 FFFF27C0 6000 FE38                   	BRA	EXEC
   2680 FFFF27C4                             FR2:
   2681 FFFF27C4 6100 02E4                   	BSR.L	EXPR	;	found it, get the step value
   2682 FFFF27C8 6002                        	BRA	FR4
   2683 FFFF27CA                             FR3:
   2684 FFFF27CA 7001                        	MOVEQ	#1,D0	;	not found, step defaults to 1
   2685 FFFF27CC                             FR4:
   2686 FFFF27CC 21C0 0614                   	MOVE.L	D0,LOPINC	;save that too
   2687 FFFF27D0                             FR5:
   2688 FFFF27D0 21F8 0604 061C              	MOVE.L	CURRNT,LOPLN	;save address of current line number
   2689 FFFF27D6 21C8 0620                   	MOVE.L	A0,LOPPT	;and text pointer
   2690 FFFF27DA 2C4F                        	MOVE.L	SP,A6		;dig into the stack to find 'LOPVAR'
   2691 FFFF27DC 6006                        	BRA	FR7
   2692 FFFF27DE                             FR6:
   2693 FFFF27DE DDFC 0000 0014              	ADD.L	#20,A6		;look at next stack frame
   2694 FFFF27E4                             FR7:
   2695 FFFF27E4 2016                        	MOVE.L	(A6),D0 	;is it zero?
   2696 FFFF27E6 6716                        	BEQ	FR8		;if so, we're done
   2697 FFFF27E8 B0B8 0610                   	CMP.L	LOPVAR,D0	;same as current LOPVAR?
   2698 FFFF27EC 66F0                        	BNE	FR6		;nope, look some more
   2699 FFFF27EE 244F                        	MOVE.L	SP,A2	;	Else remove 5 long words from...
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 46
BOOTROM.x68
   2700 FFFF27F0 224E                        	MOVE.L	A6,A1	;	inside the stack.
   2701 FFFF27F2 47F8 0014                   	LEA	20,A3
   2702 FFFF27F6 D7C9                        	ADD.L	A1,A3
   2703 FFFF27F8 6100 06DC                   	BSR.L	MVDOWN
   2704 FFFF27FC 2E4B                        	MOVE.L	A3,SP	;	set the SP 5 long words up
   2705 FFFF27FE                             FR8:
   2706 FFFF27FE 6000 FF42                   	BRA	FINISH		;and continue execution
                                             
   2708 FFFF2802                             NEXT:
   2709 FFFF2802 6100 03F2                   	BSR.L	TSTV;		get address of variable
   2710 FFFF2806 6500 059C                   	BCS.L	QWHAT	;	if no variable, say "What?"
   2711 FFFF280A 2240                        	MOVE.L	D0,A1	;	save variable's address
   2712 FFFF280C                             NX0:
   2713 FFFF280C 2038 0610                   	MOVE.L	LOPVAR,D0;	If 'LOPVAR' is zero, we never...
   2714 FFFF2810 6700 0592                   	BEQ.L	QWHAT	;	had a FOR loop, so say "What?"
   2715 FFFF2814 B3C0                        	CMP.L	D0,A1	;;	else we check them
   2716 FFFF2816 6706                        	BEQ	NX3	;	OK, they agree
   2717 FFFF2818 6100 06C4                   	BSR.L	POPA	;	nope, let's see the next frame
   2718 FFFF281C 60EE                        	BRA	NX0
   2719 FFFF281E                             NX3:
   2720 FFFF281E 2011                        	MOVE.L	(A1),D0 ;	get control variable's value
   2721 FFFF2820 D0B8 0614                   	ADD.L	LOPINC,D0;	add in loop increment
   2722 FFFF2824 6900 05CA                   	BVS.L	QHOW	;	say "How?" for 32-bit overflow
   2723 FFFF2828 2280                        	MOVE.L	D0,(A1) ;	save control variable's new value
   2724 FFFF282A 2238 0618                   	MOVE.L	LOPLMT,D1;	get loop's limit value
   2725 FFFF282E 4AB8 0614                   	TST.L	LOPINC
   2726 FFFF2832 6A02                        	BPL	NX1	;	branch if loop increment is positive
   2727 FFFF2834 C141                        	EXG	D0,D1
   2728 FFFF2836                             NX1:
   2729 FFFF2836 B280                        	CMP.L	D0,D1;		test against limit
   2730 FFFF2838 6D0E                        	BLT	NX2;		branch if outside limit
   2731 FFFF283A 21F8 061C 0604              	MOVE.L	LOPLN,CURRNT	;Within limit, go back to the...
   2732 FFFF2840 2078 0620                   	MOVE.L	LOPPT,A0	;saved 'CURRNT' and text pointer.
   2733 FFFF2844 6000 FEFC                   	BRA	FINISH
   2734 FFFF2848                             NX2:
   2735 FFFF2848 6100 0694                   	BSR.L	POPA		;purge this loop
   2736 FFFF284C 6000 FEF4                   	BRA	FINISH
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                             ;*
                                             ;* 'REM' can be followed by anything and is ignored by the
                                             ;* interpreter.
                                             ;*
                                             ;* 'IF' is followed by an expression, as a condition and one or
                                             ;* more commands (including other 'IF's) separated by colons.
                                             ;* Note that the word 'THEN' is not used.  The interpreter evaluates
                                             ;* the expression.  If it is non-zero, execution continues.  If it
                                             ;* is zero, the commands that follow are ignored and execution
                                             ;* continues on the next line.
                                             ;*
                                             ;* 'INPUT' is like the 'PRINT' command, and is followed by a list
                                             ;* of items.  If the item is a string in single or double quotes,
                                             ;* or is an underline (back arrow), it has the same effect as in
                                             ;* 'PRINT'.  If an item is a variable, this variable name is
                                             ;* printed out followed by a colon, then the interpreter waits for
                                             ;* an expression to be typed in.  The variable is then set to the
                                             ;* value of this expression.  If the variable is preceeded by a
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 47
BOOTROM.x68
                                             ;* string (again in single or double quotes), the string will be
                                             ;* displayed followed by a colon.  The interpreter the waits for an
                                             ;* expression to be entered and sets the variable equal to the
                                             ;* expression's value.  If the input expression is invalid, the
                                             ;* interpreter will print "What?", "How?", or "Sorry" and reprint
                                             ;* the prompt and redo the input.  The execution will not terminate
                                             ;* unless you press control-C.  This is handled in 'INPERR'.
                                             ;*
                                             ;* 'LET' is followed by a list of items separated by commas.
                                             ;* Each item consists of a variable, an equals sign, and an
                                             ;* expression.  The interpreter evaluates the expression and sets
                                             ;* the variable to that value.  The interpreter will also handle
                                             ;* 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                             ;*
   2774 FFFF2850                             REM:
   2775 FFFF2850 600A                        	BRA	IF2		;skip the rest of the line
                                             
   2777 FFFF2852                             IF:	
   2778 FFFF2852 6100 0256                   	BSR.L	EXPR	;	evaluate the expression
   2779 FFFF2856                             IF1:
   2780 FFFF2856 4A80                        	TST.L	D0		;is it zero?
   2781 FFFF2858 6600 FE32                   	BNE	RUNSML		;if not, continue
   2782 FFFF285C                             IF2:
   2783 FFFF285C 2248                        	MOVE.L	A0,A1
   2784 FFFF285E 4281                        	CLR.L	D1
   2785 FFFF2860 6100 0662                   	BSR.L	FNDSKP	;	if so, skip the rest of the line
   2786 FFFF2864 6400 FE1E                   	BCC	RUNTSL		;and run the next line
   2787 FFFF2868 6000 FBF6                   	BRA.L	WSTART	;	if no next line, do a warm start
                                             
   2789 FFFF286C                             INPERR:
   2790 FFFF286C 2E78 060C                   	MOVE.L	STKINP,SP;	restore the old stack pointer
   2791 FFFF2870 21DF 0604                   	MOVE.L	(SP)+,CURRNT;	and old 'CURRNT'
   2792 FFFF2874 588F                        	ADDQ.L	#4,SP
   2793 FFFF2876 205F                        	MOVE.L	(SP)+,A0	;and old text pointer
                                             
   2795 FFFF2878                             INPUT:
   2796 FFFF2878 2F08                        	MOVE.L	A0,-(SP);	save in case of error
   2797 FFFF287A 6100 06BE                   	BSR.L	QTSTG		;is next item a string?
   2798 FFFF287E 600A                        	BRA.S	IP2		;nope
   2799 FFFF2880 6100 0374                   	BSR.L	TSTV	;	yes, but is it followed by a variable?
   2800 FFFF2884 654C                        	BCS	IP4		;if not, branch
   2801 FFFF2886 2440                        	MOVE.L	D0,A2	;	put away the variable's address
   2802 FFFF2888 601A                        	BRA	IP3		;if so, input to variable
   2803 FFFF288A                             IP2:
   2804 FFFF288A 2F08                        	MOVE.L	A0,-(SP);	save for 'PRTSTG'
   2805 FFFF288C 6100 0368                   	BSR.L	TSTV	;	must be a variable now
   2806 FFFF2890 6500 0512                   	BCS.L	QWHAT	;	"What?" it isn't?
   2807 FFFF2894 2440                        	MOVE.L	D0,A2	;	put away the variable's address
   2808 FFFF2896 1410                        	MOVE.B	(A0),D2 ;	get ready for 'PRTSTG'
   2809 FFFF2898 4200                        	CLR.B	D0
   2810 FFFF289A 1080                        	MOVE.B	D0,(A0)
   2811 FFFF289C 225F                        	MOVE.L	(SP)+,A1
   2812 FFFF289E 6100 067E                   	BSR.L	PRTSTG	;	print string as prompt
   2813 FFFF28A2 1082                        	MOVE.B	D2,(A0) ;	restore text
   2814 FFFF28A4                             IP3:
   2815 FFFF28A4 2F08                        	MOVE.L	A0,-(SP);	save in case of error
   2816 FFFF28A6 2F38 0604                   	MOVE.L	CURRNT,-(SP)	;also save 'CURRNT'
   2817 FFFF28AA 21FC FFFF FFFF 0604         	MOVE.L	#-1,CURRNT	;flag that we are in INPUT
   2818 FFFF28B2 21CF 060C                   	MOVE.L	SP,STKINP	;save the stack pointer too
   2819 FFFF28B6 2F0A                        	MOVE.L	A2,-(SP)	;save the variable address
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 48
BOOTROM.x68
   2820 FFFF28B8 103C 003A                   	MOVE.B	#':',D0     ;    print a colon first
   2821 FFFF28BC 6100 053C                   	BSR.L	GETLN		;then get an input line
   2822 FFFF28C0 41F8 0630                   	LEA	BUFFER,A0	;point to the buffer
   2823 FFFF28C4 6100 01E4                   	BSR.L	EXPR	;	evaluate the input
   2824 FFFF28C8 245F                        	MOVE.L	(SP)+,A2	;restore the variable address
   2825 FFFF28CA 2480                        	MOVE.L	D0,(A2) 	;save value in variable
   2826 FFFF28CC 21DF 0604                   	MOVE.L	(SP)+,CURRNT	;restore old 'CURRNT'
   2827 FFFF28D0 205F                        	MOVE.L	(SP)+,A0;	and the old text pointer
   2828 FFFF28D2                             IP4:
   2829 FFFF28D2 588F                        	ADDQ.L	#4,SP	;	clean up the stack
   2830 FFFF28D4 6100 06FC                   	BSR.L	TSTC	;	is the next thing a comma?
   2831 FFFF28D8 2C 03                       	DC.B	',',IP5-$
   2832 FFFF28DA 609C                        	BRA	INPUT	;	yes, more items
   2833 FFFF28DC                             IP5:
   2834 FFFF28DC 6000 FE64                   	BRA	FINISH
                                             
   2836 FFFF28E0                             DEFLT:
   2837 FFFF28E0 0C10 000D                   	CMP.B	#CR,(A0);	empty line is OK
   2838 FFFF28E4 670C                        	BEQ	LT1		;else it is 'LET'
                                             
   2840 FFFF28E6                             LET:
   2841 FFFF28E6 6100 047C                   	BSR.L	SETVAL		;do the assignment
   2842 FFFF28EA 6100 06E6                   	BSR.L	TSTC		;check for more 'LET' items
   2843 FFFF28EE 2C 03                       	DC.B	',',LT1-$
   2844 FFFF28F0 60F4                        	BRA	LET
   2845 FFFF28F2                             LT1:
   2846 FFFF28F2 6000 FE4E                   	BRA	FINISH		;until we are finished.
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** LOAD *** & SAVE ***
                                             ;*
                                             ;* These two commands transfer a program to/from an auxiliary
                                             ;* device such as a cassette, another computer, etc.  The program
                                             ;* is converted to an easily-stored format: each line starts with
                                             ;* a colon, the line no. as 4 hex digits, and the rest of the line.
                                             ;* At the end, a line starting with an '@' sign is sent.  This
                                             ;* format can be read back with a minimum of processing time by
                                             ;* the 68000.
                                             ;*
   2861 FFFF28F6                             LOAD:
   2862 FFFF28F6 2079 FFFF 241C              	MOVE.L	TXTBGN,A0	;set pointer to start of prog. area
   2863 FFFF28FC 103C 000D                   	MOVE.B	#CR,D0		;For a CP/M host, tell it we're ready...
   2864 FFFF2900 6100 FB0E                   	BSR	GOAUXO		;by sending a CR to finish PIP command.
   2865 FFFF2904                             LOD1:
   2866 FFFF2904 6100 FB0E                   	BSR	GOAUXI	;	look for start of line
   2867 FFFF2908 67FA                        	BEQ	LOD1
   2868 FFFF290A B03C 0040                   	CMP.B	#'@',D0  ;       end of program?
   2869 FFFF290E 6722                        	BEQ	LODEND
   2870 FFFF2910 B03C 003A                   	CMP.B	#':',D0   ;      if not, is it start of line?
   2871 FFFF2914 66EE                        	BNE	LOD1			;if not, wait for it
   2872 FFFF2916 6100 0022                   	BSR	GBYTE			;get first byte of line no.
   2873 FFFF291A 10C1                        	MOVE.B	D1,(A0)+	;store it
   2874 FFFF291C 6100 001C                   	BSR	GBYTE			;get 2nd bye of line no.
   2875 FFFF2920 10C1                        	MOVE.B	D1,(A0)+	;	store that, too
   2876 FFFF2922                             LOD2:
   2877 FFFF2922 6100 FAF0                   	BSR	GOAUXI	;	get another text char.
   2878 FFFF2926 67FA                        	BEQ	LOD2
   2879 FFFF2928 10C0                        	MOVE.B	D0,(A0)+	;store it
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 49
BOOTROM.x68
   2880 FFFF292A B03C 000D                   	CMP.B	#CR,D0		;is it the end of the line?
   2881 FFFF292E 66F2                        	BNE	LOD2		;if not, go back for more
   2882 FFFF2930 60D2                        	BRA	LOD1		;if so, start a new line
   2883 FFFF2932                             LODEND:
   2884 FFFF2932 21C8 0624                   	MOVE.L	A0,TXTUNF	;set end-of program pointer
   2885 FFFF2936 6000 FB28                   	BRA	WSTART		;back to direct mode
                                             
   2887 FFFF293A                             GBYTE:
   2888 FFFF293A 7401                        	MOVEQ	#1,D2	;		get two hex characters from auxiliary
   2889 FFFF293C 4281                        	CLR	D1			;and store them as a byte in D1
   2890 FFFF293E                             GBYTE1:
   2891 FFFF293E 6100 FAD4                   	BSR	GOAUXI		;	get a char.
   2892 FFFF2942 67FA                        	BEQ	GBYTE1
   2893 FFFF2944 B03C 0041                   	CMP.B	#'A',D0
   2894 FFFF2948 6502                        	BCS	GBYTE2
   2895 FFFF294A 5F00                        	SUBQ.B	#7,D0	;	if greater than 9, adjust
   2896 FFFF294C                             GBYTE2:
   2897 FFFF294C 0200 000F                   	AND.B	#0xF,D0		;strip ASCII
   2898 FFFF2950 E909                        	LSL.B	#4,D1		;put nybble into the result
   2899 FFFF2952 8200                        	OR.B	D0,D1
   2900 FFFF2954 51CA FFE8                   	DBRA	D2,GBYTE1	;get another char.
   2901 FFFF2958 4E75                        	RTS
                                             
   2903 FFFF295A                             SAVE:
   2904 FFFF295A 2079 FFFF 241C              	MOVE.L	TXTBGN,A0;	set pointer to start of prog. area
   2905 FFFF2960 2278 0624                   	MOVE.L	TXTUNF,A1	;set pointer to end of prog. area
   2906 FFFF2964                             SAVE1:
   2907 FFFF2964 103C 000D                   	MOVE.B	#CR,D0	;	send out a CR & LF (CP/M likes this)
   2908 FFFF2968 6100 FAA6                   	BSR	GOAUXO
   2909 FFFF296C 103C 000A                   	MOVE.B	#LF,D0
   2910 FFFF2970 6100 FA9E                   	BSR	GOAUXO
   2911 FFFF2974 B3C8                        	CMP.L	A0,A1		;are we finished?
   2912 FFFF2976 6322                        	BLS	SAVEND
   2913 FFFF2978 103C 003A                   	MOVE.B	#':',D0      ;   if not, start a line
   2914 FFFF297C 6100 FA92                   	BSR	GOAUXO
   2915 FFFF2980 1218                        	MOVE.B	(A0)+,D1	;send first half of line no.
   2916 FFFF2982 6100 003A                   	BSR	PBYTE
   2917 FFFF2986 1218                        	MOVE.B	(A0)+,D1	;and send 2nd half
   2918 FFFF2988 6100 0034                   	BSR	PBYTE
   2919 FFFF298C                             SAVE2:
   2920 FFFF298C 1018                        	MOVE.B	(A0)+,D0;	get a text char.
   2921 FFFF298E B03C 000D                   	CMP.B	#CR,D0		;is it the end of the line?
   2922 FFFF2992 67D0                        	BEQ	SAVE1		;if so, send CR & LF and start new line
   2923 FFFF2994 6100 FA7A                   	BSR	GOAUXO		;send it out
   2924 FFFF2998 60F2                        	BRA	SAVE2		;go back for more text
   2925 FFFF299A                             SAVEND:
   2926 FFFF299A 103C 0040                   	MOVE.B	#'@',D0 ;        send end-of-program indicator
   2927 FFFF299E 6100 FA70                   	BSR	GOAUXO
   2928 FFFF29A2 103C 000D                   	MOVE.B	#CR,D0	;	followed by a CR & LF
   2929 FFFF29A6 6100 FA68                   	BSR	GOAUXO
   2930 FFFF29AA 103C 000A                   	MOVE.B	#LF,D0
   2931 FFFF29AE 6100 FA60                   	BSR	GOAUXO
   2932 FFFF29B2 103C 001A                   	MOVE.B	#0x1A,D0 	;and a control-Z to end the CP/M file
   2933 FFFF29B6 6100 FA58                   	BSR	GOAUXO
   2934 FFFF29BA 6000 FAA4                   	BRA	WSTART		;then go do a warm start
                                             
   2936 FFFF29BE                             PBYTE:
   2937 FFFF29BE 7401                        	MOVEQ	#1,D2	;	send two hex characters from D1's low byte
   2938 FFFF29C0                             PBYTE1:
   2939 FFFF29C0 E919                        	ROL.B	#4,D1	;	get the next nybble
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 50
BOOTROM.x68
   2940 FFFF29C2 1001                        	MOVE.B	D1,D0
   2941 FFFF29C4 0200 000F                   	AND.B	#0xF,D0	;	strip off garbage
   2942 FFFF29C8 0600 0030                   	ADD.B	#'0',D0   ;      make it into ASCII
   2943 FFFF29CC B03C 0039                   	CMP.B	#'9',D0
   2944 FFFF29D0 6302                        	BLS	PBYTE2
   2945 FFFF29D2 5E00                        	ADDQ.B	#7,D0		;adjust if greater than 9
   2946 FFFF29D4                             PBYTE2:
   2947 FFFF29D4 6100 FA3A                   	BSR	GOAUXO		;send it out
   2948 FFFF29D8 51CA FFE6                   	DBRA	D2,PBYTE1	;then send the next nybble
   2949 FFFF29DC 4E75                        	RTS
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** POKE *** & CALL ***
                                             ;*
                                             ;* 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                             ;* address specified by 'expr1'.
                                             ;*
                                             ;* 'CALL expr' jumps to the machine language subroutine whose
                                             ;* starting address is specified by 'expr'.  The subroutine can use
                                             ;* all registers but must leave the stack the way it found it.
                                             ;* The subroutine returns to the interpreter by executing an RTS.
                                             ;*
   2964 FFFF29DE                             POKE:
   2965 FFFF29DE 6100 00CA                   	BSR	EXPR		;get the memory address
   2966 FFFF29E2 6100 05EE                   	BSR.L	TSTC		;it must be followed by a comma
   2967 FFFF29E6 2C 0F                       	DC.B	',',PKER-$
   2968 FFFF29E8 2F00                        	MOVE.L	D0,-(SP)	;save the address
   2969 FFFF29EA 6100 00BE                   	BSR	EXPR		;get the byte to be POKE'd
   2970 FFFF29EE 225F                        	MOVE.L	(SP)+,A1	;get the address back
   2971 FFFF29F0 1280                        	MOVE.B	D0,(A1) 	;store the byte in memory
   2972 FFFF29F2 6000 FD4E                   	BRA	FINISH
   2973 FFFF29F6                             PKER:
   2974 FFFF29F6 6000 03AC                   	BRA.L	QWHAT	;	if no comma, say "What?"
                                             
   2976 FFFF29FA                             POINT:
   2977 FFFF29FA 6100 00AE                   	BSR EXPR
   2978 FFFF29FE 6100 05D2                   	BSR	TSTC
   2979 FFFF2A02 2C F3                       	DC.B	',',PKER-$
   2980 FFFF2A04 2F00                        	MOVE.L	D0,-(SP)
   2981 FFFF2A06 6100 00A2                   	BSR	EXPR
   2982 FFFF2A0A 221F                        	MOVE.L  (SP)+,D1
   2983 FFFF2A0C 2400                        	MOVE.L	D0,D2
   2984 FFFF2A0E 6100 EAEE                   	BSR DrawPixel
   2985 FFFF2A12 6000 FD2E                   	BRA FINISH
                                             
   2987 FFFF2A16                             PENCOLOR:
   2988 FFFF2A16 6100 0092                   	BSR	EXPR
   2989 FFFF2A1A 23C0 FFDA E000              	MOVE.L	d0,GRAPHICS
   2990 FFFF2A20 6000 FD20                   	BRA FINISH
   2991 FFFF2A24                             FILLCOLOR:
   2992 FFFF2A24 6100 0084                   	BSR	EXPR
   2993 FFFF2A28 23C0 FFDA E004              	MOVE.L	d0,GRAPHICS+4
   2994 FFFF2A2E 6000 FD12                   	BRA FINISH
                                             
   2996 FFFF2A32                             LINE:
   2997 FFFF2A32 6100 0076                   	BSR	EXPR
   2998 FFFF2A36 6100 059A                   	BSR	TSTC
   2999 FFFF2A3A 2C 49                       	DC.B	',',LINEERR1-$
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 51
BOOTROM.x68
   3000 FFFF2A3C 2F00                        	MOVE.L	D0,-(SP)
   3001 FFFF2A3E 6100 006A                   	BSR	EXPR
   3002 FFFF2A42 6100 058E                   	BSR	TSTC
   3003 FFFF2A46 2C 41                       	DC.B	',',LINEERR2-$
   3004 FFFF2A48 2F00                        	MOVE.L	D0,-(SP)
   3005 FFFF2A4A 6100 005E                   	BSR	EXPR
   3006 FFFF2A4E 6100 0582                   	BSR	TSTC
   3007 FFFF2A52 2C 3B                       	DC.B	',',LINEERR3-$
   3008 FFFF2A54 2F00                        	MOVE.L	D0,-(SP)
   3009 FFFF2A56 6100 0052                   	BSR	EXPR
                                             ;	MOVE.L	D0,D4
                                             ;	MOVE.L	(SP)+,D3
                                             ;	MOVE.L	(SP)+,D2
                                             ;	MOVE.L	(SP)+,D1
                                             ;	BSR		DrawLine
   3015 FFFF2A5A 33C0 FFDA E00E              	MOVE.W	d0,GRAPHICS+14
   3016 FFFF2A60 201F                        	MOVE.L	(SP)+,d0
   3017 FFFF2A62 33C0 FFDA E00C              	MOVE.W	d0,GRAPHICS+12
   3018 FFFF2A68 201F                        	MOVE.L	(SP)+,d0
   3019 FFFF2A6A 33C0 FFDA E00A              	MOVE.W	d0,GRAPHICS+10
   3020 FFFF2A70 201F                        	MOVE.L	(SP)+,d0
   3021 FFFF2A72 33C0 FFDA E008              	MOVE.W	d0,GRAPHICS+8
   3022 FFFF2A78 33FC 0002 FFDA E01E         	MOVE.W	#G_DRAWLINE,GRAPHICS+30
   3023 FFFF2A80 6000 FCC0                   	BRA		FINISH
                                             	
   3025 FFFF2A84                             LINEERR1:
   3026 FFFF2A84 6000 031E                   	BRA.L	QWHAT
   3027 FFFF2A88                             LINEERR2:
   3028 FFFF2A88 588F                        	ADDQ	#4,SP
   3029 FFFF2A8A 6000 0318                   	BRA.L	QWHAT
   3030 FFFF2A8E                             LINEERR3:
   3031 FFFF2A8E 508F                        	ADD.L	#8,SP
   3032 FFFF2A90 6000 0312                   	BRA.L	QWHAT
                                             
   3034 FFFF2A94                             CALL:
   3035 FFFF2A94 6100 0014                   	BSR	EXPR		;get the subroutine's address
   3036 FFFF2A98 4A80                        	TST.L	D0		;make sure we got a valid address
   3037 FFFF2A9A 6700 0354                   	BEQ.L	QHOW	;	if not, say "How?"
   3038 FFFF2A9E 2F08                        	MOVE.L	A0,-(SP);	save the text pointer
   3039 FFFF2AA0 2240                        	MOVE.L	D0,A1
   3040 FFFF2AA2 4E91                        	JSR	(A1)		;jump to the subroutine
   3041 FFFF2AA4 205F                        	MOVE.L	(SP)+,A0	;restore the text pointer
   3042 FFFF2AA6 6000 FC9A                   	BRA	FINISH
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** EXPR ***
                                             ;*
                                             ;* 'EXPR' evaluates arithmetical or logical expressions.
                                             ;* <EXPR>::=<EXPR2>
                                             ;*	   <EXPR2><rel.op.><EXPR2>
                                             ;* where <rel.op.> is one of the operators in TAB8 and the result
                                             ;* of these operations is 1 if true and 0 if false.
                                             ;* <EXPR2>::=(+,-,&,|)<EXPR3>(+,-,&,|)<EXPR3>(...
                                             ;* where () are optional and (... are optional repeats.
                                             ;* <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                             ;* <EXPR4>::=<variable>
                                             ;*	    <function>
                                             ;*	    (<EXPR>)
                                             ;* <EXPR> is recursive so that the variable '@' can have an <EXPR>
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 52
BOOTROM.x68
                                             ;* as an index, functions can have an <EXPR> as arguments, and
                                             ;* <EXPR4> can be an <EXPR> in parenthesis.
                                             ;*
   3063 FFFF2AAA                             EXPR:
   3064 FFFF2AAA 6100 0066                   	BSR	EXPR2
   3065 FFFF2AAE 2F00                        	MOVE.L	D0,-(SP);	save <EXPR2> value
   3066 FFFF2AB0 43F9 FFFF 258B              	LEA	TAB8,A1 	;look up a relational operator
   3067 FFFF2AB6 45F9 FFFF 25E0              	LEA	TAB8_1,A2
   3068 FFFF2ABC 6000 FB3C                   	BRA	EXEC		;go do it
                                             
   3070 FFFF2AC0                             XP11:
   3071 FFFF2AC0 6100 003E                   	BSR	XP18	;	is it ">="?
   3072 FFFF2AC4 6D2E                        	BLT	XPRT0		;no, return D0=0
   3073 FFFF2AC6 6030                        	BRA	XPRT1		;else return D0=1
                                             
   3075 FFFF2AC8                             XP12:
   3076 FFFF2AC8 6100 0036                   	BSR	XP18	;	is it "<>"?
   3077 FFFF2ACC 6726                        	BEQ	XPRT0		;no, return D0=0
   3078 FFFF2ACE 6028                        	BRA	XPRT1		;else return D0=1
                                             
   3080 FFFF2AD0                             XP13:
   3081 FFFF2AD0 6100 002E                   	BSR	XP18	;	is it ">"?
   3082 FFFF2AD4 6F1E                        	BLE	XPRT0		;no, return D0=0
   3083 FFFF2AD6 6020                        	BRA	XPRT1		;else return D0=1
                                             
   3085 FFFF2AD8                             XP14:
   3086 FFFF2AD8 6100 0026                   	BSR	XP18	;	is it "<="?
   3087 FFFF2ADC 6E16                        	BGT	XPRT0		;no, return D0=0
   3088 FFFF2ADE 6018                        	BRA	XPRT1		;else return D0=1
                                             
   3090 FFFF2AE0                             XP15:
   3091 FFFF2AE0 6100 001E                   	BSR	XP18	;	is it "="?
   3092 FFFF2AE4 660E                        	BNE	XPRT0		;if not, return D0=0
   3093 FFFF2AE6 6010                        	BRA	XPRT1		;else return D0=1
   3094 FFFF2AE8                             XP15RT:
   3095 FFFF2AE8 4E75                        	RTS
                                             
   3097 FFFF2AEA                             XP16:
   3098 FFFF2AEA 6100 0014                   	BSR	XP18	;	is it "<"?
   3099 FFFF2AEE 6C04                        	BGE	XPRT0		;if not, return D0=0
   3100 FFFF2AF0 6006                        	BRA	XPRT1		;else return D0=1
   3101 FFFF2AF2                             XP16RT:
   3102 FFFF2AF2 4E75                        	RTS
                                             
   3104 FFFF2AF4                             XPRT0:
   3105 FFFF2AF4 4280                        	CLR.L	D0	;	return D0=0 (false)
   3106 FFFF2AF6 4E75                        	RTS
                                             
   3108 FFFF2AF8                             XPRT1:
   3109 FFFF2AF8 7001                        	MOVEQ	#1,D0;		return D0=1 (true)
   3110 FFFF2AFA 4E75                        	RTS
                                             
   3112 FFFF2AFC                             XP17:
   3113 FFFF2AFC 201F                        	MOVE.L	(SP)+,D0	;it's not a rel. operator
   3114 FFFF2AFE 4E75                        	RTS			;return D0=<EXPR2>
                                             
   3116 FFFF2B00                             XP18:
   3117 FFFF2B00 201F                        	MOVE.L	(SP)+,D0	;reverse the top two stack items
   3118 FFFF2B02 221F                        	MOVE.L	(SP)+,D1
   3119 FFFF2B04 2F00                        	MOVE.L	D0,-(SP)
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 53
BOOTROM.x68
   3120 FFFF2B06 2F01                        	MOVE.L	D1,-(SP)
   3121 FFFF2B08 6100 0008                   	BSR	EXPR2		;do second <EXPR2>
   3122 FFFF2B0C 221F                        	MOVE.L	(SP)+,D1
   3123 FFFF2B0E B280                        	CMP.L	D0,D1	;	compare with the first result
   3124 FFFF2B10 4E75                        	RTS			;return the result
                                             
   3126 FFFF2B12                             EXPR2:
   3127 FFFF2B12 6100 04BE                   	BSR.L	TSTC		;negative sign?
   3128 FFFF2B16 2D 05                       	DC.B	'-',XP20-$
   3129 FFFF2B18 4280                        	CLR.L	D0	;	yes, fake '0-'
   3130 FFFF2B1A 603C                        	BRA	XP26
   3131 FFFF2B1C                             XP20:
   3132 FFFF2B1C 6100 04B4                   	BSR.L	TSTC
   3133 FFFF2B20 21 11                       	DC.B	'!',XP21-$
   3134 FFFF2B22 4280                        	CLR.L	D0
   3135 FFFF2B24 2F00                        	MOVE.L	D0,-(SP)
   3136 FFFF2B26 6100 0062                   	BSR		EXPR3
   3137 FFFF2B2A 4680                        	NOT.L	D0
   3138 FFFF2B2C 4EF9 FFFF 2B48              	JMP		XP24
   3139 FFFF2B32                             XP21:
   3140 FFFF2B32 6100 049E                   	BSR.L	TSTC	;	positive sign? ignore it
   3141 FFFF2B36 2B 01                       	DC.B	'+',XP22-$
   3142 FFFF2B38                             XP22:
   3143 FFFF2B38 6100 0050                   	BSR	EXPR3		;first <EXPR3>
   3144 FFFF2B3C                             XP23:
   3145 FFFF2B3C 6100 0494                   	BSR.L	TSTC	;	add?
   3146 FFFF2B40 2B 11                       	DC.B	'+',XP25-$
   3147 FFFF2B42 2F00                        	MOVE.L	D0,-(SP)	;yes, save the value
   3148 FFFF2B44 6100 0044                   	BSR	EXPR3		;get the second <EXPR3>
   3149 FFFF2B48                             XP24:
   3150 FFFF2B48 221F                        	MOVE.L	(SP)+,D1
   3151 FFFF2B4A D081                        	ADD.L	D1,D0	;	add it to the first <EXPR3>
   3152 FFFF2B4C 6900 02A2                   	BVS.L	QHOW	;	branch if there's an overflow
   3153 FFFF2B50 60EA                        	BRA	XP23	;	else go back for more operations
   3154 FFFF2B52                             XP25:
   3155 FFFF2B52 6100 047E                   	BSR.L	TSTC		;subtract?
   3156 FFFF2B56 2D 0F                       	DC.B	'-',XP27-$	; was XP42-$
   3157 FFFF2B58                             XP26:
   3158 FFFF2B58 2F00                        	MOVE.L	D0,-(SP)	;yes, save the result of 1st <EXPR3>
   3159 FFFF2B5A 6100 002E                   	BSR	EXPR3		;get second <EXPR3>
   3160 FFFF2B5E 4480                        	NEG.L	D0		;change its sign
   3161 FFFF2B60 4EF9 FFFF 2B48              	JMP	XP24		;and do an addition
   3162 FFFF2B66                             XP27:
   3163 FFFF2B66 6100 046A                   	BSR.L	TSTC
   3164 FFFF2B6A 26 0D                       	DC.B	'&',XP28-$
   3165 FFFF2B6C 2F00                        	MOVE.L	D0,-(SP)
   3166 FFFF2B6E 6100 001A                   	BSR	EXPR3
   3167 FFFF2B72 221F                        	MOVE.L	(SP)+,D1
   3168 FFFF2B74 C081                        	AND.L	D1,D0
   3169 FFFF2B76 60C4                        	BRA		XP23
   3170 FFFF2B78                             XP28:
   3171 FFFF2B78 6100 0458                   	BSR.L	TSTC
   3172 FFFF2B7C 7C 73                       	DC.B	'|',XP42-$
   3173 FFFF2B7E 2F00                        	MOVE.L	D0,-(SP)
   3174 FFFF2B80 6100 0008                   	BSR	EXPR3
   3175 FFFF2B84 221F                        	MOVE.L	(SP)+,D1
   3176 FFFF2B86 8081                        	OR.L	D1,D0
   3177 FFFF2B88 60B2                        	BRA		XP23
                                             
   3179 FFFF2B8A                             EXPR3:
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 54
BOOTROM.x68
   3180 FFFF2B8A 6100 002C                   	BSR	EXPR4		;get first <EXPR4>
   3181 FFFF2B8E                             XP31:
   3182 FFFF2B8E 6100 0442                   	BSR.L	TSTC	;	multiply?
   3183 FFFF2B92 2A 0F                       	DC.B	'*',XP34-$
   3184 FFFF2B94 2F00                        	MOVE.L	D0,-(SP);	yes, save that first result
   3185 FFFF2B96 6100 0020                   	BSR	EXPR4		;get second <EXPR4>
   3186 FFFF2B9A 221F                        	MOVE.L	(SP)+,D1
   3187 FFFF2B9C 6100 00D2                   	BSR.L	MULT32	;	multiply the two
   3188 FFFF2BA0 60EC                        	BRA	XP31		;then look for more terms
   3189 FFFF2BA2                             XP34:
   3190 FFFF2BA2 6100 042E                   	BSR.L	TSTC;		divide?
   3191 FFFF2BA6 2F 49                       	DC.B	'/',XP42-$
   3192 FFFF2BA8 2F00                        	MOVE.L	D0,-(SP);	save result of 1st <EXPR4>
   3193 FFFF2BAA 6100 000C                   	BSR	EXPR4		;get second <EXPR4>
   3194 FFFF2BAE 221F                        	MOVE.L	(SP)+,D1
   3195 FFFF2BB0 C141                        	EXG	D0,D1
   3196 FFFF2BB2 6100 00FE                   	BSR.L	DIV32	;	do the division
   3197 FFFF2BB6 60D6                        	BRA	XP31		;go back for any more terms
                                             
   3199 FFFF2BB8                             EXPR4:
   3200 FFFF2BB8 43F9 FFFF 2569              	LEA	TAB4,A1 ;	find possible function
   3201 FFFF2BBE 45F9 FFFF 25C8              	LEA	TAB4_1,A2
   3202 FFFF2BC4 6000 FA34                   	BRA	EXEC
   3203 FFFF2BC8                             XP40:
   3204 FFFF2BC8 6100 002C                   	BSR	TSTV	;	nope, not a function
   3205 FFFF2BCC 6508                        	BCS	XP41		;nor a variable
   3206 FFFF2BCE 2240                        	MOVE.L	D0,A1
   3207 FFFF2BD0 4280                        	CLR.L	D0
   3208 FFFF2BD2 2011                        	MOVE.L	(A1),D0 ;	if a variable, return its value in D0
   3209 FFFF2BD4                             EXP4RT:
   3210 FFFF2BD4 4E75                        	RTS
   3211 FFFF2BD6                             XP41:
   3212 FFFF2BD6 6100 0414                   	BSR.L	TSTNUM	;	or is it a number?
   3213 FFFF2BDA 2001                        	MOVE.L	D1,D0
   3214 FFFF2BDC 4A82                        	TST	D2		;(if not, # of digits will be zero)
   3215 FFFF2BDE 66F4                        	BNE	EXP4RT	;	if so, return it in D0
   3216 FFFF2BE0                             PARN:
   3217 FFFF2BE0 6100 03F0                   	BSR.L	TSTC	;	else look for ( EXPR )
   3218 FFFF2BE4 28 0D                       	DC.B	'(',XP43-$
   3219 FFFF2BE6 6100 FEC2                   	BSR	EXPR
   3220 FFFF2BEA 6100 03E6                   	BSR.L	TSTC
   3221 FFFF2BEE 29 03                       	DC.B	')',XP43-$
   3222 FFFF2BF0                             XP42:
   3223 FFFF2BF0 4E75                        	RTS
   3224 FFFF2BF2                             XP43:
   3225 FFFF2BF2 6000 01B0                   	BRA.L	QWHAT	;	else say "What?"
                                             
                                             ;*
                                             ;* ===== Test for a valid variable name.  Returns Carry=1 if not
                                             ;*	found, else returns Carry=0 and the address of the
                                             ;*	variable in D0.
                                             
   3232 FFFF2BF6                             TSTV:
   3233 FFFF2BF6 6100 042C                   	BSR.L	IGNBLK
   3234 FFFF2BFA 4280                        	CLR.L	D0
   3235 FFFF2BFC 1010                        	MOVE.B	(A0),D0 ;	look at the program text
   3236 FFFF2BFE 0400 0040                   	SUB.B	#'@',D0
   3237 FFFF2C02 6554                        	BCS	TSTVRT	;	C=1: not a variable
   3238 FFFF2C04 6628                        	BNE	TV1		;branch if not "@" array
   3239 FFFF2C06 5288                        	ADDQ	#1,A0	;	If it is, it should be
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 55
BOOTROM.x68
   3240 FFFF2C08 6100 FFD6                   	BSR	PARN		;followed by (EXPR) as its index.
   3241 FFFF2C0C D080                        	ADD.L	D0,D0
   3242 FFFF2C0E 6500 01E0                   	BCS.L	QHOW	;	say "How?" if index is too big
   3243 FFFF2C12 D080                        	ADD.L	D0,D0
   3244 FFFF2C14 6500 01DA                   	BCS.L	QHOW
   3245 FFFF2C18 2F00                        	MOVE.L	D0,-(SP)	;save the index
   3246 FFFF2C1A 6100 012C                   	BSR.L	SIZE_		;get amount of free memory
   3247 FFFF2C1E 221F                        	MOVE.L	(SP)+,D1	;get back the index
   3248 FFFF2C20 B081                        	CMP.L	D1,D0		;see if there's enough memory
   3249 FFFF2C22 6300 01C2                   	BLS.L	QSORRY		;if not, say "Sorry"
   3250 FFFF2C26 2038 0628                   	MOVE.L	VARBGN,D0	;put address of array element...
   3251 FFFF2C2A 9081                        	SUB.L	D1,D0		;into D0
   3252 FFFF2C2C 4E75                        	RTS
   3253 FFFF2C2E                             TV1:
   3254 FFFF2C2E B03C 001B                   	CMP.B	#27,D0		;if not @, is it A through Z?
   3255 FFFF2C32 0A3C 0001                   	EOR	#1,CCR
   3256 FFFF2C36 6520                        	BCS	TSTVRT		;if not, set Carry and return
   3257 FFFF2C38 5288                        	ADDQ	#1,A0	;	else bump the text pointer
                                             ;
   3259 FFFF2C3A 4281                        	CLR.L	D1
   3260 FFFF2C3C 1210                        	MOVE.B	(a0),D1
   3261 FFFF2C3E 6100 001A                   	BSR		CVT26
   3262 FFFF2C42 0C01 00FF                   	cmpi.b	#0xff,d1
   3263 FFFF2C46 6706                        	beq		tv2
   3264 FFFF2C48 5288                        	ADDQ	#1,A0	; bump text pointer
   3265 FFFF2C4A EB81                        	asl.l	#5,D1
   3266 FFFF2C4C D081                        	ADD.L	D1,D0
   3267 FFFF2C4E                             tv2:
   3268 FFFF2C4E D080                        	ADD	D0,D0		;compute the variable's address
   3269 FFFF2C50 D080                        	ADD	D0,D0
   3270 FFFF2C52 2238 0628                   	MOVE.L	VARBGN,D1
   3271 FFFF2C56 D081                        	ADD	D1,D0		;and return it in D0 with Carry=0
   3272 FFFF2C58                             TSTVRT:
   3273 FFFF2C58 4E75                        	RTS
                                             
   3275 FFFF2C5A                             CVT26:
   3276 FFFF2C5A 0C01 0041                   	cmpi.b	#'A',d1
   3277 FFFF2C5E 650C                        	blo		CVT26a
   3278 FFFF2C60 0C01 005A                   	cmpi.b	#'Z',d1
   3279 FFFF2C64 6206                        	bhi		CVT26a
   3280 FFFF2C66 0401 0041                   	subi.b	#'A',d1
   3281 FFFF2C6A 4E75                        	rts
   3282 FFFF2C6C                             CVT26a:
   3283 FFFF2C6C 72FF                        	moveq	#-1,d1
   3284 FFFF2C6E 4E75                        	rts
                                             ;*
                                             ;* ===== Multiplies the 32 bit values in D0 and D1, returning
                                             ;*	the 32 bit result in D0.
                                             ;*
   3289 FFFF2C70                             MULT32:
   3290 FFFF2C70 2801                        	MOVE.L	D1,D4
   3291 FFFF2C72 B184                        	EOR.L	D0,D4	;	see if the signs are the same
   3292 FFFF2C74 4A80                        	TST.L	D0		;take absolute value of D0
   3293 FFFF2C76 6A02                        	BPL	MLT1
   3294 FFFF2C78 4480                        	NEG.L	D0
   3295 FFFF2C7A                             MLT1:
   3296 FFFF2C7A 4A81                        	TST.L	D1	;	take absolute value of D1
   3297 FFFF2C7C 6A02                        	BPL	MLT2
   3298 FFFF2C7E 4481                        	NEG.L	D1
   3299 FFFF2C80                             MLT2:
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 56
BOOTROM.x68
   3300 FFFF2C80 B2BC 0000 FFFF              	CMP.L	#0xFFFF,D1	;is second argument <= 16 bits?
   3301 FFFF2C86 630C                        	BLS	MLT3	;	OK, let it through
   3302 FFFF2C88 C141                        	EXG	D0,D1	;	else swap the two arguments
   3303 FFFF2C8A B2BC 0000 FFFF              	CMP.L	#0xFFFF,D1	;and check 2nd argument again
   3304 FFFF2C90 6200 015E                   	BHI.L	QHOW		;one of them MUST be 16 bits
   3305 FFFF2C94                             MLT3:
   3306 FFFF2C94 2400                        	MOVE	D0,D2	;	prepare for 32 bit X 16 bit multiply
   3307 FFFF2C96 C4C1                        	MULU	D1,D2		;multiply low word
   3308 FFFF2C98 4840                        	SWAP	D0
   3309 FFFF2C9A C0C1                        	MULU	D1,D0		;multiply high word
   3310 FFFF2C9C 4840                        	SWAP	D0
                                             ;*** Rick Murray's bug correction follows:
   3312 FFFF2C9E 4A80                        	TST	D0		;if lower word not 0, then overflow
   3313 FFFF2CA0 6600 014E                   	BNE.L	QHOW	;	if overflow, say "How?"
   3314 FFFF2CA4 D082                        	ADD.L	D2,D0	;	D0 now holds the product
   3315 FFFF2CA6 6B00 0148                   	BMI.L	QHOW	;	if sign bit set, it's an overflow
   3316 FFFF2CAA 4A84                        	TST.L	D4		;were the signs the same?
   3317 FFFF2CAC 6A02                        	BPL	MLTRET
   3318 FFFF2CAE 4480                        	NEG.L	D0		;if not, make the result negative
   3319 FFFF2CB0                             MLTRET:
   3320 FFFF2CB0 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                                             ;*	Returns the 32 bit quotient in D0, remainder in D1.
                                             ;*
   3326 FFFF2CB2                             DIV32:
   3327 FFFF2CB2 4A81                        	TST.L	D1		;check for divide-by-zero
   3328 FFFF2CB4 6700 013A                   	BEQ.L	QHOW		;if so, say "How?"
   3329 FFFF2CB8 2401                        	MOVE.L	D1,D2
   3330 FFFF2CBA 2801                        	MOVE.L	D1,D4
   3331 FFFF2CBC B184                        	EOR.L	D0,D4		;see if the signs are the same
   3332 FFFF2CBE 4A80                        	TST.L	D0		;take absolute value of D0
   3333 FFFF2CC0 6A02                        	BPL	DIV1
   3334 FFFF2CC2 4480                        	NEG.L	D0
   3335 FFFF2CC4                             DIV1:
   3336 FFFF2CC4 4A81                        	TST.L	D1	;	take absolute value of D1
   3337 FFFF2CC6 6A02                        	BPL	DIV2
   3338 FFFF2CC8 4481                        	NEG.L	D1
   3339 FFFF2CCA                             DIV2:
   3340 FFFF2CCA 761F                        	MOVEQ	#31,D3	;	iteration count for 32 bits
   3341 FFFF2CCC 2200                        	MOVE.L	D0,D1
   3342 FFFF2CCE 4280                        	CLR.L	D0
   3343 FFFF2CD0                             DIV3:
   3344 FFFF2CD0 D281                        	ADD.L	D1,D1	;	(This algorithm was translated from
   3345 FFFF2CD2 D180                        	ADDX.L	D0,D0		;the divide routine in Ron Cain's
   3346 FFFF2CD4 6708                        	BEQ	DIV4		;Small-C run time library.)
   3347 FFFF2CD6 B082                        	CMP.L	D2,D0
   3348 FFFF2CD8 6B04                        	BMI	DIV4
   3349 FFFF2CDA 5281                        	ADDQ.L	#1,D1
   3350 FFFF2CDC 9082                        	SUB.L	D2,D0
   3351 FFFF2CDE                             DIV4:
   3352 FFFF2CDE 51CB FFF0                   	DBRA	D3,DIV3
   3353 FFFF2CE2 C141                        	EXG	D0,D1	;	put rem. & quot. in proper registers
   3354 FFFF2CE4 4A84                        	TST.L	D4	;	were the signs the same?
   3355 FFFF2CE6 6A04                        	BPL	DIVRT
   3356 FFFF2CE8 4480                        	NEG.L	D0	;	if not, results are negative
   3357 FFFF2CEA 4481                        	NEG.L	D1
   3358 FFFF2CEC                             DIVRT:
   3359 FFFF2CEC 4E75                        	RTS
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 57
BOOTROM.x68
                                             
                                             ;*
                                             ;* ===== The PEEK function returns the byte stored at the address
                                             ;*	contained in the following expression.
                                             ;*
   3365 FFFF2CEE                             PEEK:
   3366 FFFF2CEE 6100 FEF0                   	BSR	PARN	;	get the memory address
   3367 FFFF2CF2 2240                        	MOVE.L	D0,A1
   3368 FFFF2CF4 4280                        	CLR.L	D0		;upper 3 bytes will be zero
   3369 FFFF2CF6 1011                        	MOVE.B	(A1),D0 ;	get the addressed byte
   3370 FFFF2CF8 4E75                        	RTS			;and return it
                                             
                                             ;*
                                             ;* ===== The RND function returns a random number from 1 to
                                             ;*	the value of the following expression in D0.
                                             ;*
   3376 FFFF2CFA                             RND:
   3377 FFFF2CFA 6100 FEE4                   	BSR	PARN	;	get the upper limit
   3378 FFFF2CFE 4A80                        	TST.L	D0	;	it must be positive and non-zero
   3379 FFFF2D00 6700 00EE                   	BEQ.L	QHOW
   3380 FFFF2D04 6B00 00EA                   	BMI.L	QHOW
                                             	
                                             ;	move.l	d0,-(a7)
                                             ;	move.l	RANPNT,D1
                                             ;	move.l	#16807,d0
                                             ;	bsr		MULT32
                                             ;	move.l	d0,RANPNT
                                             ;	move.l	(a7)+,d1
   3388 FFFF2D08 2200                        	MOVE.L	D0,D1
   3389 FFFF2D0A 3039 FFDC 0C02              	MOVE.W	RANDOM+2,D0
   3390 FFFF2D10 4840                        	SWAP	D0
   3391 FFFF2D12 3039 FFDC 0C00              	MOVE.W	RANDOM,D0
                                             
                                             ;	MOVE.L	D0,D1
                                             ;	MOVE.L	RANPNT,A1	;get memory as a random number
                                             ;	CMP.L	#LSTROM,A1
                                             ;	BCS	RA1
                                             ;	LEA	START,A1	;wrap around if end of program
                                             ;RA1:
                                             ;	MOVE.L	(A1)+,D0;	get the slightly random number
   3400 FFFF2D18 0880 001F                   	BCLR	#31,D0	;	make sure it's positive
                                             ;	MOVE.L	A1,RANPNT	;(even I can do better than this!)
   3402 FFFF2D1C 6100 FF94                   	BSR	DIV32		;RND(n)=MOD(number,n)+1
   3403 FFFF2D20 2001                        	MOVE.L	D1,D0	;	MOD is the remainder of the div.
   3404 FFFF2D22 5280                        	ADDQ.L	#1,D0
   3405 FFFF2D24 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== The ABS function returns an absolute value in D0.
                                             ;*
   3410 FFFF2D26                             ABS:
   3411 FFFF2D26 6100 FEB8                   	BSR	PARN		;get the following expr.'s value
   3412 FFFF2D2A 4A80                        	TST.L	D0
   3413 FFFF2D2C 6A06                        	BPL	ABSRT
   3414 FFFF2D2E 4480                        	NEG.L	D0		;if negative, complement it
   3415 FFFF2D30 6B00 00BE                   	BMI.L	QHOW	;	if still negative, it was too big
   3416 FFFF2D34                             ABSRT:
   3417 FFFF2D34 4E75                        	RTS
                                             
                                             ;* RTF
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 58
BOOTROM.x68
                                             ;* ===== The SGN function returns the sign value in D0.
                                             ;*
   3422 FFFF2D36                             SGN:
   3423 FFFF2D36 6100 FEA8                   	BSR		PARN	;get the following expr.'s value
   3424 FFFF2D3A 4A80                        	TST.L	D0
   3425 FFFF2D3C 6704                        	BEQ		SGNRT
   3426 FFFF2D3E 6B04                        	BMI		SGNMI
   3427 FFFF2D40 7001                        	MOVEQ	#1,d0
   3428 FFFF2D42                             SGNRT:
   3429 FFFF2D42 4E75                        	RTS
   3430 FFFF2D44                             SGNMI:
   3431 FFFF2D44 70FF                        	MOVEQ	#-1,d0
   3432 FFFF2D46 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== The SIZE function returns the size of free memory in D0.
                                             ;*
   3437 FFFF2D48                             SIZE_:
   3438 FFFF2D48 2038 0628                   	MOVE.L	VARBGN,D0	;get the number of free bytes...
   3439 FFFF2D4C 90B8 0624                   	SUB.L	TXTUNF,D0	;between 'TXTUNF' and 'VARBGN'
   3440 FFFF2D50 4E75                        	RTS			;return the number in D0
                                             
                                             ;* RTF
                                             ;* ===== return the millisecond time value
                                             ;*
   3445 FFFF2D52                             TICK:
   3446 FFFF2D52 2038 0400                   	move.l	Milliseconds,d0
   3447 FFFF2D56 4E75                        	rts
                                             	
   3449 FFFF2D58                             TEMP:
   3450 FFFF2D58 6100 F154                   	bsr		ReadTemp
   3451 FFFF2D5C 0280 0000 FFFF              	andi.l	#0xffff,d0
   3452 FFFF2D62 4E75                        	rts
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                             ;*
                                             ;* 'SETVAL' expects a variable, followed by an equal sign and then
                                             ;* an expression.  It evaluates the expression and sets the variable
                                             ;* to that value.
                                             ;*
                                             ;* 'FIN' checks the end of a command.  If it ended with ":",
                                             ;* execution continues.	If it ended with a CR, it finds the
                                             ;* the next line and continues from there.
                                             ;*
                                             ;* 'ENDCHK' checks if a command is ended with a CR. This is
                                             ;* required in certain commands, such as GOTO, RETURN, STOP, etc.
                                             ;*
                                             ;* 'ERROR' prints the string pointed to by A0. It then prints the
                                             ;* line pointed to by CURRNT with a "?" inserted at where the
                                             ;* old text pointer (should be on top of the stack) points to.
                                             ;* Execution of Tiny BASIC is stopped and a warm start is done.
                                             ;* If CURRNT is zero (indicating a direct command), the direct
                                             ;* command is not printed. If CURRNT is -1 (indicating
                                             ;* 'INPUT' command in progress), the input line is not printed
                                             ;* and execution is not terminated but continues at 'INPERR'.
                                             ;*
                                             ;* Related to 'ERROR' are the following:
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 59
BOOTROM.x68
                                             ;* 'QWHAT' saves text pointer on stack and gets "What?" message.
                                             ;* 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                             ;* 'QSORRY' and 'ASORRY' do the same kind of thing.
                                             ;* 'QHOW' and 'AHOW' also do this for "How?".
                                             ;*
   3485 FFFF2D64                             SETVAL:
   3486 FFFF2D64 6100 FE90                   	BSR	TSTV	;	variable name?
   3487 FFFF2D68 653A                        	BCS	QWHAT		;if not, say "What?"
   3488 FFFF2D6A 2F00                        	MOVE.L	D0,-(SP);	save the variable's address
   3489 FFFF2D6C 6100 0264                   	BSR.L	TSTC	;	get past the "=" sign
   3490 FFFF2D70 3D 0B                       	DC.B	'=',SV1-$
   3491 FFFF2D72 6100 FD36                   	BSR	EXPR	;	evaluate the expression
   3492 FFFF2D76 2C5F                        	MOVE.L	(SP)+,A6
   3493 FFFF2D78 2C80                        	MOVE.L	D0,(A6) ;	and save its value in the variable
   3494 FFFF2D7A 4E75                        	RTS
   3495 FFFF2D7C                             SV1:
   3496 FFFF2D7C 6026                        	BRA	QWHAT	;	if no "=" sign
                                             
   3498 FFFF2D7E                             FIN:
   3499 FFFF2D7E 6100 0252                   	BSR.L	TSTC	;	*** FIN ***
   3500 FFFF2D82 3A 07                       	DC.B	':',FI1-$
   3501 FFFF2D84 588F                        	ADDQ.L	#4,SP	;	if ":", discard return address
   3502 FFFF2D86 6000 F904                   	BRA	RUNSML	;	continue on the same line
   3503 FFFF2D8A                             FI1:
   3504 FFFF2D8A 6100 0246                   	BSR.L	TSTC	;	not ":", is it a CR?
   3505 FFFF2D8E 0D 07                       	DC.B	CR,FI2-$
   3506 FFFF2D90 588F                        	ADDQ.L	#4,SP	;	yes, purge return address
   3507 FFFF2D92 6000 F8DC                   	BRA	RUNNXL		;execute the next line
   3508 FFFF2D96                             FI2:
   3509 FFFF2D96 4E75                        	RTS			;else return to the caller
                                             
   3511 FFFF2D98                             ENDCHK:
   3512 FFFF2D98 6100 028A                   	BSR.L	IGNBLK
   3513 FFFF2D9C 0C10 000D                   	CMP.B	#CR,(A0);	does it end with a CR?
   3514 FFFF2DA0 6602                        	BNE	QWHAT	;	if not, say "WHAT?"
   3515 FFFF2DA2 4E75                        	RTS
                                             
   3517 FFFF2DA4                             QWHAT:
   3518 FFFF2DA4 2F08                        	MOVE.L	A0,-(SP)
   3519 FFFF2DA6                             AWHAT:
   3520 FFFF2DA6 4DF9 FFFF 312C              	LEA	WHTMSG,A6
   3521 FFFF2DAC                             ERROR:
   3522 FFFF2DAC 6100 02E6                   	BSR.L	PRMESG	;	display the error message
   3523 FFFF2DB0 205F                        	MOVE.L	(SP)+,A0	;restore the text pointer
   3524 FFFF2DB2 2038 0604                   	MOVE.L	CURRNT,D0	;get the current line number
   3525 FFFF2DB6 6700 F6A8                   	BEQ	WSTART		;if zero, do a warm start
   3526 FFFF2DBA B0BC FFFF FFFF              	CMP.L	#-1,D0		;is the line no. pointer = -1?
   3527 FFFF2DC0 6700 FAAA                   	BEQ	INPERR		;if so, redo input
   3528 FFFF2DC4 1F10                        	MOVE.B	(A0),-(SP)	;save the char. pointed to
   3529 FFFF2DC6 4210                        	CLR.B	(A0)		;put a zero where the error is
   3530 FFFF2DC8 2278 0604                   	MOVE.L	CURRNT,A1	;point to start of current line
   3531 FFFF2DCC 6100 01E8                   	BSR.L	PRTLN		;display the line in error up to the 0
   3532 FFFF2DD0 109F                        	MOVE.B	(SP)+,(A0)	;restore the character
   3533 FFFF2DD2 103C 003F                   	MOVE.B	#'?',D0     ;    display a "?"
   3534 FFFF2DD6 6100 F630                   	BSR	GOOUT
   3535 FFFF2DDA 4280                        	CLR	D0
   3536 FFFF2DDC 5389                        	SUBQ.L	#1,A1		;point back to the error char.
   3537 FFFF2DDE 6100 013E                   	BSR.L	PRTSTG		;display the rest of the line
   3538 FFFF2DE2 6000 F67C                   	BRA	WSTART		;and do a warm start
   3539 FFFF2DE6                             QSORRY:
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 60
BOOTROM.x68
   3540 FFFF2DE6 2F08                        	MOVE.L	A0,-(SP)
   3541 FFFF2DE8                             ASORRY:
   3542 FFFF2DE8 4DF9 FFFF 3134              	LEA	SRYMSG,A6
   3543 FFFF2DEE 60BC                        	BRA	ERROR
   3544 FFFF2DF0                             QHOW:
   3545 FFFF2DF0 2F08                        	MOVE.L	A0,-(SP)	;Error: "How?"
   3546 FFFF2DF2                             AHOW:
   3547 FFFF2DF2 4DF9 FFFF 3125              	LEA	HOWMSG,A6
   3548 FFFF2DF8 60B2                        	BRA	ERROR
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** GETLN *** FNDLN (& friends) ***
                                             ;*
                                             ;* 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                             ;* the character in D0 (given by the caller), then it fills the
                                             ;* buffer and echos. It ignores LF's but still echos
                                             ;* them back. Control-H is used to delete the last character
                                             ;* entered (if there is one), and control-X is used to delete the
                                             ;* whole line and start over again. CR signals the end of a line,
                                             ;* and causes 'GETLN' to return.
                                             ;*
   3562 FFFF2DFA                             GETLN:
   3563 FFFF2DFA 6100 F60C                   	BSR	GOOUT		;display the prompt
   3564 FFFF2DFE 103C 0020                   	MOVE.B	#' ',D0      ;   and a space
   3565 FFFF2E02 6100 F604                   	BSR	GOOUT
   3566 FFFF2E06 41F8 0630                   	LEA	BUFFER,A0;	A0 is the buffer pointer
   3567 FFFF2E0A                             GL1:
   3568 FFFF2E0A 6100 0270                   	BSR.L	CHKIO;		check keyboard
   3569 FFFF2E0E 67FA                        	BEQ	GL1	;	wait for a char. to come in
   3570 FFFF2E10 B03C 0008                   	CMP.B	#CTRLH,D0	;delete last character?
   3571 FFFF2E14 6726                        	BEQ	GL3	;	if so
   3572 FFFF2E16 B03C 0018                   	CMP.B	#CTRLX,D0;	delete the whole line?
   3573 FFFF2E1A 6744                        	BEQ	GL4	;	if so
   3574 FFFF2E1C B03C 000D                   	CMP.B	#CR,D0	;	accept a CR
   3575 FFFF2E20 6706                        	BEQ	GL2
   3576 FFFF2E22 B03C 0020                   	CMP.B	#' ',D0  ;       if other control char., discard it
   3577 FFFF2E26 65E2                        	BCS	GL1
   3578 FFFF2E28                             GL2:
   3579 FFFF2E28 10C0                        	MOVE.B	D0,(A0)+;	save the char.
   3580 FFFF2E2A 6100 F5DC                   	BSR	GOOUT		;echo the char back out
   3581 FFFF2E2E B03C 000D                   	CMP.B	#CR,D0	;	if it's a CR, end the line
   3582 FFFF2E32 675C                        	BEQ	GL7
   3583 FFFF2E34 B1FC 0000 067F              	CMP.L	#(BUFFER+BUFLEN-1),A0	;any more room?
   3584 FFFF2E3A 65CE                        	BCS	GL1	;	yes: get some more, else delete last char.
   3585 FFFF2E3C                             GL3:
   3586 FFFF2E3C 103C 0008                   	MOVE.B	#CTRLH,D0	;delete a char. if possible
   3587 FFFF2E40 6100 F5C6                   	BSR	GOOUT
   3588 FFFF2E44 103C 0020                   	MOVE.B	#' ',D0
   3589 FFFF2E48 6100 F5BE                   	BSR	GOOUT
   3590 FFFF2E4C B1FC 0000 0630              	CMP.L	#BUFFER,A0	;any char.'s left?
   3591 FFFF2E52 63B6                        	BLS	GL1		;if not
   3592 FFFF2E54 103C 0008                   	MOVE.B	#CTRLH,D0;	if so, finish the BS-space-BS sequence
   3593 FFFF2E58 6100 F5AE                   	BSR	GOOUT
   3594 FFFF2E5C 5388                        	SUBQ.L	#1,A0	;	decrement the text pointer
   3595 FFFF2E5E 60AA                        	BRA	GL1		;back for more
   3596 FFFF2E60                             GL4:
   3597 FFFF2E60 2208                        	MOVE.L	A0,D1	;	delete the whole line
   3598 FFFF2E62 0481 0000 0630              	SUB.L	#BUFFER,D1;	figure out how many backspaces we need
   3599 FFFF2E68 671E                        	BEQ	GL6		;if none needed, branch
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 61
BOOTROM.x68
   3600 FFFF2E6A 5381                        	SUBQ	#1,D1	;	adjust for DBRA
   3601 FFFF2E6C                             GL5:
   3602 FFFF2E6C 103C 0008                   	MOVE.B	#CTRLH,D0	;and display BS-space-BS sequences
   3603 FFFF2E70 6100 F596                   	BSR	GOOUT
   3604 FFFF2E74 103C 0020                   	MOVE.B	#' ',D0
   3605 FFFF2E78 6100 F58E                   	BSR	GOOUT
   3606 FFFF2E7C 103C 0008                   	MOVE.B	#CTRLH,D0
   3607 FFFF2E80 6100 F586                   	BSR	GOOUT
   3608 FFFF2E84 51C9 FFE6                   	DBRA	D1,GL5
   3609 FFFF2E88                             GL6:
   3610 FFFF2E88 41F8 0630                   	LEA	BUFFER,A0	;reinitialize the text pointer
   3611 FFFF2E8C 6000 FF7C                   	BRA	GL1		;and go back for more
   3612 FFFF2E90                             GL7:
   3613 FFFF2E90 103C 000A                   	MOVE.B	#LF,D0	;	echo a LF for the CR
   3614 FFFF2E94 6100 F572                   	BSR	GOOUT
   3615 FFFF2E98 4E75                        	RTS
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** FNDLN (& friends) ***
                                             ;*
                                             ;* 'FNDLN' finds a line with a given line no. (in D1) in the
                                             ;* text save area.  A1 is used as the text pointer. If the line
                                             ;* is found, A1 will point to the beginning of that line
                                             ;* (i.e. the high byte of the line no.), and flags are NC & Z.
                                             ;* If that line is not there and a line with a higher line no.
                                             ;* is found, A1 points there and flags are NC & NZ. If we reached
                                             ;* the end of the text save area and cannot find the line, flags
                                             ;* are C & NZ.
                                             ;* 'FNDLN' will initialize A1 to the beginning of the text save
                                             ;* area to start the search. Some other entries of this routine
                                             ;* will not initialize A1 and do the search.
                                             ;* 'FNDLNP' will start with A1 and search for the line no.
                                             ;* 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                                             ;* 'FNDSKP' uses A1 to find a CR, and then starts the search.
                                             ;*
   3637 FFFF2E9A                             FNDLN:
   3638 FFFF2E9A B2BC 0000 FFFF              	CMP.L	#0xFFFF,D1	;line no. must be < 65535
   3639 FFFF2EA0 6400 FF4E                   	BCC	QHOW
   3640 FFFF2EA4 2279 FFFF 241C              	MOVE.L	TXTBGN,A1	;init. the text save pointer
                                             
   3642 FFFF2EAA                             FNDLNP:
   3643 FFFF2EAA 2478 0624                   	MOVE.L	TXTUNF,A2	;check if we passed the end
   3644 FFFF2EAE 538A                        	SUBQ.L	#1,A2
   3645 FFFF2EB0 B5C9                        	CMPA.L	A1,A2
   3646 FFFF2EB2 650C                        	BCS	FNDRET	;	if so, return with Z=0 & C=1
   3647 FFFF2EB4 1411                        	MOVE.B	(A1),D2	;if not, get a line no.
   3648 FFFF2EB6 E14A                        	LSL.W	#8,D2
   3649 FFFF2EB8 1429 0001                   	MOVE.B	1(A1),D2
   3650 FFFF2EBC B441                        	CMP.W	D1,D2		;is this the line we want?
   3651 FFFF2EBE 6502                        	BCS	FNDNXT		;no, not there yet
   3652 FFFF2EC0                             FNDRET:
   3653 FFFF2EC0 4E75                        	RTS			;return the cond. codes
                                             
   3655 FFFF2EC2                             FNDNXT:
   3656 FFFF2EC2 5489                        	ADDQ.L	#2,A1;		find the next line
                                             
   3658 FFFF2EC4                             FNDSKP:
   3659 FFFF2EC4 0C19 000D                   	CMP.B	#CR,(A1)+	;try to find a CR
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 62
BOOTROM.x68
   3660 FFFF2EC8 66FA                        	BNE	FNDSKP		;keep looking
   3661 FFFF2ECA 60DE                        	BRA	FNDLNP		;check if end of text
                                             
                                             ;*
                                             ;*******************************************************************
                                             ;*
                                             ;* *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                                             ;*
                                             ;* 'MVUP' moves a block up from where A1 points to where A2 points
                                             ;* until A1=A3
                                             ;*
                                             ;* 'MVDOWN' moves a block down from where A1 points to where A3
                                             ;* points until A1=A2
                                             ;*
                                             ;* 'POPA' restores the 'FOR' loop variable save area from the stack
                                             ;*
                                             ;* 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                             ;*
   3678 FFFF2ECC                             MVUP:
   3679 FFFF2ECC B7C9                        	CMP.L	A1,A3	;	see the above description
   3680 FFFF2ECE 6704                        	BEQ	MVRET
   3681 FFFF2ED0 14D9                        	MOVE.B	(A1)+,(A2)+
   3682 FFFF2ED2 60F8                        	BRA	MVUP
   3683 FFFF2ED4                             MVRET:
   3684 FFFF2ED4 4E75                        	RTS
                                             
   3686 FFFF2ED6                             MVDOWN:
   3687 FFFF2ED6 B5C9                        	CMP.L	A1,A2	;	see the above description
   3688 FFFF2ED8 67FA                        	BEQ	MVRET
   3689 FFFF2EDA 1721                        	MOVE.B	-(A1),-(A3)
   3690 FFFF2EDC 60F8                        	BRA	MVDOWN
                                             
   3692 FFFF2EDE                             POPA:
   3693 FFFF2EDE 2C5F                        	MOVE.L	(SP)+,A6	;A6 = return address
   3694 FFFF2EE0 21DF 0610                   	MOVE.L	(SP)+,LOPVAR	;restore LOPVAR, but zero means no more
   3695 FFFF2EE4 6710                        	BEQ	PP1
   3696 FFFF2EE6 21DF 0614                   	MOVE.L	(SP)+,LOPINC	;if not zero, restore the rest
   3697 FFFF2EEA 21DF 0618                   	MOVE.L	(SP)+,LOPLMT
   3698 FFFF2EEE 21DF 061C                   	MOVE.L	(SP)+,LOPLN
   3699 FFFF2EF2 21DF 0620                   	MOVE.L	(SP)+,LOPPT
   3700 FFFF2EF6                             PP1:
   3701 FFFF2EF6 4ED6                        	JMP	(A6)	;	return
                                             
   3703 FFFF2EF8                             PUSHA:
   3704 FFFF2EF8 2238 062C                   	MOVE.L	STKLMT,D1	;Are we running out of stack room?
   3705 FFFF2EFC 928F                        	SUB.L	SP,D1
   3706 FFFF2EFE 6400 FEE6                   	BCC		QSORRY		;if so, say we're sorry
   3707 FFFF2F02 2C5F                        	MOVE.L	(SP)+,A6	;else get the return address
   3708 FFFF2F04 2238 0610                   	MOVE.L	LOPVAR,D1	;save loop variables
   3709 FFFF2F08 6710                        	BEQ		PU1		;if LOPVAR is zero, that's all
   3710 FFFF2F0A 2F38 0620                   	MOVE.L	LOPPT,-(SP)	;else save all the others
   3711 FFFF2F0E 2F38 061C                   	MOVE.L	LOPLN,-(SP)
   3712 FFFF2F12 2F38 0618                   	MOVE.L	LOPLMT,-(SP)
   3713 FFFF2F16 2F38 0614                   	MOVE.L	LOPINC,-(SP)
   3714 FFFF2F1A                             PU1:
   3715 FFFF2F1A 2F01                        	MOVE.L	D1,-(SP)
   3716 FFFF2F1C 4ED6                        	JMP	(A6)		;return
                                             
                                             ;*
                                             ;*******************************************************************
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 63
BOOTROM.x68
                                             ;*
                                             ;* *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                             ;*
                                             ;* 'PRTSTG' prints a string pointed to by A1. It stops printing
                                             ;* and returns to the caller when either a CR is printed or when
                                             ;* the next byte is the same as what was passed in D0 by the
                                             ;* caller.
                                             ;*
                                             ;* 'QTSTG' looks for an underline (back-arrow on some systems),
                                             ;* single-quote, or double-quote.  If none of these are found, returns
                                             ;* to the caller.  If underline, outputs a CR without a LF.  If single
                                             ;* or double quote, prints the quoted string and demands a matching
                                             ;* end quote.  After the printing, the next 2 bytes of the caller are
                                             ;* skipped over (usually a short branch instruction).
                                             ;*
                                             ;* 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                                             ;* needed to pad the number of spaces to the number in D4.
                                             ;* However, if the number of digits is larger than the no. in
                                             ;* D4, all digits are printed anyway. Negative sign is also
                                             ;* printed and counted in, positive sign is not.
                                             ;*
                                             ;* 'PRTLN' prints the saved text line pointed to by A1
                                             ;* with line no. and all.
                                             ;*
   3744 FFFF2F1E                             PRTSTG:
   3745 FFFF2F1E 1200                        	MOVE.B	D0,D1	;	save the stop character
   3746 FFFF2F20                             PS1:
   3747 FFFF2F20 1019                        	MOVE.B	(A1)+,D0	;get a text character
   3748 FFFF2F22 B200                        	CMP.B	D0,D1		;same as stop character?
   3749 FFFF2F24 6712                        	BEQ		PRTRET		;if so, return
   3750 FFFF2F26 6100 F4E0                   	BSR		GOOUT		;display the char.
   3751 FFFF2F2A B03C 000D                   	CMP.B	#CR,D0		;;is it a C.R.?
   3752 FFFF2F2E 66F0                        	BNE		PS1		;no, go back for more
   3753 FFFF2F30 103C 000A                   	MOVE.B	#LF,D0	;	yes, add a L.F.
   3754 FFFF2F34 6100 F4D2                   	BSR		GOOUT
   3755 FFFF2F38                             PRTRET:
   3756 FFFF2F38 4E75                        	RTS			;then return
                                             
   3758 FFFF2F3A                             QTSTG:
   3759 FFFF2F3A 6100 0096                   	BSR.L	TSTC;		*** QTSTG ***
   3760 FFFF2F3E 22 1B                       	DC.B	'"',QT3-$
   3761 FFFF2F40 103C 0022                   	MOVE.B	#'"',D0  ;       it is a "
   3762 FFFF2F44                             QT1:
   3763 FFFF2F44 2248                        	MOVE.L	A0,A1
   3764 FFFF2F46 6100 FFD6                   	BSR	PRTSTG		;print until another
   3765 FFFF2F4A 2049                        	MOVE.L	A1,A0
   3766 FFFF2F4C 225F                        	MOVE.L	(SP)+,A1;	pop return address
   3767 FFFF2F4E B03C 000A                   	CMP.B	#LF,D0	;	was last one a CR?
   3768 FFFF2F52 6700 F71C                   	BEQ	RUNNXL		;if so, run next line
   3769 FFFF2F56                             QT2:
   3770 FFFF2F56 5489                        	ADDQ.L	#2,A1	;	skip 2 bytes on return
   3771 FFFF2F58 4ED1                        	JMP	(A1)		;return
   3772 FFFF2F5A                             QT3:
   3773 FFFF2F5A 6100 0076                   	BSR.L	TSTC	;	is it a single quote?
   3774 FFFF2F5E 27 07                       	DC.B	'\'',QT4-$
   3775 FFFF2F60 103C 0027                   	MOVE.B	#'''',D0  ;      if so, do same as above
   3776 FFFF2F64 60DE                        	BRA	QT1
   3777 FFFF2F66                             QT4:
   3778 FFFF2F66 6100 006A                   	BSR.L	TSTC		;is it an underline?
   3779 FFFF2F6A 5F 0D                       	DC.B	'_',QT5-$
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 64
BOOTROM.x68
   3780 FFFF2F6C 103C 000D                   	MOVE.B	#CR,D0		;if so, output a CR without LF
   3781 FFFF2F70 6100 F496                   	BSR.L	GOOUT
   3782 FFFF2F74 225F                        	MOVE.L	(SP)+,A1	;pop return address
   3783 FFFF2F76 60DE                        	BRA	QT2
   3784 FFFF2F78                             QT5:
   3785 FFFF2F78 4E75                        	RTS			;none of the above
                                             
   3787 FFFF2F7A                             PRTNUM:
   3788 FFFF2F7A 48E7 C844                   	movem.l	d0/d1/d4/a1/a5,-(a7)
   3789 FFFF2F7E 4BF8 0700                   	lea		scratch1,a5
   3790 FFFF2F82 2001                        	move.l	d1,d0
   3791 FFFF2F84 4EB9 FFFF 313E              	jsr		HEX2DEC
   3792 FFFF2F8A 4BF8 0700                   	lea		scratch1,a5
   3793 FFFF2F8E                             PN8:
   3794 FFFF2F8E 101D                        	move.b	(a5)+,d0
   3795 FFFF2F90 6704                        	beq		PN7
   3796 FFFF2F92 51CC FFFA                   	dbra    d4,PN8
   3797 FFFF2F96                             PN7:
   3798 FFFF2F96 4A44                        	tst.w	d4
   3799 FFFF2F98 6B0C                        	bmi		PN9
   3800 FFFF2F9A 103C 0020                   	MOVE.B	#' ',D0  ;       display the required leading spaces
   3801 FFFF2F9E 6100 F468                   	BSR		GOOUT
   3802 FFFF2FA2 51CC FFF2                   	DBRA	D4,PN7
   3803 FFFF2FA6                             PN9:
   3804 FFFF2FA6 43F8 0700                   	lea		scratch1,a1
   3805 FFFF2FAA 4EB9 FFFF 1858              	jsr		DisplayString
   3806 FFFF2FB0 4CDF 2213                   	movem.l	(a7)+,d0/d1/d4/a1/a5
   3807 FFFF2FB4 4E75                        	rts
                                             
                                             ;PRTNUM	
                                             ;	MOVE.L	D1,D3	;	save the number for later
                                             ;	MOVE.L	D4,-(SP)	;save the width value
                                             ;	MOVE.W	#0xFFFF,-(SP)	;flag for end of digit string
                                             ;	TST.L	D1		;is it negative?
                                             ;	BPL	PN1		;if not
                                             ;	NEG.L	D1	;	else make it positive
                                             ;	SUBQ	#1,D4	;	one less for width count
                                             ;PN1:
                                             ;	DIVU	#10,D1	;	get the next digit
                                             ;	BVS	PNOV	;	overflow flag set?
                                             ;	MOVE.L	D1,D0	;	if not, save remainder
                                             ;	AND.L	#0xFFFF,D1	;strip the remainder
                                             ;	BRA	TOASCII 	;skip the overflow stuff
                                             ;PNOV:
                                             ;	MOVE	D1,D0	;	prepare for long word division
                                             ;	CLR.W	D1		;zero out low word
                                             ;	SWAP	D1		;high word into low
                                             ;	DIVU	#10,D1	;	divide high word
                                             ;	MOVE	D1,D2	;	save quotient
                                             ;	MOVE	D0,D1	;	low word into low
                                             ;	DIVU	#10,D1	;	divide low word
                                             ;	MOVE.L	D1,D0	;	D0 = remainder
                                             ;	SWAP	D1		;	R/Q becomes Q/R
                                             ;	MOVE	D2,D1	;	D1 is low/high
                                             ;	SWAP	D1		;	D1 is finally high/low
                                             ;TOASCII:
                                             ;	SWAP	D0		;	get remainder
                                             ;	MOVE.W	D0,-(SP);	stack it as a digit
                                             ;	SWAP	D0
                                             ;	SUBQ	#1,D4	;	decrement width count
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 65
BOOTROM.x68
                                             ;	TST.L	D1		;if quotient is zero, we're done
                                             ;	BNE	PN1
                                             ;	SUBQ	#1,D4	;	adjust padding count for DBRA
                                             ;	BMI	PN4		;skip padding if not needed
                                             ;PN3:
                                             ;	MOVE.B	#' ',D0  ;       display the required leading spaces
                                             ;	BSR	GOOUT
                                             ;	DBRA	D4,PN3
                                             ;PN4:
                                             ;	TST.L	D3		;is number negative?
                                             ;	BPL	PN5
                                             ;	MOVE.B	#'-',D0  ;       if so, display the sign
                                             ;	BSR	GOOUT
                                             ;PN5:
                                             ;	MOVE.W	(SP)+,D0	;now unstack the digits and display
                                             ;	BMI	PNRET		;until the flag code is reached
                                             ;	ADD.B	#'0',D0   ;      make into ASCII
                                             ;	BSR	GOOUT
                                             ;	BRA	PN5
                                             ;PNRET:
                                             ;	MOVE.L	(SP)+,D4	;restore width value
                                             ;	RTS
                                             
   3863 FFFF2FB6                             PRTLN:
   3864 FFFF2FB6 4281                        	CLR.L	D1
   3865 FFFF2FB8 1219                        	MOVE.B	(A1)+,D1	;get the binary line number
   3866 FFFF2FBA E189                        	LSL	#8,D1
   3867 FFFF2FBC 1219                        	MOVE.B	(A1)+,D1
   3868 FFFF2FBE 7805                        	MOVEQ	#5,D4		;display a 5 digit line no.
   3869 FFFF2FC0 6100 FFB8                   	BSR	PRTNUM
   3870 FFFF2FC4 103C 0020                   	MOVE.B	#' ',D0      ;   followed by a blank
   3871 FFFF2FC8 6100 F43E                   	BSR	GOOUT
   3872 FFFF2FCC 4280                        	CLR	D0		;stop char. is a zero
   3873 FFFF2FCE 6000 FF4E                   	BRA	PRTSTG	;	display the rest of the line
                                             
                                             ;*
                                             ;* ===== Test text byte following the call to this subroutine. If it
                                             ;*	equals the byte pointed to by A0, return to the code following
                                             ;*	the call. If they are not equal, branch to the point
                                             ;*	indicated by the offset byte following the text byte.
                                             ;*
   3881 FFFF2FD2                             TSTC:
   3882 FFFF2FD2 6100 0050                   	BSR	IGNBLK		;ignore leading blanks
   3883 FFFF2FD6 225F                        	MOVE.L	(SP)+,A1	;get the return address
   3884 FFFF2FD8 1219                        	MOVE.B	(A1)+,D1	;get the byte to compare
   3885 FFFF2FDA B210                        	CMP.B	(A0),D1 	;is it = to what A0 points to?
   3886 FFFF2FDC 6708                        	BEQ	TC1		;if so
   3887 FFFF2FDE 4281                        	CLR.L	D1		;If not, add the second
   3888 FFFF2FE0 1211                        	MOVE.B	(A1),D1 ;	byte following the call to
   3889 FFFF2FE2 D3C1                        	ADD.L	D1,A1	;	the return address.
   3890 FFFF2FE4 4ED1                        	JMP	(A1)		;jump to the routine
   3891 FFFF2FE6                             TC1:
   3892 FFFF2FE6 5288                        	ADDQ.L	#1,A0	;	if equal, bump text pointer
   3893 FFFF2FE8 5289                        	ADDQ.L	#1,A1	;	Skip the 2 bytes following
   3894 FFFF2FEA 4ED1                        	JMP	(A1)		;the call and continue.
                                             
                                             ;*
                                             ;* ===== See if the text pointed to by A0 is a number. If so,
                                             ;*	return the number in D1 and the number of digits in D2,
                                             ;*	else return zero in D1 and D2.
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 66
BOOTROM.x68
                                             ;*
   3901 FFFF2FEC                             TSTNUM:
   3902 FFFF2FEC 4281                        	CLR.L	D1		;initialize return parameters
   3903 FFFF2FEE 4282                        	CLR	D2
   3904 FFFF2FF0 6100 0032                   	BSR	IGNBLK		;skip over blanks
   3905 FFFF2FF4                             TN1:
   3906 FFFF2FF4 0C10 0030                   	CMP.B	#'0',(A0) ;      is it less than zero?
   3907 FFFF2FF8 6528                        	BCS	TSNMRET 	;if so, that's all
   3908 FFFF2FFA 0C10 0039                   	CMP.B	#'9',(A0) ;      is it greater than nine?
   3909 FFFF2FFE 6222                        	BHI	TSNMRET 	;if so, return
   3910 FFFF3000 B2BC 0CCC CCCC              	CMP.L	#214748364,D1	;see if there's room for new digit
   3911 FFFF3006 6400 FDE8                   	BCC	QHOW		;if not, we've overflowd
   3912 FFFF300A 2001                        	MOVE.L	D1,D0	;	quickly multiply result by 10
   3913 FFFF300C D281                        	ADD.L	D1,D1
   3914 FFFF300E D281                        	ADD.L	D1,D1
   3915 FFFF3010 D280                        	ADD.L	D0,D1
   3916 FFFF3012 D281                        	ADD.L	D1,D1
   3917 FFFF3014 1018                        	MOVE.B	(A0)+,D0	;add in the new digit
   3918 FFFF3016 0280 0000 000F              	AND.L	#0xF,D0
   3919 FFFF301C D280                        	ADD.L	D0,D1
   3920 FFFF301E 5282                        	ADDQ	#1,D2		;increment the no. of digits
   3921 FFFF3020 60D2                        	BRA	TN1
   3922 FFFF3022                             TSNMRET:
   3923 FFFF3022 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Skip over blanks in the text pointed to by A0.
                                             ;*
   3928 FFFF3024                             IGNBLK:
   3929 FFFF3024 0C10 0020                   	CMP.B	#' ',(A0)   ;    see if it's a space
   3930 FFFF3028 6604                        	BNE	IGBRET		;if so, swallow it
   3931 FFFF302A                             IGB1:
   3932 FFFF302A 5288                        	ADDQ.L	#1,A0	;	increment the text pointer
   3933 FFFF302C 60F6                        	BRA	IGNBLK
   3934 FFFF302E                             IGBRET:
   3935 FFFF302E 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Convert the line of text in the input buffer to upper
                                             ;*	case (except for stuff between quotes).
                                             ;*
   3941 FFFF3030                             TOUPBUF:
   3942 FFFF3030 41F8 0630                   	LEA	BUFFER,A0	;set up text pointer
   3943 FFFF3034 4201                        	CLR.B	D1		;clear quote flag
   3944 FFFF3036                             TOUPB1:
   3945 FFFF3036 1018                        	MOVE.B	(A0)+,D0	;get the next text char.
   3946 FFFF3038 B03C 000D                   	CMP.B	#CR,D0		;is it end of line?
   3947 FFFF303C 671A                        	BEQ	TOUPBRT 	;if so, return
   3948 FFFF303E B03C 0022                   	CMP.B	#'"',D0  ;       a double quote?
   3949 FFFF3042 6716                        	BEQ	DOQUO
   3950 FFFF3044 B03C 0027                   	CMP.B	#'''',D0  ;      or a single quote?
   3951 FFFF3048 6710                        	BEQ	DOQUO
   3952 FFFF304A 4A01                        	TST.B	D1		;inside quotes?
   3953 FFFF304C 66E8                        	BNE	TOUPB1		;if so, do the next one
   3954 FFFF304E 6100 001A                   	BSR	TOUPPER 	;convert to upper case
   3955 FFFF3052 1100                        	MOVE.B	D0,-(A0);	store it
   3956 FFFF3054 5288                        	ADDQ.L	#1,A0
   3957 FFFF3056 60DE                        	BRA	TOUPB1		;and go back for more
   3958 FFFF3058                             TOUPBRT:
   3959 FFFF3058 4E75                        	RTS
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 67
BOOTROM.x68
                                             
   3961 FFFF305A                             DOQUO:
   3962 FFFF305A 4A01                        	TST.B	D1	;	are we inside quotes?
   3963 FFFF305C 6604                        	BNE	DOQUO1
   3964 FFFF305E 1200                        	MOVE.B	D0,D1	;	if not, toggle inside-quotes flag
   3965 FFFF3060 60D4                        	BRA	TOUPB1
   3966 FFFF3062                             DOQUO1:
   3967 FFFF3062 B200                        	CMP.B	D0,D1	;	make sure we're ending proper quote
   3968 FFFF3064 66D0                        	BNE	TOUPB1		;if not, ignore it
   3969 FFFF3066 4201                        	CLR.B	D1		;else clear quote flag
   3970 FFFF3068 60CC                        	BRA	TOUPB1
                                             
                                             ;*
                                             ;* ===== Convert the character in D0 to upper case
                                             ;*
   3975 FFFF306A                             TOUPPER:
   3976 FFFF306A B03C 0061                   	CMP.B	#'a',D0   ;      is it < 'a'?
   3977 FFFF306E 650A                        	BCS	TOUPRET
   3978 FFFF3070 B03C 007A                   	CMP.B	#'z',D0        ; or > 'z'?
   3979 FFFF3074 6204                        	BHI	TOUPRET
   3980 FFFF3076 0400 0020                   	SUB.B	#32,D0		;if not, make it upper case
   3981 FFFF307A                             TOUPRET:
   3982 FFFF307A 4E75                        	RTS
                                             
                                             ;*
                                             ;* 'CHKIO' checks the input. If there's no input, it will return
                                             ;* to the caller with the Z flag set. If there is input, the Z
                                             ;* flag is cleared and the input byte is in D0. However, if a
                                             ;* control-C is read, 'CHKIO' will warm-start BASIC and will not
                                             ;* return to the caller.
                                             ;*
   3991 FFFF307C                             CHKIO:
   3992 FFFF307C 6100 F38E                   	BSR.L	GOIN	;	get input if possible
   3993 FFFF3080 670A                        	BEQ	CHKRET		;if Zero, no input
   3994 FFFF3082 B03C 0003                   	CMP.B	#CTRLC,D0	;is it control-C?
   3995 FFFF3086 6604                        	BNE	CHKRET		;if not
   3996 FFFF3088 6000 F3D6                   	BRA.L	WSTART		;if so, do a warm start
   3997 FFFF308C                             CHKRET:
   3998 FFFF308C 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Display a CR-LF sequence
                                             ;*
   4003 FFFF308E                             CRLF1:
   4004 FFFF308E 4DF9 FFFF 313A              	LEA	CLMSG,A6
                                             
                                             ;*
                                             ;* ===== Display a zero-ended string pointed to by register A6
                                             ;*
   4009 FFFF3094                             PRMESG:
   4010 FFFF3094 101E                        	MOVE.B	(A6)+,D0	;get the char.
   4011 FFFF3096 6706                        	BEQ	PRMRET		;if it's zero, we're done
   4012 FFFF3098 6100 F36E                   	BSR	GOOUT		;else display it
   4013 FFFF309C 60F6                        	BRA	PRMESG
   4014 FFFF309E                             PRMRET:
   4015 FFFF309E 4E75                        	RTS
                                             
                                             ;******************************************************
                                             ;* The following routines are the only ones that need *
                                             ;* to be changed for a different I/O environment.     *
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 68
BOOTROM.x68
                                             ;******************************************************
                                             
                                             ;UART		EQU		0xFFDC0A00
                                             ;UART_LS		EQU		UART+1
                                             ;UART_CTRL	EQU		UART+7
                                             ;KEYBD		EQU		0xFFDC0000
                                             
                                             
                                             ;*
                                             ;* ===== Output character to the console (Port 1) from register D0
                                             ;*	(Preserves all registers.)
                                             ;*
   4032 FFFF30A0                             OUTC:
   4033 FFFF30A0 48E7 C000                   	MOVEM.L	D0/D1,-(SP)
   4034 FFFF30A4 2200                        	MOVE.L	D0,D1
   4035 FFFF30A6 4EB9 FFFF 1732              	JSR		DisplayChar
   4036 FFFF30AC 4CDF 0003                   	MOVEM.L	(SP)+,D0/D1
   4037 FFFF30B0 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Input a character from the console into register D0 (or
                                             ;*	return Zero status if there's no character available).
                                             ;*
   4043 FFFF30B2                             INC:
   4044 FFFF30B2 3039 FFDC 0000              	MOVE.W	KEYBD,D0	;is character ready?
   4045 FFFF30B8 6A0C                        	BPL		INCRET0		;if not, return Zero status
   4046 FFFF30BA 4279 FFDC 0002              	CLR.W	KEYBD+2		; clear keyboard strobe line
   4047 FFFF30C0 0240 00FF                   	AND.W	#0xFF,D0 	;zero out the high bit
   4048 FFFF30C4 4E75                        	RTS
   4049 FFFF30C6                             INCRET0
   4050 FFFF30C6 7000                        	MOVEQ	#0,D0
   4051 FFFF30C8 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Output character to the host (Port 2) from register D0
                                             ;*	(Preserves all registers.)
                                             ;*
   4057 FFFF30CA                             AUXOUT:
   4058 FFFF30CA 0839 0005 FFDC 0A01         	BTST	#5,UART_LS	;is port ready for a character?
   4059 FFFF30D2 67F6                        	BEQ		AUXOUT		;if not, wait for it
   4060 FFFF30D4 13C0 FFDC 0A00              	MOVE.B	D0,UART		;out it goes.
   4061 FFFF30DA 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Input a character from the host into register D0 (or
                                             ;*	return Zero status if there's no character available).
                                             ;*
   4067 FFFF30DC                             AUXIN:
   4068 FFFF30DC 0839 0000 FFDC 0A01         	BTST	#0,UART_LS	;is character ready?
   4069 FFFF30E4 670A                        	BEQ		AXIRET		;if not, return Zero status
   4070 FFFF30E6 1039 FFDC 0A00              	MOVE.B	UART,D0		;else get the character
   4071 FFFF30EC 0200 007F                   	AND.B	#0x7F,D0 	;zero out the high bit
   4072 FFFF30F0                             AXIRET:
   4073 FFFF30F0 4E75                        	RTS
                                             
                                             ;*
                                             ;* ===== Return to the resident monitor, operating system, etc.
                                             ;*
   4078 FFFF30F2                             BYEBYE:
   4079 FFFF30F2 4EF9 FFFF 1A7A              	JMP		Monitor
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 69
BOOTROM.x68
                                             ;    MOVE.B	#228,D7 	;return to Tutor
                                             ;	TRAP	#14
                                             
   4083 FFFF30F8                             INITMSG:
   4084 FFFF30F8 0D 0A 47 6F 72 64 6F 27     	DC.B	CR,LF,'Gordo\'s MC68000 Tiny BASIC, v1.3',CR,LF,LF,0
   4085 FFFF3100 73 20 4D 43 36 38 30 30     
   4086 FFFF3108 30 20 54 69 6E 79 20 42     
   4087 FFFF3110 41 53 49 43 2C 20 76 31     
   4088 FFFF3118 2E 33 0D 0A 0A 00           
   4089 FFFF311E                             OKMSG:
   4090 FFFF311E 0D 0A 4F 4B 0D 0A 00        	DC.B	CR,LF,'OK',CR,LF,0
   4091 FFFF3125                             HOWMSG:
   4092 FFFF3125 48 6F 77 3F 0D 0A 00        	DC.B	'How?',CR,LF,0
   4093 FFFF312C                             WHTMSG:
   4094 FFFF312C 57 68 61 74 3F 0D 0A 00     	DC.B	'What?',CR,LF,0
                                             
   4096 FFFF3134                             SRYMSG:
   4097 FFFF3134 53 6F 72 72 79 2E           	DC.B	'Sorry.'
   4098 FFFF313A                             CLMSG:
   4099 FFFF313A 0D 0A 00                    	DC.B	CR,LF,0
                                             ;	DC.B	0	;<- for aligning on a word boundary
   4101 FFFF313D FF                         	even
                                             	
                                             LSTROM	EQU		$
                                             	;	end of possible ROM area
                                             
                                             ;**************************************************************************
                                             ; The portion of code within STAR lines are modified from Tutor source code
                                             ;
                                             ;
                                             ; HEX2DEC   HEX2DEC convert hex to decimal                   
                                             ; CONVERT BINARY TO DECIMAL  REG D0 PUT IN (A5) BUFFER AS ASCII
                                             
   4113 FFFF313E 48 E77F 00                  HEX2DEC  MOVEM.L D1/D2/D3/D4/D5/D6/D7,-(SP)   ;SAVE REGISTERS
   4114 FFFF3142 2E00                                 MOVE.L  D0,D7               ;SAVE IT HERE
   4115 FFFF3144 6A08                                 BPL.S   HX2DC
   4116 FFFF3146 4487                                 NEG.L   D7             ;CHANGE TO POSITIVE
   4117 FFFF3148 6B4E                                 BMI.S   HX2DC57        ;SPECIAL CASE (-0)
   4118 FFFF314A 1AFC 002D                            MOVE.B  #'-',(A5)+     ;PUT IN NEG SIGN
   4119 FFFF314E 4244                        HX2DC    CLR.W   D4             ;FOR ZERO SURPRESS
   4120 FFFF3150 7C0A                                 MOVEQ.L   #10,D6         ;COUNTER
   4121 FFFF3152 7401                        HX2DC0   MOVEQ.L   #1,D2          ;VALUE TO SUB
   4122 FFFF3154 2206                                 MOVE.L  D6,D1          ;COUNTER
   4123 FFFF3156 5381                                 SUBQ.L  #1,D1          ;ADJUST - FORM POWER OF TEN
   4124 FFFF3158 671A                                 BEQ.S   HX2DC2         ;IF POWER IS ZERO
   4125 FFFF315A 3602                        HX2DC1   MOVE.W  D2,D3          ;D3=LOWER WORD
   4126 FFFF315C C6FC 000A                            MULU.W    #10,D3
   4127 FFFF3160 4842                                 SWAP.W    D2             ;D2=UPPER WORD
   4128 FFFF3162 C4FC 000A                            MULU.W    #10,D2
   4129 FFFF3166 4843                                 SWAP.W    D3             ;ADD UPPER TO UPPER
   4130 FFFF3168 D443                                 ADD.W   D3,D2
   4131 FFFF316A 4842                                 SWAP.W    D2             ;PUT UPPER IN UPPER
   4132 FFFF316C 4843                                 SWAP.W    D3             ;PUT LOWER IN LOWER
   4133 FFFF316E 3403                                 MOVE.W  D3,D2          ;D2=UPPER & LOWER
   4134 FFFF3170 5381                                 SUBQ.L  #1,D1
   4135 FFFF3172 66E6                                 BNE     HX2DC1
   4136 FFFF3174 4280                        HX2DC2   CLR.L   D0             ;HOLDS SUB AMT
   4137 FFFF3176 BE82                        HX2DC22  CMP.L   D2,D7
   4138 FFFF3178 6D06                                 BLT.S   HX2DC3         ;IF NO MORE SUB POSSIBLE
   4139 FFFF317A 5280                                 ADDQ.L  #1,D0          ;BUMP SUBS
FPGAfield asm68 assembler    version 5.1   Fri Sep 23 07:24:21 2011     Page 70
BOOTROM.x68
   4140 FFFF317C 9E82                                 SUB.L   D2,D7          ;COUNT DOWN BY POWERS OF TEN
   4141 FFFF317E 60F6                                 BRA.S   HX2DC22        ;DO MORE
   4142 FFFF3180 4A00                        HX2DC3   TST.B   D0             ;ANY VALUE?
   4143 FFFF3182 6604                                 BNE.S   HX2DC4
   4144 FFFF3184 4A44                                 TST.W   D4             ;ZERO SURPRESS
   4145 FFFF3186 6708                                 BEQ.S   HX2DC5
   4146 FFFF3188 0600 0030                   HX2DC4   ADDI.B  #0x30,D0        ;BINARY TO ASCII
   4147 FFFF318C 1AC0                                 MOVE.B  D0,(A5)+       ;PUT IN BUFFER
   4148 FFFF318E 1800                                 MOVE.B  D0,D4          ;MARK AS NON ZERO SURPRESS
   4149 FFFF3190 5386                        HX2DC5   SUBQ.L  #1,D6          ;NEXT POWER
   4150 FFFF3192 66BE                                 BNE     HX2DC0
   4151 FFFF3194 4A44                                 TST.W   D4             ;SEE IF ANYTHING PRINTED
   4152 FFFF3196 6604                                 BNE.S   HX2DC6
   4153 FFFF3198 1AFC 0030                   HX2DC57  MOVE.B  #'0',(A5)+     ;PRINT AT LEST A ZERO
   4154 FFFF319C 1ABC 0000                   HX2DC6   MOVE.B  #0,(A5)        ; PUT TERMINATOR
   4155 FFFF31A0 4CDF 00FE                            MOVEM.L (SP)+,D1/D2/D3/D4/D5/D6/D7   ;RESTORE REGISTERS
   4156 FFFF31A4 4E75                                 RTS                    ;END OF ROUTINE
                                             
                                             ;******************************************************************************
