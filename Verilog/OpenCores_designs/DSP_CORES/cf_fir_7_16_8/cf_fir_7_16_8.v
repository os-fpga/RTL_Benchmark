//
//  Copyright (c) 2003 Launchbird Design Systems, Inc.
//  All rights reserved.
//  
//  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
//  
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
//  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
//  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
//  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//  
//  
//  Overview:
//  
//    Performs finite impulse response (FIR) filtering.
//    The filter's sum of products is pipelined with a register after
//    every multiplier and adder.  The adder network is a balanced binary
//    tree to minimize latency.  The sum of products has no numeric loss because the
//    multipliers keep all resulting bits and each adder extends the precision by 1.
//  
//  Interface:
//  
//    Synchronization:
//      clock_c  : Clock input.
//      reset_i  : Filter delay bank synchronous reset.  Does not reset sum of products pipeline registers.
//  
//    Inputs:
//      data_i  : Input data.
//      k0_i    : Coefficient 0 multiplied by in_i(0).
//      k1_i    : Coefficient 1 multiplied by in_i(k-1).
//      k2_i    : Coefficient 2 multiplied by in_i(k-2).
//      ...
//      k<order>_i : Coefficient <order> multiplied by in_i(k-<order>).
//  
//    Outputs:
//      data_o : Output data.
//  
//  Built In Parameters:
//  
//    Filter Order             = 7
//    Input Precision          = 16
//    Coefficient Precision    = 8
//    Sum of Products Latency  = 4
//  
//  
//  
//  
//  Generated by Confluence 0.6.3  --  Launchbird Design Systems, Inc.  --  www.launchbird.com
//  
//  Build Date : Fri Aug 22 09:45:48 CDT 2003
//  
//  Interface
//  
//    Build Name    : cf_fir_7_16_8
//    Clock Domains : clock_c  
//    Vector Input  : reset_i(1)
//    Vector Input  : data_i(16)
//    Vector Input  : k0_i(8)
//    Vector Input  : k1_i(8)
//    Vector Input  : k2_i(8)
//    Vector Input  : k3_i(8)
//    Vector Input  : k4_i(8)
//    Vector Input  : k5_i(8)
//    Vector Input  : k6_i(8)
//    Vector Input  : k7_i(8)
//    Vector Output : data_o(27)
//  
//  
//  

`timescale 1 ns / 1 ns

module cf_fir_7_16_8 (clock_c, reset_i, data_i, k0_i, k1_i, k2_i, k3_i, k4_i, k5_i, k6_i, k7_i, data_o);
input  clock_c;
input  reset_i;
input  [15:0] data_i;
input  [7:0] k0_i;
input  [7:0] k1_i;
input  [7:0] k2_i;
input  [7:0] k3_i;
input  [7:0] k4_i;
input  [7:0] k5_i;
input  [7:0] k6_i;
input  [7:0] k7_i;
output [26:0] data_o;
wire   [26:0] n1;
cf_fir_7_16_8_1 s1 (clock_c, reset_i, k0_i, k1_i, k2_i, k3_i, k4_i, k5_i, k6_i, k7_i, data_i, n1);
assign data_o = n1;
endmodule

module cf_fir_7_16_8_1 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, o1);
input  clock_c;
input  i1;
input  [7:0] i2;
input  [7:0] i3;
input  [7:0] i4;
input  [7:0] i5;
input  [7:0] i6;
input  [7:0] i7;
input  [7:0] i8;
input  [7:0] i9;
input  [15:0] i10;
output [26:0] o1;
wire   n1;
wire   n2;
wire   [26:0] s3_1;
wire   [23:0] s4_1;
wire   [23:0] s4_2;
wire   [23:0] s4_3;
wire   [23:0] s4_4;
wire   [23:0] s4_5;
wire   [23:0] s4_6;
wire   [23:0] s4_7;
wire   [23:0] s4_8;
wire   [15:0] s5_1;
wire   [15:0] s5_2;
wire   [15:0] s5_3;
wire   [15:0] s5_4;
wire   [15:0] s5_5;
wire   [15:0] s5_6;
wire   [15:0] s5_7;
wire   [15:0] s5_8;
assign n1 = 1'b1;
assign n2 = 1'b0;
cf_fir_7_16_8_5 s3 (clock_c, n1, n2, s4_1, s4_2, s4_3, s4_4, s4_5, s4_6, s4_7, s4_8, s3_1);
cf_fir_7_16_8_3 s4 (clock_c, n1, n2, i2, i3, i4, i5, i6, i7, i8, i9, s5_1, s5_2, s5_3, s5_4, s5_5, s5_6, s5_7, s5_8, s4_1, s4_2, s4_3, s4_4, s4_5, s4_6, s4_7, s4_8);
cf_fir_7_16_8_2 s5 (clock_c, n1, i1, i10, s5_1, s5_2, s5_3, s5_4, s5_5, s5_6, s5_7, s5_8);
assign o1 = s3_1;
endmodule

module cf_fir_7_16_8_2 (clock_c, i1, i2, i3, o1, o2, o3, o4, o5, o6, o7, o8);
input  clock_c;
input  i1;
input  i2;
input  [15:0] i3;
output [15:0] o1;
output [15:0] o2;
output [15:0] o3;
output [15:0] o4;
output [15:0] o5;
output [15:0] o6;
output [15:0] o7;
output [15:0] o8;
reg    [15:0] n1;
reg    [15:0] n2;
reg    [15:0] n3;
reg    [15:0] n4;
reg    [15:0] n5;
reg    [15:0] n6;
reg    [15:0] n7;
reg    [15:0] n8;
initial n1 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n1 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n1 <= i3;
initial n2 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n2 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n2 <= n1;
initial n3 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n3 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n3 <= n2;
initial n4 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n4 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n4 <= n3;
initial n5 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n5 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n5 <= n4;
initial n6 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n6 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n6 <= n5;
initial n7 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n7 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n7 <= n6;
initial n8 = 16'b0000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n8 <= 16'b0000000000000000;
  else if (i1 == 1'b1)
    n8 <= n7;
assign o8 = n8;
assign o7 = n7;
assign o6 = n6;
assign o5 = n5;
assign o4 = n4;
assign o3 = n3;
assign o2 = n2;
assign o1 = n1;
endmodule

module cf_fir_7_16_8_3 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, o1, o2, o3, o4, o5, o6, o7, o8);
input  clock_c;
input  i1;
input  i2;
input  [7:0] i3;
input  [7:0] i4;
input  [7:0] i5;
input  [7:0] i6;
input  [7:0] i7;
input  [7:0] i8;
input  [7:0] i9;
input  [7:0] i10;
input  [15:0] i11;
input  [15:0] i12;
input  [15:0] i13;
input  [15:0] i14;
input  [15:0] i15;
input  [15:0] i16;
input  [15:0] i17;
input  [15:0] i18;
output [23:0] o1;
output [23:0] o2;
output [23:0] o3;
output [23:0] o4;
output [23:0] o5;
output [23:0] o6;
output [23:0] o7;
output [23:0] o8;
wire   [23:0] n1;
reg    [23:0] n2;
wire   [23:0] n3;
reg    [23:0] n4;
wire   [23:0] n5;
reg    [23:0] n6;
wire   [23:0] n7;
reg    [23:0] n8;
wire   [23:0] s9_1;
wire   [23:0] s9_2;
wire   [23:0] s9_3;
wire   [23:0] s9_4;
assign n1 = {{16{1'b0}}, i3} * {{8{1'b0}}, i11};
initial n2 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n2 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n2 <= n1;
assign n3 = {{16{1'b0}}, i4} * {{8{1'b0}}, i12};
initial n4 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n4 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n4 <= n3;
assign n5 = {{16{1'b0}}, i5} * {{8{1'b0}}, i13};
initial n6 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n6 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n6 <= n5;
assign n7 = {{16{1'b0}}, i6} * {{8{1'b0}}, i14};
initial n8 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n8 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n8 <= n7;
cf_fir_7_16_8_4 s9 (clock_c, i1, i2, i7, i8, i9, i10, i15, i16, i17, i18, s9_1, s9_2, s9_3, s9_4);
assign o8 = s9_4;
assign o7 = s9_3;
assign o6 = s9_2;
assign o5 = s9_1;
assign o4 = n8;
assign o3 = n6;
assign o2 = n4;
assign o1 = n2;
endmodule

module cf_fir_7_16_8_4 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, o1, o2, o3, o4);
input  clock_c;
input  i1;
input  i2;
input  [7:0] i3;
input  [7:0] i4;
input  [7:0] i5;
input  [7:0] i6;
input  [15:0] i7;
input  [15:0] i8;
input  [15:0] i9;
input  [15:0] i10;
output [23:0] o1;
output [23:0] o2;
output [23:0] o3;
output [23:0] o4;
wire   [23:0] n1;
reg    [23:0] n2;
wire   [23:0] n3;
reg    [23:0] n4;
wire   [23:0] n5;
reg    [23:0] n6;
wire   [23:0] n7;
reg    [23:0] n8;
assign n1 = {{16{1'b0}}, i3} * {{8{1'b0}}, i7};
initial n2 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n2 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n2 <= n1;
assign n3 = {{16{1'b0}}, i4} * {{8{1'b0}}, i8};
initial n4 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n4 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n4 <= n3;
assign n5 = {{16{1'b0}}, i5} * {{8{1'b0}}, i9};
initial n6 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n6 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n6 <= n5;
assign n7 = {{16{1'b0}}, i6} * {{8{1'b0}}, i10};
initial n8 = 24'b000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n8 <= 24'b000000000000000000000000;
  else if (i1 == 1'b1)
    n8 <= n7;
assign o4 = n8;
assign o3 = n6;
assign o2 = n4;
assign o1 = n2;
endmodule

module cf_fir_7_16_8_5 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, o1);
input  clock_c;
input  i1;
input  i2;
input  [23:0] i3;
input  [23:0] i4;
input  [23:0] i5;
input  [23:0] i6;
input  [23:0] i7;
input  [23:0] i8;
input  [23:0] i9;
input  [23:0] i10;
output [26:0] o1;
wire   n1;
wire   [26:0] n2;
wire   n3;
wire   [26:0] n4;
wire   [26:0] n5;
reg    [26:0] n6;
wire   [25:0] s7_1;
wire   [25:0] s7_2;
wire   [24:0] s8_1;
wire   [24:0] s8_2;
wire   [24:0] s8_3;
wire   [24:0] s8_4;
assign n1 = s7_1[25];
assign n2 = {n1, s7_1};
assign n3 = s7_2[25];
assign n4 = {n3, s7_2};
assign n5 = n2 + n4;
initial n6 = 27'b000000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n6 <= 27'b000000000000000000000000000;
  else if (i1 == 1'b1)
    n6 <= n5;
cf_fir_7_16_8_8 s7 (clock_c, i1, i2, s8_1, s8_2, s8_3, s8_4, s7_1, s7_2);
cf_fir_7_16_8_6 s8 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, s8_1, s8_2, s8_3, s8_4);
assign o1 = n6;
endmodule

module cf_fir_7_16_8_6 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, o1, o2, o3, o4);
input  clock_c;
input  i1;
input  i2;
input  [23:0] i3;
input  [23:0] i4;
input  [23:0] i5;
input  [23:0] i6;
input  [23:0] i7;
input  [23:0] i8;
input  [23:0] i9;
input  [23:0] i10;
output [24:0] o1;
output [24:0] o2;
output [24:0] o3;
output [24:0] o4;
wire   n1;
wire   [24:0] n2;
wire   n3;
wire   [24:0] n4;
wire   [24:0] n5;
reg    [24:0] n6;
wire   n7;
wire   [24:0] n8;
wire   n9;
wire   [24:0] n10;
wire   [24:0] n11;
reg    [24:0] n12;
wire   [24:0] s13_1;
wire   [24:0] s13_2;
assign n1 = i3[23];
assign n2 = {n1, i3};
assign n3 = i4[23];
assign n4 = {n3, i4};
assign n5 = n2 + n4;
initial n6 = 25'b0000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n6 <= 25'b0000000000000000000000000;
  else if (i1 == 1'b1)
    n6 <= n5;
assign n7 = i5[23];
assign n8 = {n7, i5};
assign n9 = i6[23];
assign n10 = {n9, i6};
assign n11 = n8 + n10;
initial n12 = 25'b0000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n12 <= 25'b0000000000000000000000000;
  else if (i1 == 1'b1)
    n12 <= n11;
cf_fir_7_16_8_7 s13 (clock_c, i1, i2, i7, i8, i9, i10, s13_1, s13_2);
assign o4 = s13_2;
assign o3 = s13_1;
assign o2 = n12;
assign o1 = n6;
endmodule

module cf_fir_7_16_8_7 (clock_c, i1, i2, i3, i4, i5, i6, o1, o2);
input  clock_c;
input  i1;
input  i2;
input  [23:0] i3;
input  [23:0] i4;
input  [23:0] i5;
input  [23:0] i6;
output [24:0] o1;
output [24:0] o2;
wire   n1;
wire   [24:0] n2;
wire   n3;
wire   [24:0] n4;
wire   [24:0] n5;
reg    [24:0] n6;
wire   n7;
wire   [24:0] n8;
wire   n9;
wire   [24:0] n10;
wire   [24:0] n11;
reg    [24:0] n12;
assign n1 = i3[23];
assign n2 = {n1, i3};
assign n3 = i4[23];
assign n4 = {n3, i4};
assign n5 = n2 + n4;
initial n6 = 25'b0000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n6 <= 25'b0000000000000000000000000;
  else if (i1 == 1'b1)
    n6 <= n5;
assign n7 = i5[23];
assign n8 = {n7, i5};
assign n9 = i6[23];
assign n10 = {n9, i6};
assign n11 = n8 + n10;
initial n12 = 25'b0000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n12 <= 25'b0000000000000000000000000;
  else if (i1 == 1'b1)
    n12 <= n11;
assign o2 = n12;
assign o1 = n6;
endmodule

module cf_fir_7_16_8_8 (clock_c, i1, i2, i3, i4, i5, i6, o1, o2);
input  clock_c;
input  i1;
input  i2;
input  [24:0] i3;
input  [24:0] i4;
input  [24:0] i5;
input  [24:0] i6;
output [25:0] o1;
output [25:0] o2;
wire   n1;
wire   [25:0] n2;
wire   n3;
wire   [25:0] n4;
wire   [25:0] n5;
reg    [25:0] n6;
wire   n7;
wire   [25:0] n8;
wire   n9;
wire   [25:0] n10;
wire   [25:0] n11;
reg    [25:0] n12;
assign n1 = i3[24];
assign n2 = {n1, i3};
assign n3 = i4[24];
assign n4 = {n3, i4};
assign n5 = n2 + n4;
initial n6 = 26'b00000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n6 <= 26'b00000000000000000000000000;
  else if (i1 == 1'b1)
    n6 <= n5;
assign n7 = i5[24];
assign n8 = {n7, i5};
assign n9 = i6[24];
assign n10 = {n9, i6};
assign n11 = n8 + n10;
initial n12 = 26'b00000000000000000000000000;
always @ (posedge clock_c)
  if (i2 == 1'b1)
    n12 <= 26'b00000000000000000000000000;
  else if (i1 == 1'b1)
    n12 <= n11;
assign o2 = n12;
assign o1 = n6;
endmodule

